@node ccnames
@appendix Automatically generated @api{} names


The header file @file{ccnames.h} defines a set of macros that generate, at expansion time,
identifiers for functions and variables that have ``well known'' roles in the @api{} of the
CCLibraries projects.

@menu
* ccnames struct common::       Well known functions for @struct{} types.
* ccnames struct table::        Tables of methods for @struct{} types.
* ccnames iface::               Well known names for interface types.
@end menu

@c page
@node ccnames struct common
@appendixsec Well known functions for @struct{} types


The macros for ``well known functions'' define an @api{} for the basic operations upon a data
@struct{}.  The following macros are defined in the header file @file{ccnames.h}.


@defmac ccname_type (@var{STRUCT_TYPE})
@defmacx ccname_type (@var{STRUCT_TYPE}, @var{VARIANT})
@defmacx ccname_type (@var{STRUCT_TYPE}, @vari{VARIANT}, @varii{VARIANT})
@defmacx ccname_type (@var{STRUCT_TYPE}, @vari{VARIANT}, @varii{VARIANT}, @variii{VARIANT})
Given a @struct{} type name and an optional variant specification: expand into the name of a derived
type.  We can use this macro to define a type derived (specialised) from another one.
@end defmac


@defmac ccname_init (@var{STRUCT_TYPE})
@defmacx ccname_init (@var{STRUCT_TYPE}, @var{VARIANT})
@defmacx ccname_init (@var{STRUCT_TYPE}, @vari{VARIANT}, @varii{VARIANT})
@defmacx ccname_init (@var{STRUCT_TYPE}, @vari{VARIANT}, @varii{VARIANT}, @variii{VARIANT})
Given a @struct{} type name and an optional variant specification: expand into the name of the
@api{} function @cfunc{init}.

Functions with this name are constructors for @struct{} instances allocated on the stack or embedded
into enclosing @struct{} instances.  They allocate all the asynchronous resources and initialise the
@struct{} fields.
@end defmac


@defmac ccname_final (@var{STRUCT_TYPE})
Given a @struct{} type name: expand into the name of the @api{} function @cfunc{final}.

Functions with this name are destructors for @struct{} instances allocated on the stack or embedded
into enclosing @struct{} instances.  They release all the asynchronous resources associated to the
@struct{} fields.
@end defmac


@defmac ccname_alloc (@var{STRUCT_TYPE})
Given a @struct{} type name: expand into the name of the @api{} function @cfunc{alloc}.

Functions of this type are memory allocators for @struct{} instances allocated on the heap.  They
might perform the allocation using the @api{} of the library CCMemory.
@end defmac


@defmac ccname_release (@var{STRUCT_TYPE})
Given a @struct{} type name: expand into the name of the @api{} function @cfunc{release}.

Functions of this type are memory releasers for @struct{} instances allocated on the heap.  They
might perform the release using the @api{} of the library CCMemory.
@end defmac


@defmac ccname_new (@var{STRUCT_TYPE})
@defmacx ccname_new (@var{STRUCT_TYPE}, @var{VARIANT})
@defmacx ccname_new (@var{STRUCT_TYPE}, @vari{VARIANT}, @varii{VARIANT})
@defmacx ccname_new (@var{STRUCT_TYPE}, @vari{VARIANT}, @varii{VARIANT}, @variii{VARIANT})
Given a @struct{} type name and an optional variant specification: expand into the name of the
@api{} function @cfunc{new}.

Functions with this name are constructors for @struct{} instances allocated on the heap.  The memory
allocation is performed by calling the @cfunc{alloc} function.  The initialisation of the fields is
performed by calling the @cfunc{init} function.
@end defmac


@defmac ccname_delete (@var{STRUCT_TYPE})
Given a @struct{} type name: expand into the name of the @api{} function @cfunc{delete}.

Functions with this name are destructors for @struct{} instances allocated on the heap.  The
finalisation of the fields is performed by calling the @cfunc{final} function.  The memory release
is performed by calling the @cfunc{release} function.
@end defmac


@defmac ccname_is (@var{STRUCT_IS})
@defmacx ccname_is (@var{STRUCT_IS}, @var{VARIANT})
@defmacx ccname_is (@var{STRUCT_IS}, @vari{VARIANT}, @varii{VARIANT})
@defmacx ccname_is (@var{STRUCT_IS}, @vari{VARIANT}, @varii{VARIANT}, @variii{VARIANT})
Given a @struct{} type name and an optional variant specification: expand into the name of the
@api{} function @cfunc{is}.
@end defmac


An example of common function implementation for @struct{} types:

@smallexample
#include <ccexceptions.h>
#include <ccmemory.h>
#include <ccnames.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

typedef struct my_coords_t      my_coords_t;

struct my_coords_t @{
  double        X;
  double        Y;
@};

void
ccname_init(my_coords_t, rec) (my_coords_t * S, double X, double Y)
@{
  S->X = X;
  S->Y = Y;
@}

void
ccname_init(my_coords_t, pol) (my_coords_t * S, double RHO, double THETA)
@{
  S->X = RHO * cos(THETA);
  S->Y = RHO * sin(THETA);
@}

void
ccname_final(my_coords_t) (my_coords_t * S)
@{
@}

static my_coords_t *
ccname_alloc(my_coords_t) (cce_destination_t L)
@{
  return (my_coords_t *)ccmem_std_malloc(L, sizeof(my_coords_t));
@}

static void
ccname_release(my_coords_t) (my_coords_t * S)
@{
  ccmem_std_free(S);
@}

my_coords_t *
ccname_new(my_coords_t, rec) (cce_destination_t L, double X, double Y)
@{
  my_coords_t * S = ccname_alloc(my_coords_t)(L);

  ccname_init(my_coords_t, rec)(S, X, Y);
  return S;
@}

my_coords_t *
ccname_new(my_coords_t, pol) (cce_destination_t L, double RHO, double THETA)
@{
  my_coords_t * S = ccname_alloc(my_coords_t)(L);

  ccname_init(my_coords_t, pol)(S, RHO, THETA);
  return S;
@}

void
ccname_delete(my_coords_t) (my_coords_t * S)
@{
  ccname_final(my_coords_t)(S);
  ccname_release(my_coords_t)(S);
@}

int
main (void)
@{
  cce_location_t        L[1];
  my_coords_t *         S;

  if (cce_location(L)) @{
    cce_run_catch_handlers_final(L);
  @} else @{
    S = ccname_new(my_coords_t, rec)(L, 1.0, 2.0);

    printf("X=%f, Y=%f\n", S->X, S->Y);
    ccname_delete(my_coords_t)(S);
  @}
  exit(EXIT_SUCCESS);
@}
@end smallexample

@c page
@node ccnames struct table
@appendixsec Tables of methods for @struct{} types


The macros for the ``table of methods known functions'' define an @api{} to implement a table of
methods in a data @struct{}: every instance of the @struct{} type is meant to hold a pointer to a
statically allocated @struct{} which in turn holds pointers to method functions.  The following
macros are defined in the header file @file{ccnames.h}.


@defmac ccname_table_type (@var{STRUCT_TYPE})
@defmacx ccname_table_type (@var{STRUCT_TYPE}, @var{VARIANT})
Given a @struct{} type name and an optional variant specification: expand into the name of the
methods table type for the @struct{} type.
@end defmac


@defmac ccname_table (@var{STRUCT_TYPE})
@defmacx ccname_table (@var{STRUCT_TYPE}, @var{VARIANT})
Given a @struct{} type name and an optional variant specification: expand into the name of the
methods table for the @struct{} type.
@end defmac


@defmac ccname_method_type (@var{STRUCT_TYPE}, @var{METHOD_NAME})
@defmacx ccname_method_type (@var{STRUCT_TYPE}, @var{VARIANT}, @var{METHOD_NAME})
Given a @struct{} type name, an optional variant specification, and a method name: expand into the
type name of that variant of the method function for the @struct{} type.
@end defmac


@defmac ccname_method (@var{STRUCT_TYPE}, @var{METHOD_NAME})
@defmacx ccname_method (@var{STRUCT_TYPE}, @var{VARIANT}, @var{METHOD_NAME})
Given a @struct{} type name, an optional variant specification, and a method name: expand into the
name of that variant of the method for that @struct{} type.
@end defmac


An example of methods table implementation for @struct{} types:

@smallexample
#include <ccexceptions.h>
#include <ccnames.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct my_coords_t                      my_coords_t;
typedef struct ccname_table_type(my_coords_t)   ccname_table_type(my_coords_t);

typedef void ccname_method_type(my_coords_t, print) (my_coords_t * S, FILE * stream);

struct my_coords_t @{
  ccname_table_type(my_coords_t) const * methods;
  double        X;
  double        Y;
@};

struct ccname_table_type(my_coords_t) @{
  ccname_method_type(my_coords_t, print) * print_rec;
  ccname_method_type(my_coords_t, print) * print_pol;
@};

static void
ccname_method(my_coords_t, print_rec) (my_coords_t * S, FILE * stream)
@{
  fprintf(stream, "X=%f, Y=%f\n", S->X, S->Y);
@}

static void
ccname_method(my_coords_t, print_pol) (my_coords_t * S, FILE * stream)
@{
  double        RHO   = hypot(S->X, S->Y);
  double        THETA = atan2(S->Y, S->X);

  fprintf(stream, "RHO=%f, THETA=%f\n", RHO, THETA);
@}

static ccname_table_type(my_coords_t) const ccname_table(my_coords_t) = @{
  .print_rec    = ccname_method(my_coords_t, print_rec),
  .print_pol    = ccname_method(my_coords_t, print_pol)
@};

void
ccname_init(my_coords_t, rec) (my_coords_t * S, double X, double Y)
@{
  S->methods = &ccname_table(my_coords_t);
  S->X = X;
  S->Y = Y;
@}

void
ccname_init(my_coords_t, pol) (my_coords_t * S, double RHO, double THETA)
@{
  S->methods = &ccname_table(my_coords_t);
  S->X = RHO * cos(THETA);
  S->Y = RHO * sin(THETA);
@}
@end smallexample

@c page
@node ccnames iface
@appendixsec Well known names for interface types.


The macros for ``well known interface functions'' define an @api{} to implement interface @struct{}
types; an interface is a set of operations we can apply to a data @struct{}; multiple data @struct{}
types can implement multiple interfaces.  The following macros are defined in the header file
@file{ccnames.h}.


@defmac ccname_iface_new_type (@var{IFACE_TYPE})
@defmacx ccname_iface_new_type (@var{IFACE_TYPE}, @var{STRUCT_TYPE})
@defmacx ccname_iface_new_type (@var{IFACE_TYPE}, @var{STRUCT_TYPE}, @var{VARIANT})
Given an interface type name, an optional struct name and an optional variant specification: expand
into the function type name of interface implementation constructors.  Constructors of such type
must build instances of @var{IFACE_TYPE} as implemented by @var{STRUCT_TYPE}, as specified for the
variant @var{VARIANT}.
@end defmac


@defmac ccname_iface_new (@var{IFACE_TYPE}, @var{STRUCT_TYPE})
@defmacx ccname_iface_new (@var{IFACE_TYPE}, @var{STRUCT_TYPE}, @var{VARIANT})
Given an interface type name, a struct type name, an optional variant specification: expand into the
name of the @api{} function @cfunc{new} that instantiates that variant of the interface for the
@struct{}.
@end defmac


@defmac ccname_iface_table_type (@var{IFACE_TYPE})
@defmacx ccname_iface_table_type (@var{IFACE_TYPE}, @var{VARIANT})
Given an interface type name and an optional variant specification: expand into the name of the
methods table type for the interface type.
@end defmac


@defmac ccname_iface_table (@var{IFACE_TYPE}, @var{STRUCT_TYPE})
@defmacx ccname_iface_table (@var{IFACE_TYPE}, @var{STRUCT_TYPE}, @var{VARIANT})
Given an interface type name, a struct type name, and an optional variant specification: expand into
the name of the methods table for that variant of the interface implementation for the @struct{}
type.
@end defmac


@defmac ccname_iface_method_type (@var{IFACE_TYPE}, @var{METHOD_NAME})
@defmacx ccname_iface_method_type (@var{IFACE_TYPE}, @var{VARIANT}, @var{METHOD_NAME})
Given an interface type name, an optional variant specification, and a method name: expand into the
type name of the method function for that variant of the interface implementation.
@end defmac


@defmac ccname_iface_method (@var{IFACE_TYPE}, @var{STRUCT_TYPE}, @var{METHOD_NAME})
@defmacx ccname_iface_method (@var{IFACE_TYPE}, @var{STRUCT_TYPE}, @var{VARIANT}, @var{METHOD_NAME})
Given an interface type name, a struct type name, an optional variant specification, and a method
name: expand into the name of the method function for that variant of the interface implementation
for the struct type.
@end defmac


Let's say we have this @struct{} definition:

@smallexample
typedef struct my_coords_t      my_coords_t;

struct my_coords_t @{
  double        X;
  double        Y;
@};
@end smallexample

@noindent
and we want to define an interface type @objtype{my_printable_I} to print the @struct{} on a
standard stream, both in rectangular and polar forms.

Every interface must have a @struct{} acting as table of pointers to functions, whose functions
implements the interface methods.  The interface @struct{} type is unique, the methods table
@struct{} type is unique; for every data @struct{} that implements the interface: we need a methods
table and an interface constructor.

The interface @struct{} type and the methods table @struct{} type are defined as follows:

@smallexample
typedef struct my_printable_I   my_printable_I;
typedef struct ccname_iface_table_type(my_printable_I) \
  ccname_iface_table_type(my_printable_I);

struct my_printable_I @{
  ccname_iface_table_type(my_printable_I)  const * methods;
  ccstructs_core_t                         const * self;
@};

typedef void ccname_iface_method_type(my_printable_I, print) \
  (my_printable_I I, FILE * stream);

struct ccname_iface_table_type(my_printable_I) @{
  ccname_iface_method_type(my_printable_I, print) * print_rec;
  ccname_iface_method_type(my_printable_I, print) * print_pol;
@};
@end smallexample

The @objtype{my_printable_I} interface @api{} is defined as follows:

@smallexample
my_printable_I
my_printable_new (ccstructs_core_t const * S,
                  ccname_iface_table_type(my_printable_I) const * M)
@{
  my_printable_I        I = @{
    .methods    = M,
    .self       = S
  @};
  return I;
@}

ccstructs_core_t const *
my_printable_self (my_printable_I I)
@{
  return I.self;
@}

void
my_printable_print_rec (my_printable_I I, FILE * stream)
@{
  I.methods->print_rec(I, stream);
@}

void
my_printable_print_pol (my_printable_I I, FILE * stream)
@{
  I.methods->print_pol(I, stream);
@}
@end smallexample

The implementation of @objtype{my_printable_I} for the data @struct{} @objtype{my_coords_t} is
defined as follows:

@smallexample
static void
ccname_iface_method(my_printable_I, my_coords_t, print_rec) (my_printable_I I, FILE * stream)
@{
  CCSTRUCTS_PC(my_coords_t, S, my_printable_self(I));

  fprintf(stream, "X=%f, Y=%f\n", S->X, S->Y);
@}

static void
ccname_iface_method(my_printable_I, my_coords_t, print_pol) (my_printable_I I, FILE * stream)
@{
  CCSTRUCTS_PC(my_coords_t, S, my_printable_self(I));
  double        RHO   = hypot(S->X, S->Y);
  double        THETA = atan2(S->Y, S->X);

  fprintf(stream, "RHO=%f, THETA=%f\n", RHO, THETA);
@}

static ccname_iface_table_type(my_printable_I) const ccname_iface_table(my_printable_I, my_coords_t) = @{
  .print_rec    = ccname_iface_method(my_printable_I, my_coords_t, print_rec),
  .print_pol    = ccname_iface_method(my_printable_I, my_coords_t, print_pol)
@};

my_printable_I
ccname_iface_new(my_printable_I, my_coords_t) (my_coords_t * S)
@{
  return my_printable_new(ccstructs_core(S), &ccname_iface_table(my_printable_I, my_coords_t));
@}
@end smallexample

We can use the interface as follows:

@smallexample
int
main (void)
@{
  cce_location_t        L[1];
  my_coords_t *         S;
  my_printable_I        I;

  if (cce_location(L)) @{
    cce_run_catch_handlers_final(L);
  @} else @{
    S = ccname_new(my_coords_t, rec)(L, 1.0, 2.0);
    I = ccname_iface_new(my_printable_I, my_coords_t)(S);

    my_printable_print_rec(I, stdout);
    my_printable_print_pol(I, stdout);
    ccname_delete(my_coords_t)(S);
  @}
  exit(EXIT_SUCCESS);
@}
@end smallexample

@c Local Variables:
@c mode: texinfo
@c TeX-master: "ccexceptions"
@c End:
