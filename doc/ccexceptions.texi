\input texinfo.tex
@c %**start of header
@setfilename ccexceptions.info
@settitle CCExceptions
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCExceptions

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCExceptions

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccexceptions

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2016

@c ------------------------------------------------------------

@set GITHUB_URL                 @url{http://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BITBUCKET_URL              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DOWNLOAD_URL               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DOCUMENTATION_URL          @url{http://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C language library
implementing an interface to non--local exits, which is somewhat similar to exceptions handling.

The package is distributed under the terms of the @gnu{} General Public License (@gpl{}).

The latest release can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front--Cover Texts, and no
Back--Cover Texts.  A copy of the license is included in the section
entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccexceptions: (ccexceptions).       CCExceptions a C language library
                                      implementing exceptions handling.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* setjmp::                      Brief introduction to non-local exits.
* locations::                   The locations @api{}.
* handlers::                    The handlers @api{}.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C language library
implementing an interface to non--local exits, which is somewhat similar to exceptions handling.

This tiny library will not solve the problem of error handling in the C language, it just brings a
little order in the mess resulting from hand--coding the error handling logic.

@value{PACKAGE} installs the single header file @file{ccexceptions.h}.  All the function names in
the @api{} are prefixed with @code{cce_}; all the constant names are prefixed with @code{CCE_}; all
the type names are prefixed with @code{cce_} and suffixed with @code{_t}.

@value{PACKAGE}'s location mechanism has the following purposes:

@enumerate
@item
Implement non--local exits in a way that allows client code to be
shorter and simpler to understand.

@item
Implement non--local exit handlers to perform synchronous clean--up operations.
@end enumerate

@noindent
these features come at the cost of slowing down execution in a possibly sensible way (with respect
to, for example, hand--coded @code{goto} instructions that jump to labels).

@menu
* overview linking::            Linking code with the library.
@end menu

@c page
@node overview linking
@section Linking code with the library


This package installs a data file for @command{pkg-config}, so when searching for the installed
library with the @gnu{} Autotools, we can:

@itemize
@item
Add the following macro use to @file{configure.ac}:

@example
PKG_CHECK_MODULES([CCEXCEPTIONS],[ccexceptions >= 0.1])
@end example

@noindent
which will set the variables @code{CCEXCEPTIONS_LIBS} and @code{CCEXCEPTIONS_CFLAGS}.
@end itemize

Alternatively we can use the raw @gnu{} Autoconf macros:

@example
AC_CHECK_LIB([ccexceptions],[cce_version_string],,
  [AC_MSG_FAILURE([test for CCExceptions library failed])])
AC_CHECK_HEADERS([ccexceptions.h],,
  [AC_MSG_FAILURE([test for CCExceptions header failed])])
@end example

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the
@gnu{} Autotools.  For an explanation of interface numbers as managed by
@gnu{} Libtool @xref{Libtool versioning, interface, Libtool's versioning
system, libtool, Shared library support for @gnu{}}.


@deftypefun {const char *} cce_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing
the interface version number.
@end deftypefun


@deftypefun int cce_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int cce_version_interface_revision (void)
Return an integer representing the library interface current revision
number.
@end deftypefun


@deftypefun int cce_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node setjmp
@chapter Brief introduction to non--local exits


Let's recall briefly how the standard, C language, non--local exits mechanism works; for the full
documentation refer to the C Library.  @glibcref{Non-Local Exits, Non-Local Exits}.

@value{PACKAGE} makes use of @cfunc{sigsetjmp} and @cfunc{siglongjmp}, rather than @cfunc{setjmp}
and @cfunc{longjmp}, because we are not interested in saving the inter--process Unix signals state.

To use @cfunc{sigsetjmp} and @cfunc{siglongjmp} we write chunks of code like the following:

@example
#define DO_NOT_SAVE_SIGS        0
#define JMP_ERROR_CODE          1

sigjmp_buf  here;

if (sigsetjmp(here, DO_NOT_SAVE_SIGS))
  @{
    handle_the_error();
  @}
else
  @{
    do_something();
    if (error)
      siglongjmp(here, JMP_ERROR_CODE);
    do_something_else();
  @}
@end example

@noindent
this is what happens:

@itemize
@item
When @cfunc{sigsetjmp} is invoked: it saves the current ``position'' in @code{here}, then it returns
zero.

@item
If @cfunc{siglongjmp} is not applied to @code{here}, nothing strange happens and the execution flow
goes on as usual.

@item
If @cfunc{siglongjmp} is applied to @code{here}: the execution jumps back to the call to
@cfunc{sigsetjmp} with @code{JMP_ERROR_CODE} as return value.
@end itemize

This mechanism allows us to separate the error handling code from the main code.  By using
@var{here} as argument to nested function calls: we can perform non--local exits across functions;
something that is not possible with @code{goto} statements.

As always, care must be taken when the body allocates asynchronous resources.  For each resource:
the error handler must detect if the allocation took place and execute release code.  For example:

@example
#define DO_NOT_SAVE_SIGS        0
#define JMP_ERROR_CODE          1

sigjmp_buf           here;
volatile void *   p = NULL;

if (sigsetjmp(here, DO_NOT_SAFE_SIGS))
  @{
    if (p)
      free(p);
  @}
else
  @{
    ...
    p = malloc(4096);
    ...
  @}
@end example

Let's see some logic example; we will assume the following preamble:

@example
#include <assert.h>
#include <stdlib.h>
#include <setjmp.h>

#define DO_NOT_SAVE_SIGS        0
#define JUMP_TO_ERROR           2
#define JUMP_TO_RETRY           3
@end example

In the following code no jump is performed; we just call @cfunc{sigsetjmp} once and never call
@cfunc{siglongjmp}:

@example
sigjmp_buf  L;
int         flag = 0, code = 0;

code = sigsetjmp(L, DO_NOT_SAVE_SIGS);
if (code) @{
  flag = 2;
@} else @{
  flag = 1;
@}
assert(0 == code);
assert(1 == flag);
@end example

In the following code we perform a jump and handle the logic with an @code{if} statement:

@example
sigjmp_buf  L;
int         code;
int         flag = 0;

code = sigsetjmp(L, DO_NOT_SAVE_SIGS);
if (JUMP_TO_ERROR == code) @{
  flag = 2;
@} else @{
  flag = 1;
  siglongjmp(L, JUMP_TO_ERROR);
@}
assert(JUMP_TO_ERROR == code);
assert(2 == flag);
@end example

In the following code we perform a jump and handle the logic with a @code{switch} statement:

@example
sigjmp_buf  L;
int         code;
int         flag = 0;

code = sigsetjmp(L, DO_NOT_SAVE_SIGS);
switch (code) @{
case JUMP_TO_ERROR:
  flag = 2;
  break;
default:
  flag = 1;
  siglongjmp(L, JUMP_TO_ERROR);
  break;
@}
assert(JUMP_TO_ERROR == code);
assert(2 == flag);
@end example

In the following code we perform a jump and try an alternative body; we handle the logic with a
@code{switch} statement:

@example
sigjmp_buf  L;
int         code;
int         flag = 0;

code = sigsetjmp(L, DO_NOT_SAVE_SIGS);
switch (code) @{
case JUMP_TO_ERROR:
  flag = 2;
  siglongjmp(L, JUMP_TO_RETRY);
  break;
case JUMP_TO_RETRY:
  // the alternative body
  flag = 3;
  break;
default:
  // the body
  flag = 1;
  siglongjmp(L, JUMP_TO_ERROR);
  break;
@}
assert(JUMP_TO_RETRY == code);
assert(3 == flag);
@end example

In the following code we perform a jump and retry the body several times:

@example
sigjmp_buf          L;
volatile int        times = 0;
int                 code = 0;
int                 flag = 0;

code = sigsetjmp(L, DO_NOT_SAVE_SIGS);
switch (code) @{
case JUMP_TO_ERROR:
  flag = 2;
  siglongjmp(L, JUMP_TO_RETRY);
  break;
default:
  if ((JUMP_TO_RETRY == code) && (times < 5)) @{
    // retrying
    ++times;
    siglongjmp(L, JUMP_TO_ERROR);
  @} else if (JUMP_TO_RETRY == code) @{
    flag = 3;
  @} else @{
    // the body
    flag = 1;
    siglongjmp(L, JUMP_TO_ERROR);
  @}
  break;
@}
assert(JUMP_TO_RETRY == code);
assert(3 == flag);
@end example

@c page
@node locations
@chapter The locations @api{}


Non--local exits are a way to transfer execution from one point to another in a program; they are
implemented by the standard C library through the @cfunc{sigsetjmp} and @cfunc{siglongjmp}
functions.  @value{PACKAGE} calls @cfunc{sigsetjmp} and @cfunc{siglongjmp} to make sure that the
signal context is not saved (consuming time) at each invocation; see the @code{setjmp(3)} manual
page for details.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_location_tag_t
Struct type representing the location context.  It contains an instance of @code{setjmp_buf} which
is the target of the @cfunc{siglongjmp} calls.  It has the following public fields:

@table @code
@item void * condition
An opaque pointer to a data structure representing the description of the exceptional condition.  It
is set by @cfunc{cce_raise}.  The client code is responsible of releasing resources associated to
this value.
@end table
@end deftp


@deftp {One-Element Array Typedef} cce_location_t
It is defined as follows:

@example
typedef cce_location_tag_t      cce_location_t[1];
@end example

This type is convenient to define an instance of location.
@end deftp


@deftypefun void cce_location_init (cce_location_tag_t * @var{L})
Initialise the location @var{L}, but do @strong{not} call @cfunc{sigsetjmp}.  We are not meant to
call this function directly; rather we should use the macro @cfunc{cce_location}.
@end deftypefun


@deftypefn {Preprocessor Macro} int cce_location (cce_location_tag_t * @var{L})
Initialise the location @var{L}; call @cfunc{sigsetjmp} and return its return value.
@end deftypefn


@defmac CCE_SUCCESS
Constant of type @code{int} used by the library as non--local exit code.  It is the return value of
@cfunc{cce_location} at the first evaluation.
@end defmac


@defmac CCE_ERROR
Constant of type @code{int} used by the library as non--local exit code.  It is the return value of
@cfunc{cce_location} when a non--local exit is performed by @cfunc{cce_raise}.
@end defmac


@defmac CCE_RETRY
Constant of type @code{int} used by the library as non--local exit code.  It is the return value of
@cfunc{cce_location} when a non--local exit is performed by @cfunc{cce_retry}.
@end defmac


@deftypefun void cce_raise (cce_location_tag_t * @var{L}, void * @var{condition})
Raise an exception associated to the destination @var{L} and with descriptor @var{condition}.  This
function performs the call to @cfunc{siglongjmp} with code @code{CCE_ERROR}.
@end deftypefun


@deftypefun void cce_retry (cce_location_tag_t * @var{L})
Raise an exception associated to the destination @var{L} with the purpose or retrying the body
evaluation.  This function performs the call to @cfunc{siglongjmp} with code @code{CCE_RETRY}.
@end deftypefun


It is suggested to use @code{switch} statements to organise the logic of location mechanisms.  The
basic scheme is as follows:

@example
cce_location_t  L;

switch (cce_location (L)) @{
case CCE_ERROR:
  handle_the_exception();
  break;

default:
  do_something();
  if (some_error()) @{
    cce_raise(L, NULL);
  @}
@}
@end example

If we want to distinguish between the main body and the retry body, we do:

@example
cce_location_t  L;

switch (cce_location (L)) @{
case CCE_ERROR:
  handle_the_exception();
  break;

case CCE_RETRY:
  retry_doing_something();
  break;

default:
  do_something();
  if (some_recoverable_error()) @{
    cce_retry(L);
  @} else if (some_error()) @{
    cce_raise(L, NULL);
  @}
@}
@end example

@noindent
and we can fall through:

@example
cce_location_t  L;

switch (cce_location (L)) @{
case CCE_ERROR:
  handle_the_exception();
  break;

case CCE_RETRY:
  prepare_to_retry();
  // fall through

default:
  do_something();
  if (some_recoverable_error()) @{
    cce_retry(L);
  @} else if (some_error()) @{
    cce_raise(L, NULL);
  @}
@}
@end example

@c page
@node handlers
@chapter The handlers @api{}


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_handler_tag_t
Struct type representing a cleanup or error handler.  Instances of this type are associated to a
location by calling @cfunc{cce_register_cleanup_handler} or @cfunc{cce_register_error_handler}.
Handlers are invoked by @cfunc{cce_run_cleanup_handlers} or @cfunc{cce_run_error_handlers}.

We are meant to wrap instances of this type into an enclosing struct definition as follows:

@example
struct resource_handler_t @{
  cce_handler_tag_t	handler;
  void *		resourcep;
@};
@end example

@noindent
in which the instance of @code{cce_handler_tag_t} is the first field.

The structure has the following public fields:

@table @code
@item cce_handler_fun_t * handler_function
Pointer to the function implementing the handler.
@end table
@end deftp


@deftypefn {Function Typedef} void cce_handler_fun_t (cce_location_tag_t * @var{L}, void * @var{H})
Type of handler functions.  The argument @var{L} references the location.  The argument @var{H}
references the handler context.
@end deftypefn


@deftp {One-Element Array Typedef} cce_handler_t
It is defined as follows:

@example
typedef cce_handler_tag_t      cce_handler_t[1];
@end example

In some cases, this type is convenient to define an instance of handler structure.
@end deftp


@deftypefun void cce_register_cleanup_handler (cce_location_tag_t * @var{L}, void * @var{H})
Register the cleanup handler referenced by @var{H} in the list of handlers associated to the
location @var{L}.  The pointer @var{H} must reference an instance of structure whose first field is
a structure of type @code{cce_handler_tag_t}; such structure is meant to be allocated on the stack
frame of the function also defining the location @var{L}.

A cleanup handler is meant to be called whenever the execution flow leaves the dynamic extent of a
location, whether with an exception or as part of the successful execution.
@end deftypefun


@deftypefun void cce_register_error_handler (cce_location_tag_t * @var{L}, void * @var{H})
Register the error handler referenced by @var{H} in the list of handlers associated to the location
@var{L}.  The pointer @var{H} must reference an instance of structure whose first field is a
structure of type @code{cce_handler_tag_t}; such structure is meant to be allocated on the stack
frame of the function also defining the location @var{L}.

An error handler is meant to be called whenever the execution flow leaves the dynamic extent of a
location in case of an exception; it must not be called as part of the successful execution.
@end deftypefun


@deftypefun void cce_run_cleanup_handlers (cce_location_tag_t * @var{L})
Run all the cleanup handlers associated to the location @var{L}.  Each handler must return to its
calle, taking care of itself regarding internal error handling and asynchronous resources
allocation.  Handlers are called starting from the last registered one.
@end deftypefun


@deftypefun void cce_run_error_handlers (cce_location_tag_t * @var{L})
Run all the error handlers associated to the location @var{L}.  Each handler must return to its
caller, taking care of itself regarding internal error handling and asynchronous resources
allocation.  Handlers are called starting from the last registered one.
@end deftypefun


For convenience, in the following examples: we will use nested C function definitions, which are a
@gnu{} C Compiler's extension.  We could define and call a list of cleanup handlers as follows:

@example
void handler1 (cce_location_tag_t * L, void * H) @{
  do_some_cleanup();
@}
void handler2 (cce_location_tag_t * L, void * H) @{
  do_some_cleanup();
@}
void handler3 (cce_location_tag_t * L, void * H) @{
  do_some_cleanup();
@}

cce_location_t     L;
cce_handler_tag_t  H1 = @{ .handler_function = handler1 @};
cce_handler_tag_t  H2 = @{ .handler_function = handler2 @};
cce_handler_tag_t  H3 = @{ .handler_function = handler3 @};

cce_location_init(L);
cce_register_cleanup_handler(L, &H1);
cce_register_cleanup_handler(L, &H2);
cce_register_cleanup_handler(L, &H3);
cce_run_cleanup_handlers(L);
@end example

@noindent
and we could define and call a list of error handlers as follows:

@example
void handler1 (cce_location_tag_t * L, void * H) @{
  do_some_error_handling();
@}
void handler2 (cce_location_tag_t * L, void * H) @{
  do_some_error_handling();
@}
void handler3 (cce_location_tag_t * L, void * H) @{
  do_some_error_handling();
@}

cce_location_t     L;
cce_handler_tag_t  H1 = @{ .handler_function = handler1 @};
cce_handler_tag_t  H2 = @{ .handler_function = handler2 @};
cce_handler_tag_t  H3 = @{ .handler_function = handler3 @};

cce_location_init(L);
cce_register_error_handler(L, &H1);
cce_register_error_handler(L, &H2);
cce_register_error_handler(L, &H3);
cce_run_error_handlers(L);
@end example

Let's say we need to allocate memory, and to release it whenever the dynamic extent of the local
function terminates; we can organise the code as follows, using a cleanup handler:

@example
cce_location_t      L;
cce_handler_t       HP;
void *              P;

void P_handler (cce_location_tag_t * L, void * H) @{
  free(P);
@}
HP->handler_function = P_handler;

switch (cce_location(L)) @{
case CCE_ERROR:
  cce_run_error_handlers(L);
  break;

default:
  P = malloc(4096);
  if (P) @{
    cce_register_cleanup_handler(L, HP);
  @} else @{
    cce_raise(L, NULL);
  @}
  do_something(L, P);
  cce_run_cleanup_handlers(L);
@}
@end example

@noindent
whether @cfunc{do_something} raises an exception or not: the cleanup handler is invoked and the
memory is released.

Let's say we are writing a constructor and we need to allocate memory, do something and, if
successful, return the memory to the caller; we can organise the code as follows, using an error
handler in the constructor and a cleanup handler in the caller:

@example
void *
constructor (cce_location_tag_t * upper_L)
@{
  cce_location_t    L;
  cce_handler_t     HP;
  void *            P;

  void P_handler (cce_location_tag_t * L, void * H) @{
    free(P);
  @}
  HP->handler_function = P_handler;

  switch (cce_location(L)) @{
  case CCE_ERROR:
    cce_run_error_handlers(L);
    cce_raise(upper_L, NULL);
    break;

  default:
    P = malloc(4096);
    if (P) @{
      cce_register_error_handler(L, HP);
    @} else @{
      cce_raise(L, NULL);
    @}
    do_some_initialisation_in(P);
    cce_run_cleanup_handlers(L);
  @}
  return P;
@}

void caller (void)
@{
  cce_location_t    L;
  cce_handler_t     HP;
  void *            P;

  void P_handler (cce_location_tag_t * L, void * H) @{
    free(P);
  @}
  HP->handler_function = P_handler;

  switch (cce_location(L)) @{
  case CCE_ERROR:
    cce_run_error_handlers(L);
    break;

  default:
    P = constructor(L);
    cce_register_cleanup_handler(L, HP);
    do_something_with(P);
    cce_run_cleanup_handlers(L);
  @}
@}
@end example

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DOCUMENTATION_URL}

@noindent
the latest release of this package can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

