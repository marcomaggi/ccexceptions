\input texinfo.tex
@c %**start of header
@setfilename ccexceptions.info
@settitle CCExceptions
@c %**end of header

@include version.texi
@include macros.texi
@include ccexceptions-macros.texi

@c page
@c ------------------------------------------------------------
@c Document specific macros.
@c ------------------------------------------------------------

@macro ConditionSubtypingExample{FILESTEM, TYPESTEM}
@subsubheading Subtyping example

To define a subtype of @objtype{cce_condition_\TYPESTEM\_t} we can copy the code in the files:

@example
test-condition-subtyping-\FILESTEM\.c
condition-subtyping-\FILESTEM\.h
condition-subtyping-\FILESTEM\.c
@end example

@noindent
under the @file{tests} directory of the source distribution; the code defines a new
exceptional--condition object--type @objtype{my_condition_\TYPESTEM\_subtype_t}.
@end macro

@macro ExceptionalConditionIndexEntries{DESCRIPTION}
@cindex \DESCRIPTION\, exceptional condition
@cindex Exceptional conditions, \DESCRIPTION\
@end macro

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCExceptions

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCExceptions

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccexceptions

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2016-2019

@c ------------------------------------------------------------

@set PackageAutoconfPrefix              CCEXCEPTIONS
@set PackagePkgconfigModule             ccexceptions
@set PackageLibsVar                     @env{CCEXCEPTIONS_LIBS}
@set PackageCflagsVar                   @env{CCEXCEPTIONS_CFLAGS}
@c This is the stem of the library in "libccexceptions.so".
@set PackageLibstem                     ccexceptions
@set PackageApiPrefixLower              cce_
@set PackageApiPrefixUpper              CCE_

@set PackageHeader                      ccexceptions.h
@set PackageHeaderFile                  @file{@value{PackageHeader}}

@set GithubUrl                 @url{http://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BitbucketUrl              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DownloadUrl               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DocumentationUrl          @url{http://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C11 Standard language library;
it implements an interface to non--local exits, which is somewhat similar to exceptions handling.
The library targets @posix{} systems.

The package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

The latest release can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} Lesser
General Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccexceptions: (ccexceptions).       CCExceptions a C11 language library
                                      implementing exceptions handling.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* setjmp::                      Brief introduction to non-local exits.
* locations::                   The locations @api{}.
* handlers::                    The location handlers @api{}.
* conditions::                  Exceptional condition descriptors.
* system::                      System call adapters.
* tracing::                     Printing execution traces.

Appendices

* cclibraries::                 The header file @file{cclibraries.h}.
* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library; it
implements an interface to non--local exits, which is somewhat similar to exceptions handling.  The
library targets @posix{} systems.

This tiny library will not solve the problem of error handling in the C language, it just brings a
little order in the complexity resulting from hand--coding the error handling logic.
@value{PACKAGE}'s location mechanism has the following purposes:

@enumerate
@item
Implement non--local exits in a way that allows client source code to be shorter and simpler to
understand.

@item
Implement non--local exit handlers to perform synchronous clean--up operations.

@item
Implement a simple architecture for exceptional--condition descriptors.
@end enumerate

@noindent
these features come at the cost of slowing down execution in a possibly sensible way (with respect
to, for example, hand--coded @code{goto} instructions that jump to labels).

@cindex @value{PackageHeaderFile}, header file
@cindex Header file @value{PackageHeaderFile}
@value{PACKAGE} installs multiple header files, of which @value{PackageHeaderFile} is the main one,
exporting the whole library's @api{}.  For the definitions of the file @value{PackageHeaderFile}:
all the function names in the @api{} are prefixed with @code{@value{PackageApiPrefixLower}}; all the
preprocessor symbol names are prefixed with @code{@value{PackageApiPrefixUpper}}; all the type names
are prefixed with @code{@value{PackageApiPrefixLower}} and suffixed with @code{_t}.

The package also distributes the header file @file{cclibraries.h}, with common definitions for all
the CCLibraries projects; @ref{cclibraries} for details.

@strong{IMPORTANT} To use the library we must enable the @posix{} features when including the
standard header files; so either we include @file{ccexceptions.h} as first header, or we include the
following definitions before including @strong{all} the header files:

@example
#define _POSIX_C_SOURCE         200809L
@end example

@menu
* overview linking::            Linking code with the library.
@end menu

@include overview-linking.texi

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the
@gnu{} Autotools.  For an explanation of interface numbers as managed by
@gnu{} Libtool @xref{Libtool versioning, interface, Libtool's versioning
system, libtool, Shared library support for @gnu{}}.


@deftypefun {char const *} cce_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing
the interface version number.
@end deftypefun


@deftypefun int cce_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int cce_version_interface_revision (void)
Return an integer representing the library interface current revision
number.
@end deftypefun


@deftypefun int cce_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node setjmp
@chapter Brief introduction to non--local exits


Let's recall briefly how the standard, C language, non--local exits mechanism works; for the full
documentation refer to the C Library.  @glibcref{Non-Local Exits, Non-Local Exits}.

To use @cfunc{setjmp} and @cfunc{longjmp} we write chunks of code like the following:

@example
#define JMP_ERROR_CODE          1

jmp_buf  here;

if (setjmp(here))
  @{
    handle_the_error();
  @}
else
  @{
    do_something();
    if (an_error_occurred()) @{
      longjmp(here, JMP_ERROR_CODE);
    @}
    do_something_else();
  @}
@end example

@noindent
this is what happens:

@itemize
@item
When @cfunc{setjmp} is invoked: it saves the current ``location'' in @var{here}, then it returns
zero.

@item
If @cfunc{longjmp} is not applied to @var{here}, nothing strange happens and the execution flow goes
on as usual.

@item
If @cfunc{longjmp} is applied to @var{here}: the execution jumps back to the call to @cfunc{setjmp}
with @code{JMP_ERROR_CODE} as return value.
@end itemize

This mechanism allows us to separate the exception handling code from the main code.  By using
@var{here} as argument to nested function calls: we can perform non--local exits across functions;
something that is not possible with @code{goto} statements.

As always, care must be taken when the body allocates asynchronous resources.  For each resource:
the exception handler must detect if the allocation took place and execute release code.  For
example:

@example
jmp_buf         here;
volatile void * P = NULL;

if (setjmp(here))
  @{
    if (P)
      free(P);
  @}
else
  @{
    ...
    P = malloc(4096);
    ...
  @}
@end example

Let's see some logic example; we will assume the following preamble:

@example
#include <assert.h>
#include <stdlib.h>
#include <setjmp.h>

#define JUMP_TO_ERROR           2
@end example

In the following code no jump is performed; we just call @cfunc{setjmp} once and never call
@cfunc{longjmp}:

@example
jmp_buf         L;
int             flag = 0, code;

code = setjmp(L);
if (code) @{
  flag = 2;
@} else @{
  flag = 1;
@}
assert(0 == code);
assert(1 == flag);
@end example

In the following code we perform a jump and handle the logic with an @code{if} statement:

@example
jmp_buf         L;
int             flag = 0, code;

code = setjmp(L);
if (JUMP_TO_ERROR == code) @{
  flag = 2;
@} else @{
  flag = 1;
  longjmp(L, JUMP_TO_ERROR);
@}
assert(JUMP_TO_ERROR == code);
assert(2 == flag);
@end example

In the following code we perform a jump and handle the logic with a @code{switch} statement:

@example
jmp_buf         L;
int             flag = 0, code;

code = setjmp(L);
switch (code) @{
case JUMP_TO_ERROR:
  flag = 2;
  break;
default:
  flag = 1;
  longjmp(L, JUMP_TO_ERROR);
@}
assert(JUMP_TO_ERROR == code);
assert(2 == flag);
@end example

@c page
@node locations
@chapter The locations @api{}


Non--local exits are a way to transfer execution from one point to another in a program; they are
implemented by the standard C library through the @cfunc{setjmp} and @cfunc{longjmp} functions.
@value{PACKAGE} uses the @posix{} variants @cfunc{sigsetjmp} and @cfunc{siglongjmp}: they do
@strong{not} save the interprocess signals mask, making the operations a bit faster.

The main usage pattern for this module is the following:

@example
cce_location_t  L[1];

if (cce_location(L)) @{
  /* handle the exception here */
  cce_run_catch_handlers_final(L);
@} else @{
  /* do something useful here */
  cce_run_body_handlers(L);
@}
@end example

@noindent
it is usually useful to define variables of type @objtype{cce_location_t} as one--element arrays.
When using @value{PACKAGE} we should consider configuring our source code editor to automatically
insert this code template.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_location_t
Struct type representing the location context.  This type is ``derived'' from @objtype{sigjmp_buf}
in the sense that a pointer to @objtype{cce_location_t} is also a pointer to @objtype{sigjmp_buf}.

Instances of this structure reference an instance of type @objtype{cce_condition_t}; it is set by
@cfunc{cce_raise}.  The client code is responsible for releasing resources associated to this value
by retrieving a pointer to it with @cfunc{cce_condition} and releasing it with
@cfunc{cce_condition_delete}.

Before terminating the use of instances of this type we must always call
@cfunc{cce_run_body_handlers}, @cfunc{cce_run_catch_handlers}.  We must assume that the handlers
might access the @objtype{cce_condition_t} object, so: first we call the handlers, then we release
the exceptional--condition object.

The functions @cfunc{cce_run_catch_handlers_final} or @cfunc{cce_run_catch_handlers_raise} will run
the catch handlers and take care of handling the @objtype{cce_condition_t} object.
@end deftp


@deftp {Pointer Typedef} cce_destination_t
Pointer to @objtype{cce_location_t}.
@end deftp


@deftypefun void cce_location_init (cce_destination_t @var{L})
Initialise the location @var{L}, but do @strong{not} call @cfunc{sigsetjmp}.  We are not meant to
call this function directly; rather we should use the macro @cfunc{cce_location}.
@end deftypefun


@deftypefn {Preprocessor Macro} int cce_location (cce_destination_t @var{L})
Initialise the location @var{L}; call @cfunc{sigsetjmp} and return its return value.
@end deftypefn


@deftypevr Constant int CCE_ENTER
@deftypevrx Constant int CCE_SUCCESS
Constants used by the library as non--local exit codes.  They are defined as @code{0} and represent
the return value of @cfunc{cce_location} at the first evaluation.
@end deftypevr


@deftypevr Constant int CCE_RETRY
This code represents the return value of the @cfunc{setjmp} evaluation after a @cfunc{cce_retry}
call.
@end deftypevr


@deftypevr Constant int CCE_EXCEPT
@deftypevrx Constant int CCE_ERROR
Constants used by the library as non--local exit codes.  They are defined as @code{1} and are the
return value of @cfunc{cce_location} when a non--local exit is performed by @cfunc{cce_raise}.
@end deftypevr


@deftypefun void cce_raise (cce_destination_t @var{L}, cce_condition_t const * @var{C})
Raise an exception associated to the location @var{L}, with exceptional--condition object referenced
by @var{C}.  This function performs the call to @cfunc{siglongjmp} with code @code{CCE_EXCEPT}.

With a call to this function: the client code is put in charge of releasing resources associated to
@var{C}.  If @var{C} is @cnull{}: an internal, statically allocated, exceptional--condition object
is selected to represent an ``unknown exceptional condition''; we can transparently apply the
function @cfunc{cce_condition_delete} to this object.
@end deftypefun


@deftypefun void cce_retry (cce_destinataion_t @var{L})
Jump back to the location @var{L}, reentering the body of the construct.
@end deftypefun


@deftypefn {Generic Macro} {cce_condition_t *} cce_condition (cce_destination_t @var{L})
Return the exceptional--condition object associated to the location @var{L}; this value is
@strong{never} @cnull{}.

If we apply this function to a location without calling @cfunc{cce_raise}: the returned pointer
references an internal, statically allocated, exceptional--condition object representing an
``unknown exceptional condition''; we can transparently apply the function
@cfunc{cce_condition_delete} to this object.
@end deftypefn


As examples of logic, consider the following:

@itemize
@item
If we want to evaluate a body of code and catch its raised exceptions locally, we can use the
following template code:

@example
cce_location_t  L[1];

if (cce_location(L)) @{
  /* handle the exception here */
  cce_run_catch_handlers_final(L);
@} else @{
  /* do something useful here */
  cce_run_body_handlers(L);
@}
@end example

@item
If we want to evaluate a body of code, catch its raised exceptions locally and then re--raise them
to another location, we can use the following template code:

@example
void
outer (void)
@{
  cce_location_t  L[1];

  if (cce_location(L)) @{
    /* handle the exception here */
    cce_run_catch_handlers_final(L);
  @} else @{
    inner(L);
    cce_run_body_handlers(L);
  @}
@}

void
inner (cce_location_t * upper_L)
@{
  cce_location_t  L[1];

  if (cce_location(L)) @{
    cce_run_catch_handlers_raise(upper_L, L);
  @} else @{
    /* do something useful here */
    cce_run_body_handlers(L);
  @}
@}
@end example
@end itemize

@c page
@node handlers
@chapter The location handlers @api{}


Location handlers allow us to execute callback functions whenever we exit a location context,
represented by an instance of @objtype{cce_location_t}, either by normal execution or by raising an
exception.  Before terminating the use of a @objtype{cce_location_t} instance: we must always call
the handlers, whether or not an exception was raised.

Normal--execution handlers are run by calling the function @cfunc{cce_run_body_handlers};
exception--reaction handlers are run by calling the function @cfunc{cce_run_catch_handlers}, but we
should use the more useful functions @cfunc{cce_run_catch_handlers_final} and
@cfunc{cce_run_catch_handlers_raise}.

@value{PACKAGE} defines @dfn{clean handlers}, which are run as both normal--execution and
exception--reaction handlers; it also defines @dfn{error handlers}, which are run only as
exception--reaction handlers.

@menu
* handlers typedefs::           Handlers type definitions.
* handlers init::               Initialising location handlers.
* handlers registering::        Registering and forgetting location handlers.
* handlers init and reg::       Initialising and registering location handlers.
* handlers accessors::          Accessing location handlers.
* handlers running::            Running location handlers.
* handlers handlers::           Running handlers from handlers.
@end menu

@c page
@node handlers typedefs
@section Handlers type definitions


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_clean_handler_t
@deftpx {Struct Typedef} cce_error_handler_t
Opaque structures representing clean and error handlers.  Instances of this type:

@itemize
@item
Are initialised by using the macro @cfunc{cce_init_handler}, which registers the asynchronous
resource to be finalised.

@item
Are registered into a location by using the macro @cfunc{cce_register_handler}.

@item
Can be initialised and registered in one step by using the macro
@cfunc{cce_init_and_register_handler}.
@end itemize

Clean handlers are invoked by calling one of the functions: @cfunc{cce_run_body_handlers},
@cfunc{cce_run_catch_handlers} and its variants @cfunc{cce_run_catch_handlers_final} and
@cfunc{cce_run_catch_handlers_raise}.

Error handlers are invoked by calling the function @cfunc{cce_run_catch_handlers} or one of its
variants, @cfunc{cce_run_catch_handlers_final} and @cfunc{cce_run_catch_handlers_raise}.

When an exception is raised: both the clean handlers and the error handlers are invoked; the clean
handlers are invoked first, in reverse order with respect of their registration; the error handlers
are invoked last, in reverse order with respect of their registration.

It is strongly advised to allocate instances of these types on the call stack, near the associated
@objtype{cce_location_t} instance, rather than to put them into dynamically allocated memory.
@end deftp

@c ------------------------------------------------------------------------

@deftypefn {Function Typedef} void cce_clean_handler_fun_t (cce_condition_t const * @var{C}, cce_clean_handler_t const * @var{H})
@deftypefnx {Function Typedef} void cce_error_handler_fun_t (cce_condition_t const * @var{C}, cce_error_handler_t const * @var{H})
Type of exception handler functions meant to release some asynchronous resource.  The argument
@var{C} references a structure representing the raised exceptional--condition object; the handler
must leave it untouched, it must @strong{not} mutate or release it.  The argument @var{H} references
the handler context; the handler must leave it untouched, it must @strong{not} mutate it.

This function might call the destructor function registered in @var{H}, if any.

If an error occurs: the handler function must take care of itself and return to the caller, it must
@strong{not} raise an exceptional condition and jump to a remote location.
@end deftypefn


@deftp {Typedef} cce_resource_data_t
An alias for @objtype{cclib_resource_data_t}, @ref{cclibraries typedefs opaque,
cclib_resource_data_t}.  We can use it in pointer cast operations to make the code more readable.
@end deftp


@deftypefn {Function Typedef} void cce_resource_destructor_fun_t (cce_resource_data_t * @var{pointer})
Type of client data destructor functions meant to destroy some ansynchronous resource.  The argument
@var{pointer} references the client data to destroy.

If an error occurs destroying some data: the destructor function must take care of itself and return
to the caller, it must @strong{not} raise an exceptional condition and jump to a remote location.
@end deftypefn


@deftypefn {Preprocessor Macro} {cce_resource_data_t *} cce_resource_pointer (@var{POINTER})
An alias for @cfunc{cclib_resource_pointer}, @ref{cclibraries typedefs opaque,
cclib_resource_pointer}.  Cast the @var{POINTER} to @code{cce_resource_data_t *} and return it.  We
can use this macro to make the code more readable when initialising exception handlers.
@end deftypefn


@deftypefn {Preprocessor Macro} {cce_resource_destructor_fun_t *} cce_resource_destructor (@var{POINTER})
Cast the @var{POINTER} to @code{cce_resource_destructor_fun_t *} and return it.  We can use this
macro to make the code more readable when initialising exception handlers.
@end deftypefn

@c page
@node handlers init
@section Initialising location handlers


@value{PACKAGE} offers a number of functions to initialise handler instances, but the recommended
@api{} is to use the preprocessor macro @cfunc{cce_init_handler}; this macro uses the dispatching
mechanism provided by @code{_Generic}.

@menu
* handlers init macro clean::  Initialising clean handlers with
                               generic macros.
* handlers init macro error::  Initialising error handlers with
                               generic macros.
* handlers init func clean::   Initialising clean handlers with functions.
* handlers init func error::   Initialising error handlers with functions.
* handlers init builtin::      Built-in handler functions.
@end menu

@c page
@node handlers init macro clean
@subsection Initialising clean handlers with generic macros


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftypefn {Preprocessor Macro} void cce_init_handler (cce_clean_handler_t * @var{H}, cce_clean_handler_fun_t * @var{handler_function}, void * @var{RESOURCE_POINTER})
Initialise the clean handler referenced by @var{H} with the given handler function and resource
pointer; the argument @var{RESOURCE_POINTER} can be @cnull{}.

Upon exiting the associated location context: the handler might finalise the resource referenced by
@var{RESOURCE_POINTER}, but it can also perform some unrelated operations.
@end deftypefn


@deftypefn {Preprocessor Macro} void cce_init_handler (cce_clean_handler_t * @var{H}, cce_clean_handler_fun_t * @var{handler_function},  void * @var{RESOURCE_POINTER}, cce_resource_destructor_fun_t * @var{RESOURCE_DESTRUCTOR})
Initialise the clean handler referenced by @var{H} with the given handler function, resource pointer
and resource destructor; the arguments @var{RESOURCE_POINTER} and @var{RESOURCE_DESTRUCTOR} can be
@cnull{}.

Upon exiting the associated location context: the handler might finalise the resource referenced by
@var{RESOURCE_POINTER} using the destructor function referenced by @var{RESOURCE_DESTRUCTOR}, but it
can also perform some unrelated operations.
@end deftypefn


As example of initialising a clean handler:

@smallexample
void
clean_handler (cce_condition_t const * C, cce_clean_handler_t const * P_H)
@{
  free(cce_handler_resource_pointer(P_H));
@}

void
main (void)
@{
  cce_location_t          L[1];
  cce_clean_handler_t     P_H[1];

  if (cce_location(L)) @{
    cce_run_catch_handlers_final(L);
  @} else @{
    void *  P = cce_sys_malloc(L, 4096);
    cce_init_handler(P_H, clean_handler, cce_resource_pointer(P));
    cce_register_handler(L, P_H);

    /* Do something with "P". */
    cce_run_body_handlers(L);
  @}
@}
@end smallexample

As example of initialising a clean handler using a destructor function:

@smallexample
void
clean_handler (cce_condition_t const * C, cce_clean_handler_t const * P_H)
@{
  cce_resource_destructor_fun_t * release;

  release = cce_handler_resource_destructor(P_H);
  release(cce_handler_resource_pointer(P_H));
@}

void
main (void)
@{
  cce_location_t          L[1];
  cce_clean_handler_t     P_H[1];

  if (cce_location(L)) @{
    cce_run_catch_handlers_final(L);
  @} else @{
    void *  P = cce_sys_malloc(L, 4096);
    cce_init_handler(P_H, clean_handler, cce_resource_pointer(P), free);
    cce_register_handler(L, P_H);

    /* Do something with "P". */
    cce_run_body_handlers(L);
  @}
@}
@end smallexample

As example of initialising a clean handler using a destructor function and the built--in handler
function:

@smallexample
void
main (void)
@{
  cce_location_t          L[1];
  cce_clean_handler_t     P_H[1];

  if (cce_location(L)) @{
    cce_run_catch_handlers_final(L);
  @} else @{
    void *  P = cce_sys_malloc(L, 4096);
    cce_init_handler(P_H, cce_default_clean_handler_function,
                     cce_resource_pointer(P), free);
    cce_register_handler(L, P_H);

    /* Do something with "P". */
    cce_run_body_handlers(L);
  @}
@}
@end smallexample

@c page
@node handlers init macro error
@subsection Initialising error handlers with generic macros


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftypefn {Preprocessor Macro} void cce_init_handler (cce_error_handler_t * @var{H}, cce_error_handler_fun_t * @var{handler_function}, void * @var{RESOURCE_POINTER})
Initialise the error handler referenced by @var{H} with the given handler function and resource
pointer; the argument @var{RESOURCE_POINTER} can be @cnull{}.

Upon exiting the associated location context: the handler might finalise the resource referenced by
@var{RESOURCE_POINTER}, but it can also perform some unrelated operations.
@end deftypefn


@deftypefn {Preprocessor Macro} void cce_init_handler (cce_error_handler_t * @var{H}, cce_error_handler_fun_t * @var{handler_function},  void * @var{RESOURCE_POINTER}, cce_resource_destructor_fun_t * @var{RESOURCE_DESTRUCTOR})
Initialise the error handler referenced by @var{H} with the given handler function, resource pointer
and resource destructor; the arguments @var{RESOURCE_POINTER} and @var{RESOURCE_DESTRUCTOR} can be
@cnull{}.

Upon exiting the associated location context: the handler might finalise the resource referenced by
@var{RESOURCE_POINTER} using the destructor function referenced by @var{RESOURCE_DESTRUCTOR}, but it
can also perform some unrelated operations.
@end deftypefn


As example of initialising a error handler:

@smallexample
void
error_handler (cce_condition_t const * C, cce_error_handler_t const * P_H)
@{
  free(cce_handler_resource_pointer(P_H));
@}

void
main (void)
@{
  cce_location_t          L[1];
  cce_error_handler_t     P_H[1];

  if (cce_location(L)) @{
    cce_run_catch_handlers_final(L);
  @} else @{
    void *  P = cce_sys_malloc(L, 4096);
    cce_init_handler(P_H, error_handler, cce_resource_pointer(P));
    cce_register_handler(L, P_H);

    /* Do something with "P". */
    cce_run_body_handlers(L);
  @}
@}
@end smallexample

As example of initialising a error handler using a destructor function:

@smallexample
void
error_handler (cce_condition_t const * C, cce_error_handler_t const * P_H)
@{
  cce_resource_destructor_fun_t * release;

  release = cce_handler_resource_destructor(P_H);
  release(cce_handler_resource_pointer(P_H));
@}

void
main (void)
@{
  cce_location_t          L[1];
  cce_error_handler_t     P_H[1];

  if (cce_location(L)) @{
    cce_run_catch_handlers_final(L);
  @} else @{
    void *  P = cce_sys_malloc(L, 4096);
    cce_init_handler(P_H, error_handler, cce_resource_pointer(P), free);
    cce_register_handler(L, P_H);

    /* Do something with "P". */
    cce_run_body_handlers(L);
  @}
@}
@end smallexample

As example of initialising a error handler using a destructor function and the built--in handler
function:

@smallexample
void
main (void)
@{
  cce_location_t          L[1];
  cce_error_handler_t     P_H[1];

  if (cce_location(L)) @{
    cce_run_catch_handlers_final(L);
  @} else @{
    void *  P = cce_sys_malloc(L, 4096);
    cce_init_handler(P_H, cce_default_error_handler_function,
                     cce_resource_pointer(P), free);
    cce_register_handler(L, P_H);

    /* Do something with "P". */
    cce_run_body_handlers(L);
  @}
@}
@end smallexample

@c page
@node handlers init func clean
@subsection Initialising clean handlers with functions


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftypefun void cce_init_clean_handler_3 (cce_clean_handler_t * @var{H}, cce_clean_handler_fun_t * @var{handler_function}, void * @var{RESOURCE_POINTER})
Initialise the clean handler referenced by @var{H} with the given handler function and resource
pointer; the argument @var{RESOURCE_POINTER} can be @cnull{}.

Upon exiting the associated location context: the handler might finalise the resource referenced by
@var{RESOURCE_POINTER}, but it can also perform some unrelated operations.
@end deftypefun


@deftypefun void cce_init_clean_handler_4 (cce_clean_handler_t * @var{H}, cce_clean_handler_fun_t * @var{handler_function}, void * @var{RESOURCE_POINTER}, cce_resource_destructor_fun_t * @var{RESOURCE_DESTRUCTOR})
Initialise the clean handler referenced by @var{H} with the given handler function, resource pointer
and resource destructor; the arguments @var{RESOURCE_POINTER} and @var{RESOURCE_DESTRUCTOR} can be
@cnull{}.

Upon exiting the associated location context: the handler might finalise the resource referenced by
@var{RESOURCE_POINTER} using the destructor function referenced by @var{RESOURCE_DESTRUCTOR}, but it
can also perform some unrelated operations.
@end deftypefun

@c page
@node handlers init func error
@subsection Initialising error handlers with functions


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftypefun void cce_init_error_handler_3 (cce_error_handler_t * @var{H}, cce_error_handler_fun_t * @var{handler_function}, void * @var{RESOURCE_POINTER})
Initialise the error handler referenced by @var{H} with the given handler function and resource
pointer; the argument @var{RESOURCE_POINTER} can be @cnull{}.

Upon exiting the associated location context: the handler might finalise the resource referenced by
@var{RESOURCE_POINTER}, but it can also perform some unrelated operations.
@end deftypefun


@deftypefun void cce_init_error_handler_4 (cce_error_handler_t * @var{H}, cce_error_handler_fun_t * @var{handler_function}, void * @var{RESOURCE_POINTER}, cce_resource_destructor_fun_t * @var{RESOURCE_DESTRUCTOR})
Initialise the error handler referenced by @var{H} with the given handler function, resource pointer
and resource destructor; the arguments @var{RESOURCE_POINTER} and @var{RESOURCE_DESTRUCTOR} can be
@cnull{}.

Upon exiting the associated location context: the handler might finalise the resource referenced by
@var{RESOURCE_POINTER} using the destructor function referenced by @var{RESOURCE_DESTRUCTOR}, but it
can also perform some unrelated operations.
@end deftypefun

@c page
@node handlers init builtin
@subsection Built-in handler functions


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftypefun void cce_default_clean_handler_function (cce_condition_t const * @var{C}, cce_clean_handler_t const * @var{H})
Handler function that tests if the handler referenced by @var{H} holds a pointer to a destructor
function, if it is: just apply the destructor to the pointer; otherwise do nothing.
@end deftypefun


@deftypefun void cce_default_error_handler_function (cce_condition_t const * @var{C}, cce_error_handler_t const * @var{H})
Handler function that tests if the handler referenced by @var{H} holds a pointer to a destructor
function, if it is: just apply the destructor to the pointer; otherwise do nothing.
@end deftypefun

@c page
@node handlers registering
@section Registering and forgetting location handlers


To execute an exception handler: we must register the handler structure in the context of a
location.  We can do this using the macro @cfunc{cce_register_handler}.

@menu
* handlers registering register::  Registering location handlers.
* handlers registering forget::    Forgetting location handlers.
@end menu

@c page
@node handlers registering register
@subsection Registering location handlers


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftypefun void cce_register_clean_handler (cce_destination_t @var{L}, cce_clean_handler_t * @var{H})
Register the clean handler referenced by @var{H} in the list of handlers associated to the location
@var{L}.  A clean handler is meant to be called whenever the execution flow leaves the dynamic
extent of a location, whether with an exception or as part of the successful execution path.
@end deftypefun


@deftypefun void cce_register_error_handler (cce_destination_t @var{L}, cce_error_handler_t * @var{H})
Register the error handler referenced by @var{H} in the list of handlers associated to the location
@var{L}.  An error handler is meant to be called whenever the execution flow leaves the dynamic
extent of a location in case of an exceptional condition; it must @strong{not} be called as part of
the successful execution path.
@end deftypefun


@deftypefn {Preprocessor Macro} void cce_register_handler (cce_destination_t @var{L}, cce_clean_handler_t * @var{H})
@deftypefnx {Preprocessor Macro} void cce_register_handler (cce_destination_t @var{L}, cce_error_handler_t * @var{H})
Generic macro using @code{_Generic} to dispatch its expansion depending on the type of the argument
@var{H}.  If the type of structure referenced by @var{H} is:

@table @objtype
@item cce_clean_handler_t
The macro expands into a call to @cfunc{cce_register_clean_handler}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{cce_register_error_handler}.
@end table
@end deftypefn

@c page
@node handlers registering forget
@subsection Forgetting location handlers


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftypefun void cce_forget_clean_handler (cce_destination_t @var{L}, cce_clean_handler_t * @var{H})
@deftypefunx void cce_forget_error_handler (cce_destination_t @var{L}, cce_error_handler_t * @var{H})
Remove the handler @var{H} from the context of the location @var{L}.  If @var{H} is not registered
in @var{L}: nothing happens.
@end deftypefun


@deftypefn {Preprocessor Macro} void cce_forget_handler (cce_destination_t @var{L}, cce_clean_handler_t * @var{H})
@deftypefnx {Preprocessor Macro} void cce_forget_handler (cce_destination_t @var{L}, cce_error_handler_t * @var{H})
Generic macro using @code{_Generic} to dispatch its expansion depending on the type of the argument
@var{H}.  If the type of structure referenced by @var{H} is:

@table @objtype
@item cce_clean_handler_t
The macro expands into a call to @cfunc{cce_forget_clean_handler}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{cce_forget_error_handler}.
@end table
@end deftypefn

@c page
@node handlers init and reg
@section Initialising and registering location handlers


It is possible to initialise an exception handler and register it in the context of a location with
a single step; for this we use the preprocessor macro @cfunc{cce_init_and_register_handler}; this
macro uses the dispatching mechanism provided by @code{_Generic}

@menu
* handlers init and reg macro clean::     Initialising and registering clean
                                          handlers with generic macros.
* handlers init and reg macro error::     Initialising and registering error
                                          handlers with generic macros.
* handlers init and reg function clean::  Initialising and registering clean
                                          handlers with functions.
* handlers init and reg function error::  Initialising and registering error
                                          handlers with functions.
@end menu

@c page
@node handlers init and reg macro clean
@subsection Initialising and registering clean handlers with generic macros


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftypefn {Preprocessor Macro} void cce_init_and_register_handler (cce_destination_t @var{L}, cce_clean_handler_t * @var{H}, cce_clean_handler_fun_t * @var{HANDLER_FUNCTION}, void * @var{RESOURCE_POINTER})
Initialise the clean handler referenced by @var{H} with the given handler function and resource
pointer; the argument @var{RESOURCE_POINTER} can be @cnull{}.  Register the clean handler referenced
by @var{H} in the list of handlers associated to the location @var{L}.

Upon exiting the associated location context: the handler might finalise the resource referenced by
@var{RESOURCE_POINTER}, but it can also perform some unrelated operations.
@end deftypefn


@deftypefn {Preprocessor Macro} void cce_init_and_register_handler (cce_destination_t @var{L}, cce_clean_handler_t * @var{H}, cce_clean_handler_fun_t * @var{HANDLER_FUNCTION}, void * @var{RESOURCE_POINTER}, cce_resource_destructor_fun_t * @var{RESOURCE_DESTRUCTOR})
Initialise the clean handler referenced by @var{H} with the given handler function, resource pointer
and resource destructor; the arguments @var{RESOURCE_POINTER} and @var{RESOURCE_DESTRUCTOR} can be
@cnull{}.  Register the clean handler referenced by @var{H} in the list of handlers associated to
the location @var{L}.

Upon exiting the associated location context: the handler might finalise the resource referenced by
@var{RESOURCE_POINTER} using the destructor function referenced by @var{RESOURCE_DESTRUCTOR}, but it
can also perform some unrelated operations.
@end deftypefn


As example of initialising a clean handler:

@smallexample
void
clean_handler (cce_condition_t const * C, cce_clean_handler_t const * P_H)
@{
  free(cce_handler_resource_pointer(P_H));
@}

void
main (void)
@{
  cce_location_t          L[1];
  cce_clean_handler_t     P_H[1];

  if (cce_location(L)) @{
    cce_run_catch_handlers_final(L);
  @} else @{
    void *  P = cce_sys_malloc(L, 4096);
    cce_init_and_register_handler(L, P_H, clean_handler,
      cce_resource_pointer(P));

    /* Do something with "P". */
    cce_run_body_handlers(L);
  @}
@}
@end smallexample

As example of initialising a clean handler using a destructor function:

@smallexample
void
clean_handler (cce_condition_t const * C, cce_clean_handler_t const * P_H)
@{
  cce_resource_destructor_fun_t * release;

  release = cce_handler_resource_destructor(P_H);
  release(cce_handler_resource_pointer(P_H));
@}

void
main (void)
@{
  cce_location_t          L[1];
  cce_clean_handler_t     P_H[1];

  if (cce_location(L)) @{
    cce_run_catch_handlers_final(L);
  @} else @{
    void *  P = cce_sys_malloc(L, 4096);
    cce_init_and_register_handler(L, P_H, clean_handler,
      cce_resource_pointerP, free);

    /* Do something with "P". */
    cce_run_body_handlers(L);
  @}
@}
@end smallexample

As example of initialising a clean handler using a destructor function and the built--in handler
function:

@smallexample
void
main (void)
@{
  cce_location_t          L[1];
  cce_clean_handler_t     P_H[1];

  if (cce_location(L)) @{
    cce_run_catch_handlers_final(L);
  @} else @{
    void *  P = cce_sys_malloc(L, 4096);
    cce_init_and_register_handler(L,
      P_H, cce_default_clean_handler_function,
      cce_resource_pointer(P), free);
    cce_register_handler(L, P_H);

    /* Do something with "P". */
    cce_run_body_handlers(L);
  @}
@}
@end smallexample

@c page
@node handlers init and reg macro error
@subsection Initialising and registering error handlers with generic macros


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftypefn {Preprocessor Macro} void cce_init_and_register_handler (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, cce_error_handler_fun_t * @var{HANDLER_FUNCTION}, void * @var{RESOURCE_POINTER})
Initialise the error handler referenced by @var{H} with the given handler function and resource
pointer; the argument @var{RESOURCE_POINTER} can be @cnull{}.  Register the error handler referenced
by @var{H} in the list of handlers associated to the location @var{L}.

Upon exiting the associated location context: the handler might finalise the resource referenced by
@var{RESOURCE_POINTER}, but it can also perform some unrelated operations.
@end deftypefn


@deftypefn {Preprocessor Macro} void cce_init_and_register_handler (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, cce_error_handler_fun_t * @var{HANDLER_FUNCTION}, void * @var{RESOURCE_POINTER}, cce_resource_destructor_fun_t * @var{RESOURCE_DESTRUCTOR})
Initialise the error handler referenced by @var{H} with the given handler function, resource pointer
and resource destructor; the arguments @var{RESOURCE_POINTER} and @var{RESOURCE_DESTRUCTOR} can be
@cnull{}.  Register the error handler referenced by @var{H} in the list of handlers associated to
the location @var{L}.

Upon exiting the associated location context: the handler might finalise the resource referenced by
@var{RESOURCE_POINTER} using the destructor function referenced by @var{RESOURCE_DESTRUCTOR}, but it
can also perform some unrelated operations.
@end deftypefn


As example of initialising a error handler:

@smallexample
void
error_handler (cce_condition_t const * C, cce_error_handler_t const * P_H)
@{
  free(cce_handler_resource_pointer(P_H));
@}

void
main (void)
@{
  cce_location_t          L[1];
  cce_error_handler_t     P_H[1];

  if (cce_location(L)) @{
    cce_run_catch_handlers_final(L);
  @} else @{
    void *  P = cce_sys_malloc(L, 4096);
    cce_init_and_register_handler(L, P_H, error_handler,
      cce_resource_pointer(P));

    /* Do something with "P". */
    cce_run_body_handlers(L);
  @}
@}
@end smallexample

As example of initialising a error handler using a destructor function:

@smallexample
void
error_handler (cce_condition_t const * C, cce_error_handler_t const * P_H)
@{
  cce_resource_destructor_fun_t * release;

  release = cce_handler_resource_destructor(P_H);
  release(cce_handler_resource_pointer(P_H));
@}

void
main (void)
@{
  cce_location_t          L[1];
  cce_error_handler_t     P_H[1];

  if (cce_location(L)) @{
    cce_run_catch_handlers_final(L);
  @} else @{
    void *  P = cce_sys_malloc(L, 4096);
    cce_init_and_register_handler(L, P_H, error_handler,
      cce_resource_pointer(P), free);

    /* Do something with "P". */
    cce_run_body_handlers(L);
  @}
@}
@end smallexample

As example of initialising a error handler using a destructor function and the built--in handler
function:

@smallexample
void
main (void)
@{
  cce_location_t          L[1];
  cce_error_handler_t     P_H[1];

  if (cce_location(L)) @{
    cce_run_catch_handlers_final(L);
  @} else @{
    void *  P = cce_sys_malloc(L, 4096);
    cce_init_and_register_handler(L,
      P_H, cce_default_error_handler_function,
      cce_resource_pointer(P), free);
    cce_register_handler(L, P_H);

    /* Do something with "P". */
    cce_run_body_handlers(L);
  @}
@}
@end smallexample

@c page
@node handlers init and reg function clean
@subsection Initialising and registering clean handlers with functions


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftypefun void cce_init_and_register_clean_handler_4 (cce_destination_t @var{L}, cce_clean_handler_t * @var{H}, cce_clean_handler_fun_t * @var{HANDLER_FUNCTION}, void * @var{RESOURCE_POINTER})
Initialise the clean handler referenced by @var{H} with the given handler function and resource
pointer; the argument @var{RESOURCE_POINTER} can be @cnull{}.  Register the clean handler referenced
by @var{H} in the list of handlers associated to the location @var{L}.

Upon exiting the associated location context: the handler might finalise the resource referenced by
@var{RESOURCE_POINTER}, but it can also perform some unrelated operations.
@end deftypefun


@deftypefun void cce_init_and_register_clean_handler_5 (cce_destination_t @var{L}, cce_clean_handler_t * @var{H}, cce_clean_handler_fun_t * @var{HANDLER_FUNCTION}, void * @var{RESOURCE_POINTER}, cce_resource_destructor_fun_t * @var{RESOURCE_DESTRUCTOR})
Initialise the clean handler referenced by @var{H} with the given handler function, resource pointer
and resource destructor; the arguments @var{RESOURCE_POINTER} and @var{RESOURCE_DESTRUCTOR} can be
@cnull{}.  Register the clean handler referenced by @var{H} in the list of handlers associated to
the location @var{L}.

Upon exiting the associated location context: the handler might finalise the resource referenced by
@var{RESOURCE_POINTER} using the destructor function referenced by @var{RESOURCE_DESTRUCTOR}, but it
can also perform some unrelated operations.
@end deftypefun

@c page
@node handlers init and reg function error
@subsection Initialising and registering error handlers with functions


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftypefun void cce_init_and_register_error_handler_4 (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, cce_error_handler_fun_t * @var{HANDLER_FUNCTION}, void * @var{RESOURCE_POINTER})
Initialise the error handler referenced by @var{H} with the given handler function and resource
pointer; the argument @var{RESOURCE_POINTER} can be @cnull{}.  Register the error handler referenced
by @var{H} in the list of handlers associated to the location @var{L}.

Upon exiting the associated location context: the handler might finalise the resource referenced by
@var{RESOURCE_POINTER}, but it can also perform some unrelated operations.
@end deftypefun


@deftypefun void cce_init_and_register_error_handler_5 (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, cce_error_handler_fun_t * @var{HANDLER_FUNCTION}, void * @var{RESOURCE_POINTER}, cce_resource_destructor_fun_t * @var{RESOURCE_DESTRUCTOR})
Initialise the error handler referenced by @var{H} with the given handler function, resource pointer
and resource destructor; the arguments @var{RESOURCE_POINTER} and @var{RESOURCE_DESTRUCTOR} can be
@cnull{}.  Register the error handler referenced by @var{H} in the list of handlers associated to
the location @var{L}.

Upon exiting the associated location context: the handler might finalise the resource referenced by
@var{RESOURCE_POINTER} using the destructor function referenced by @var{RESOURCE_DESTRUCTOR}, but it
can also perform some unrelated operations.
@end deftypefun

@c page
@node handlers accessors
@section Accessing location handlers


@menu
* handlers accessors resource::    Accessing the resource.
* handlers accessors destructor::  Accessing the destructor.
@end menu

@c page
@node handlers accessors resource
@subsection Accessing the resource


Every handler instance holds pointer to the manage resource.  The following accessor functions allow
us to retrieve such a pointer.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftypefun {void *} cce_clean_handler_resource_pointer (cce_clean_handler_t const * @var{H})
@deftypefunx {void *} cce_error_handler_resource_pointer (cce_error_handler_t const * @var{H})
Return the pointer to resource stored in the given handler.
@end deftypefun


@deftypefn {Preprocessor Macro} {void *} cce_handler_resource_pointer (cce_clean_handler_t * @var{H})
@deftypefnx {Preprocessor Macro} {void *} cce_handler_resource_pointer (cce_error_handler_t * @var{H})
Generic macro using @code{_Generic} to dispatch its expansion depending on the type of the argument
@var{H}.  If the type of structure referenced by @var{H} is:

@table @code
@item cce_clean_handler_t
@itemx cce_clean_handler_t
Expand into a call to @cfunc{cce_clean_handler_resource_pointer}.

@item cce_error_handler_t
Expand into a call to @cfunc{cce_error_handler_resource_pointer}.
@end table
@end deftypefn

@c page
@node handlers accessors destructor
@subsection Accessing the destructor


Every handler instance may hold a pointer to a destructor function for the managed resource.  The
following accessor functions allow us to retrieve such a pointer.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftypefun {void *} cce_clean_handler_resource_destructor (cce_clean_handler_t const * @var{H})
@deftypefunx {void *} cce_error_handler_resource_destructor (cce_error_handler_t const * @var{H})
Return the pointer to resource stored in the given handler.
@end deftypefun


@deftypefn {Preprocessor Macro} {void *} cce_handler_resource_destructor (cce_clean_handler_t * @var{H})
@deftypefnx {Preprocessor Macro} {void *} cce_handler_resource_destructor (cce_error_handler_t * @var{H})
Generic macro using @code{_Generic} to dispatch its expansion depending on the type of the argument
@var{H}.  If the type of structure referenced by @var{H} is:

@table @code
@item cce_clean_handler_t
@itemx cce_clean_handler_t
Expand into a call to @cfunc{cce_clean_handler_resource_destructor}.

@item cce_error_handler_t
Expand into a call to @cfunc{cce_error_handler_resource_destructor}.
@end table
@end deftypefn

@c page
@node handlers running
@section Running location handlers


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftypefun void cce_run_body_handlers (cce_destination_t @var{L})
Run all the clean handlers associated to the location @var{L}.  Each handler must return to its
caller, taking care of itself regarding internal error handling and asynchronous resources
allocation.  Handlers are called starting from the last registered one.

This is a destructive function: once the list has been traversed, it is not valid anymore.  When the
handler function is applied to the handler structure: the handler structure is completely detached
from the context of @var{L}, so it can be finalised and its memory released.
@end deftypefun


@deftypefun void cce_run_catch_handlers (cce_destination_t @var{L})
Run all the clean and error handlers associated to the location @var{L}.  Each handler must return
to its caller, taking care of itself regarding internal error handling and asynchronous resources
allocation.  Handlers are called starting from the last registered one.

This is a destructive function: once the list has been traversed, it is not valid anymore.  When the
handler function is applied to the handler structure: the handler structure is completely detached
from the context of @var{L}, so it can be finalised and its memory released.

The clean handlers are invoked first, in reverse order with respect of their registration; the error
handlers are invoked last, in reverse order with respect of their registration.

@strong{NOTE} This function must assume that an error handler might access the
exceptional--condition object associated to @var{L} upon raising the exception, so this function
should always be called @strong{before} applying @cfunc{cce_condition_delete} to the return value of
@code{cce_condition(@var{L})}.
@end deftypefun


@deftypefun void cce_run_catch_handlers_final (cce_destination_t @var{L})
Equivalent to calling:

@example
cce_run_catch_handlers(L);
cce_condition_delete(cce_condition(L));
@end example
@end deftypefun


@deftypefun void cce_run_body_handlers_final (cce_destination_t @var{L})
Equivalent to calling:

@example
cce_run_body_handlers(L);
cce_condition_delete(cce_condition(L));
@end example
@end deftypefun


@deftypefun void cce_run_catch_handlers_raise (cce_destination_t @var{L}, cce_location_t * @var{upper_L})
Equivalent to calling:

@example
cce_run_catch_handlers(L);
cce_raise(upper_L, cce_condition(L));
@end example
@end deftypefun


@deftypefun void cce_run_body_handlers_raise (cce_destination_t @var{L}, cce_location_t * @var{upper_L})
Equivalent to calling:

@example
cce_run_body_handlers(L);
cce_raise(upper_L, cce_condition(L));
@end example
@end deftypefun

@c page
@node handlers handlers
@section Running handlers from handlers


It is sometimes useful to execute complex code in an exception--handler code block; for example we
may need to map a set of exceptional--condition objects into another set.  Whenever an
exception--handler code block needs to handle exceptions itself, we must register the outer handlers
as inner handlers; @value{PACKAGE} offers functions to do this with ease.

The basic code template is this:

@example
cce_location_t  outer_L[1];

if (cce_location(outer_L)) @{
  /* outer exception handler */
  cce_location_t  inner_L[1];

  if (cce_location(inner_L)) @}
    /* inner exception handler */
    cce_run_catch_handlers_final(inner_L);
  @} else @{
    /* inner body */
    cce_run_body_handlers(inner_L);
  @}
@} else @{
  /* outer body */
  cce_run_body_handlers(outer_L);
@}
@end example

@menu
* handlers handlers cc::        Using a clean handler to run clean handlers.
* handlers handlers ce::        Using a clean handler to run error handlers.
* handlers handlers ec::        Using an error handler to run clean handlers.
* handlers handlers ee::        Using an error handler to run error handlers.
@end menu

@c page
@node handlers handlers cc
@subsection Using a clean handler to run clean handlers


@deftypefun void cce_register_clean_handler_to_run_body_handlers (cce_destination_t @var{inner_L}, cce_clean_handler_t * @var{inner_H}, cce_destination_t @var{outer_L})
Register the clean handler @var{inner_H}, in the context of the location @var{inner_L}, so that it
will run the clean handlers registered for the location @var{outer_L}.  The exceptional--condition
object associated to @var{outer_L} will be deleted by the handler.
@end deftypefun


We can use this function as follows:

@smallexample
cce_location_t  outer_L[1];

if (cce_location(outer_L)) @{
  /* outer exception handler */
  cce_location_t       inner_L[1];
  cce_clean_handler_t  inner_H[1];

  if (cce_location(inner_L)) @}
    /* inner exception handler */
    cce_run_catch_handlers_final(inner_L);
  @} else @{
    cce_register_clean_handler_to_run_body_handlers(inner_L, inner_H,
      cce_resource_pointer(outer_L));
    /* inner body */
    cce_run_body_handlers(inner_L);
  @}
@} else @{
  /* outer body */
  cce_run_body_handlers(outer_L);
@}
@end smallexample

@c page
@node handlers handlers ce
@subsection Using a clean handler to run error handlers


@deftypefun void cce_register_clean_handler_to_run_catch_handlers (cce_destination_t @var{inner_L}, cce_clean_handler_t * @var{inner_H}, cce_destination_t @var{outer_L})
Register the clean handler @var{inner_H}, in the context of the location @var{inner_L}, so that it
will run the error handlers registered for the location @var{outer_L}.  The exceptional--condition
object associated to @var{outer_L} will be deleted by the handler.
@end deftypefun


We can use this function as follows:

@smallexample
cce_location_t  outer_L[1];

if (cce_location(outer_L)) @{
  /* outer exception handler */
  cce_location_t       inner_L[1];
  cce_clean_handler_t  inner_H[1];

  if (cce_location(inner_L)) @}
    /* inner exception handler */
    cce_run_catch_handlers_final(inner_L);
  @} else @{
    cce_register_clean_handler_to_run_catch_handlers(inner_L, inner_H,
      cce_resource_pointer(outer_L));
    /* inner body */
    cce_run_body_handlers(inner_L);
  @}
@} else @{
  /* outer body */
  cce_run_body_handlers(outer_L);
@}
@end smallexample

@c page
@node handlers handlers ec
@subsection Using an error handler to run clean handlers


@deftypefun void cce_register_error_handler_to_run_body_handlers (cce_destination_t @var{inner_L}, cce_error_handler_t * @var{inner_H}, cce_destination_t @var{outer_L})
Register the error handler @var{inner_H}, in the context of the location @var{inner_L}, so that it
will run the clean handlers registered for the location @var{outer_L}.  The exceptional--condition
object associated to @var{outer_L} will be deleted by the handler.
@end deftypefun


We can use this function as follows:

@smallexample
cce_location_t  outer_L[1];

if (cce_location(outer_L)) @{
  /* outer exception handler */
  cce_location_t       inner_L[1];
  cce_error_handler_t  inner_H[1];

  if (cce_location(inner_L)) @}
    /* inner exception handler */
    cce_run_catch_handlers_final(inner_L);
  @} else @{
    cce_register_error_handler_to_run_body_handlers(inner_L, inner_H,
      cce_resource_pointer(outer_L));
    /* inner body */
    cce_run_body_handlers(inner_L);
  @}
@} else @{
  /* outer body */
  cce_run_body_handlers(outer_L);
@}
@end smallexample

@c page
@node handlers handlers ee
@subsection Using an error handler to run error handlers


@deftypefun void cce_register_error_handler_to_run_catch_handlers (cce_destination_t @var{inner_L}, cce_error_handler_t * @var{inner_H}, cce_destination_t @var{outer_L})
Register the error handler @var{inner_H}, in the context of the location @var{inner_L}, so that it
will run the error handlers registered for the location @var{outer_L}.  The exceptional--condition
object associated to @var{outer_L} will be deleted by the handler.
@end deftypefun


We can use this function as follows:

@smallexample
cce_location_t  outer_L[1];

if (cce_location(outer_L)) @{
  /* outer exception handler */
  cce_location_t       inner_L[1];
  cce_error_handler_t  inner_H[1];

  if (cce_location(inner_L)) @}
    /* inner exception handler */
    cce_run_catch_handlers_final(inner_L);
  @} else @{
    cce_register_error_handler_to_run_catch_handlers(inner_L, inner_H,
      cce_resource_pointer(outer_L));
    /* inner body */
    cce_run_body_handlers(inner_L);
  @}
@} else @{
  /* outer body */
  cce_run_body_handlers(outer_L);
@}
@end smallexample

@c page
@node conditions
@chapter Exceptional condition descriptors


In the context of the @value{PACKAGE} framework, we represent exceptional conditions with a tree
hierarchy of data structures; this way it is possible to react to a raised exception by branching at
runtime according to the type of raised structure.

@value{PACKAGE} implements two equivalent @api{} to handle exceptional--condition objects:

@enumerate
@item
A plain @api{} using common C language identifiers, like @cfunc{cce_condition_new_runtime_error}.

@item
The @code{cclib} @api{} using the automatic identifiers generation facilities of the header file
@file{cclibraries.h}; the identifiers are built at preprocessing time from macros uses like:

@example
cclib_new(cclib_exceptional_condition_object_type(cce_runtime_error))
@end example

@ref{cclibraries conditions, Exceptional--condition objects}.
@end enumerate

@noindent
we are free to use the two sets of identifiers interchangeably.

@menu
* conditions intro::            Introduction to exceptional-condition objects.
* conditions descriptors::      Exceptional-condition object-type descriptors.
* conditions objects::          Exceptional-condition objects.
* conditions root::             The @emph{root} exceptional-condition object.
* conditions unknown::          The @emph{unknown} exceptional-condition object.
* conditions break::            The @emph{break} exceptional-condition object.
* conditions error::            The @emph{error} exceptional-condition object.
* conditions runtime error::    The @emph{runtime error} exceptional-condition
                                object.
* conditions logic error::      The @emph{logic error} exceptional-condition
                                object.
* conditions unimplemented::    The @emph{unimplemented} exceptional-condition
                                object.
* conditions invalid arg::      The @emph{invalid argument} exceptional-condition
                                object.
* conditions unreachable::      The @emph{unreachable code} exceptional-condition
                                object.
* conditions errno::            The @code{errno} exceptional-condition object.
* conditions math::             The mathematical exceptional-condition objects.
* conditions custom::           Defining custom exceptional-condition
                                object-types.
@end menu

@c page
@node conditions intro
@section Introduction to exceptional--condition objects


The purpose of @value{PACKAGE}'s exceptional--condition objects module is to allow us to write code
like this:

@example
cce_location_t  L[1];

if (cce_location(L)) @{
  // handle the exceptional condition
  if (my_condition_is_alpha(cce_condition(L)))
    @{
      // react to exception "alpha"
    @}
  else if (my_condition_is_beta(cce_condition(L)))
    @{
      // react to exception "beta"
    @}
  else
    @{
      // default reaction to any exception
    @}
  cce_run_catch_handlers_final(L);
@} else @{
  // do something useful
  cce_run_body_handlers(L);
@}
@end example

@noindent
in which we use some, previously defined, exceptional--condition object--types @samp{alpha} and
@samp{beta}.

If we need to hand the exceptional--condition object to an upper level location we can do it as
follows:

@example
void
upper_function (void)
@{
  cce_location_t        L[1];

  if (cce_location(L)) @{
    fprintf(stderr, "log: %s\n", \
        cce_condition_static_message(cce_condition(L)));
    cce_run_catch_handlers_final(L);
  @} else @{
    lower_function(L);
    cce_run_body_handlers(L);
  @}
@}

void
lower_function (cce_location_t * upper_L)
@{
  cce_location_t        L[1];

  if (cce_location(L)) @{
    cce_run_catch_handlers_raise(L, upper_L);
  @} else @{
    do_something();
    if (an_error_occurred()) @{
      cce_raise(L, select_condition_object());
    @}
   cce_run_body_handlers(L);
  @}
@}
@end example

From the point of view of our ability to react to an exception at runtime: a flexible situation is
the one in which the exceptional--condition object--types are organised in a tree hierarchy.  It
allows us to select the level of granularity we desire in the branching logic.  The tree hierarchy
implemented by @value{PACKAGE} uses single inheritance; multiple inheritance would be more general,
but also more complex.

@c ------------------------------------------------------------------------

@subsubheading How the hierarchy is implemented

Exceptional--condition objects are C language structures referencing a type descriptor, which is
also a C language structure.  Type descriptors are usually statically allocated and mostly have a
hard--coded initialisation.  Exceptional--condition objects are either dynamically allocated and
initialised or statically allocated with hard--coded initialisation.

Every type descriptor data structure encloses a data structure of type @objtype{cce_descriptor_t},
which must be its first field.  The instances of @objtype{cce_descriptor_t} hold the pointers that
define the tree hierarchy; every type descriptor can be referenced by multiple
exceptional--condition objects: it can represent the type of multiple objects; every type descriptor
has a single parent and can have zero, one or more children.  Each pointer to
@objtype{cce_descriptor_t} is a unique runtime value identifying the type of
exceptional--condition objects.

Every exceptional--condition object's data structure encloses a data structure of type
@objtype{cce_condition_t}, which must be its first field.  The exceptional--condition object holds a
pointer to the associated type descriptor.

The root of the tree is represented by the object--type descriptor @objtype{cce_descriptor_root_t}
and objects of such type are @code{struct} of type @objtype{cce_condition_root_t}.  We can think of
the root structure types as follows:

@smallexample
typedef struct cce_condition_root_t     cce_descriptor_root_t;
typedef struct cce_condition_root_t     cce_condition_root_t;

struct cce_descriptor_root_t @{
  cce_descriptor_t	descriptor;
@};

struct cce_condition_root_t @{
  cce_condition_t	condition;
@};

extern cce_descriptor_root_t const * const cce_descriptor_root_ptr;
@end smallexample

We declare the @code{struct} types needed to define a new exceptional--condition object--type, child
of the @emph{root} type, as follows:

@smallexample
typedef struct my_descriptor_error_t  my_descriptor_error_t;
typedef struct my_condition_error_t   my_condition_error_t;

struct my_descriptor_error_t @{
  cce_descriptor_t  descriptor;
  /* Put some custom fields here. */
@};

struct my_condition_error_t @{
  cce_condition_root_t  root;
  /* Put some custom fields here. */
@};
@end smallexample

@noindent
the field of type @objtype{cce_descriptor_t} is the first in its data structure type; the field of
type @objtype{cce_condition_root_t} is the first in its data structure type.

In the following picture: the @emph{alpha} descriptor is a child of the @emph{root} descriptor; the
@emph{beta} descriptor is a child of the type @samp{alpha} descriptor.  We can say that:

@itemize
@item
An exceptional--condition object of type @emph{alpha} is also of type @emph{root}.

@item
An exceptional--condition object of type @emph{beta} is also of type @emph{alpha} and of type
@emph{root}.
@end itemize

@example
 -----------------
| descriptor root |
 -----------------
         ^
         |
 ------------------       --------------
| descriptor alpha | <-- | object alpha |
 ------------------       --------------
         ^
         |
 -----------------        -------------
| descriptor beta | <--- | object beta |
 -----------------        -------------
@end example

The data types that represent such hierarchy look as follows:

@smallexample
typedef struct my_descriptor_alpha_t my_descriptor_alpha_t;
typedef struct my_descriptor_beta_t  my_descriptor_beta_t;
typedef struct my_condition_alpha_t  my_condition_alpha_t;
typedef struct my_condition_beta_t   my_condition_beta_t;

/*** Descriptors types. ***/

struct my_descriptor_alpha_t @{
  cce_descriptor_t  descriptor;
@};

struct my_descriptor_beta_t @{
  cce_descriptor_t  descriptor;
@};

/*** Object types. ***/

struct my_condition_alpha_t @{
  cce_condition_root_t  root;
@};

struct my_condition_beta_t @{
  my_condition_alpha_t  alpha;
@};
@end smallexample

@noindent
we can statically allocate and initialise the type descriptors as follows:

@smallexample
my_descriptor_alpha_t my_descriptor_alpha = @{
  .descriptor.parent = NULL
@};

my_descriptor_beta_t  my_descriptor_beta  = @{
  .descriptor.parent = &my_descriptor_alpha.descriptor
@};

void
initialisation_function (void)
@{
  cce_descriptor_set_parent_to(cce_descriptor_root_t) \
    (&my_descriptor_alpha.descriptor);
@}
@end smallexample

@c page
@node conditions descriptors
@section Exceptional--condition object--type descriptors


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_descriptor_t
Structure type representing exceptional--condition object--type descriptors; it holds a table
of function pointers to handle exceptional--condition objects.  It has the following fields:

@table @code
@item cce_descriptor_t const * parent
Pointer to the descriptor that is parent of this one in the tree hierarchy.  This pointer is set to
@cnull{} only for the root condition descriptor, @xref{conditions root, Predefined root condition
descriptor}.

@item cce_condition_final_fun_t * delete
Pointer to function releasing the exceptional--condition object's memory block itself.  This pointer
can be @cnull{}, meaning that: the object is statically allocated.

@item cce_condition_final_fun_t * final
Pointer to function releasing all the dynamic resources associated to the exceptional--condition
object.  This pointer can be @cnull{}, meaning that: there are no dynamic resources.

@item cce_condition_static_message_fun_t * static_message
Pointer to function returning a statically allocated @asciiz{} string describing the
exceptional--condition.
@end table
@end deftp


@deftypefn {Function Prototype} void cce_condition_final_fun_t (cce_condition_t * @var{C})
Release all the dynamic resources associated to @var{C}; leave untouched the memory block holding
the @objtype{cce_condition_t} instance itself.
@end deftypefn


@deftypefn {Function Prototype} void cce_condition_delete_fun_t (cce_condition_t * @var{C})
Release the memory block referenced by @var{C}, if appropriate.  If the structure is allocated with
@cfunc{malloc}, the @code{delete} function can just be:

@example
void
my_condition_delete_stuff (my_condition_stuff_t * C)
@{
  free(C);
@}
@end example
@end deftypefn


@deftypefn {Function Prototype} {char const *} cce_condition_static_message_fun_t (cce_condition_t const * @var{C})
Return a statically allocated @asciiz{} string describing the exceptional--condition.  A static
message must always be defined; another client--defined function can build a dynamic and more
descriptive message.

For example, an instance of this function can be:

@example
char const *
my_condition_static_message_stuff (my_condition_stuff_t const * C)
@{
  return "error doing stuff";
@}
@end example
@end deftypefn


@deftypefun bool cce_descriptor_child_and_ancestor (cce_descriptor_t const * @var{child}, cce_descriptor_t const * @var{ancestor})
Establish if two condition descriptors are child and ancestor.  Return @ctrue{} if @var{child} is
equal to @var{ancestor} or @var{ancestor} is in the hierarchy of @var{child}'s ancestors; otherwise
return @cfalse{}.
@end deftypefun


@deftypefn {Generic Macro} {cce_descriptor_t *} cce_descriptor (@var{X})
This generic macro dispatches its expansion according to its argument's type:

@itemize
@item
Given a pointer to condition object: retrieve the pointer to its descriptor and cast it to a pointer
to @objtype{cce_descriptor_t}.

@item
Given a pointer to condition descriptor: cast it to a pointer to @objtype{cce_descriptor_t}.
@end itemize

This generic macro performs compile--time type--checking so that the cast operation is applied only
on values of suitable types; we can apply this macro to pointers to all the types defined by
@value{PACKAGE} for which it makes sense.
@end deftypefn


@anchor{cce_descriptor_set_parent_to}
@defmac cce_descriptor_set_parent_to (@var{TYPE})
Expand into the name of a function that we can use to set the parent of a descriptor to the given
@var{TYPE} descriptor.
@end defmac


@anchor{cce_descriptor_pointer}
@deftypefn {Preprocessor Macro} {cce_descriptor_t *} cce_descriptor_pointer (@var{EXCEPTIONAL_CONDITION_DESCRIPTOR_VARIABLE})
Expand into:

@example
&((@var{EXCEPTIONAL_CONDITION_DESCRIPTOR_VARIABLE}).descriptor)
@end example

Given an exceptional-condition descriptor @struct{} defined as:

@example
typedef struct descr_t  descr_t;

struct descr_t @{
  cce_descriptor_t      descriptor;
@};

descr_t my_descriptor_descr = @{ ... @};
@end example

@noindent
this macro is used as:

@example
cce_descriptor_pointer(my_descriptor_descr)
@end example

@noindent
to expand into:

@example
&((my_descriptor_descr).descriptor)
@end example
@end deftypefn

@c page
@node conditions objects
@section Exceptional-condition objects


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_condition_t
Type of structure representing an exceptional--condition object.  It has the following public
fields:

@table @code
@item cce_descriptor_t const * descriptor
Pointer to the descriptor of the exceptional--condition object--type.
@end table
@end deftp


@deftypefun void cce_condition_init (cce_condition_t * @var{C}, cce_descriptor_t const * @var{D})
Initialise the core fields of an already allocated condition object.  The argument @var{D} must be a
pointer to the descriptor: it is stored in the object referenced by @var{C}.  This function is
usually called from a type--specific constructor function.
@end deftypefun


@deftypefun void cce_condition_final (cce_condition_t * @var{C})
@strong{Usually we do not need to call this function directly; rather, we should use
@cfunc{cce_condition_delete}.}

Traverse, from leaf to root, the hierarchy of descriptors for the type of the exceptional--condition
object referenced by @var{C}: apply to @var{C} the @code{final} functions referenced by the
descriptors' functions tables.  The finalisation functions are applied from leaf to root.
@end deftypefun


@deftypefun void cce_condition_delete (cce_condition_t * @var{C})
Apply @cfunc{cce_condition_final} to @var{C}; then apply to @var{C} the @code{delete} function
referenced by the descriptor's functions table.
@end deftypefun


@deftypefun {char const *} cce_condition_static_message (cce_condition_t const * @var{C})
Apply to @var{C} the @code{static_message} function referenced by its descriptor's functions
table.
@end deftypefun


@deftypefun bool cce_condition_is (cce_condition_t const * @var{C}, cce_descriptor_t const * @var{D})
Determine if an object is of a selected object--type.  Return @ctrue{} if the object referenced by
@var{C} is an instance of the type whose descriptor is referenced by @var{D}, or an instance of a
type that is an ancestor of such descriptor; otherwise return @cfalse{}.
@end deftypefun


@deftypefn {Generic Macro} {cce_condition_t *} cce_condition (@var{X})
This generic macro dispatches its expansion according to its argument's type:

@itemize
@item
Given a pointer to @objtype{cce_location_t}: retrieve a pointer to the associated condition object
and cast it to a pointer to @objtype{cce_condition_t}.

@item
Given a pointer to condition object: cast it to a pointer to @objtype{cce_condition_t}.
@end itemize

This generic macro performs compile--time type--checking so that the cast operation is applied only
on values of suitable types; we can apply this macro to pointers to all the types defined by
@value{PACKAGE} for which it makes sense.

This macro allows us to compare pointers without raising a warning:

@example
cce_condition_errno_t * A = ...;
cce_condition_t *       B = ...;

/* This raises a warning: */
A == B;

/* This does not raise a warning: */
cce_condition(A) == cce_condition(B);
@end example
@end deftypefn

@c page
@node conditions root
@section The @emph{root} exceptional--condition object


@ExceptionalConditionIndexEntries{root}


The @dfn{root} exceptional--condition object--type descriptor has the only purpose of being the root
of the descriptors tree; there should be no exceptional--condition objects having this as
descriptor.  The @emph{root} descriptor has @code{parent} field set to @cnull{}; this must be the
only descriptor with such a property.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_descriptor_root_t
@deftpx {Struct Typedef} {cclib_exceptional_condition_descriptor_type(cce_root)}
Structure type representing the @emph{root} exceptional--condition object--type descriptor,
the root of the descriptors hierarchy tree.  This descriptor has a single instance built into the
library.  It has the following public fields:

@table @code
@item cce_descriptor_t descriptor
Core values of the exceptional--condition object--type descriptor.
@end table
@end deftp


@deftp {Struct Typedef} cce_condition_root_t
@deftpx {Struct Typedef} {cclib_exceptional_condition_object_type(cce_root)}
Structure type representing the @emph{root} exceptional--condition object; this @code{struct}
type must never be instantiated.  It has the following public fields:

@table @code
@item cce_condition_t condition
Core values of the exceptional--condition object.
@end table
@end deftp


@deftypefun bool cce_condition_is_root (cce_condition_t const * @var{C})
@deftypefunx bool {cclib_is(cclib_exceptional_condition_object_type(cce_root))} (cce_condition_t const * @var{C})
Return @ctrue{} if the object referenced by @var{C} is derived from the @emph{root} type; otherwise
return @cfalse{}.  With a correctly built conditions hierarchy: this function always returns
@ctrue{}.
@end deftypefun

@c ------------------------------------------------------------------------

@CCEConditionSubtypingFacilitiesNoArgs{cce,root}

@c ------------------------------------------------------------------------

@ConditionSubtypingExample{root, root}

@c page
@node conditions unknown
@section The @emph{unknown} exceptional--condition object


@ExceptionalConditionIndexEntries{unknown}


The @dfn{unknown} exceptional--condition object--type has the purpose of describing an
exceptional--condition with unknown cause; it should be used only by the function @cfunc{cce_raise}
when the condition object argument is set to @cnull{}.

There should be only one @emph{unknown} exceptional--condition object: the one predefined by
@value{PACKAGE} and built into the library as statically allocated structure.  Subtyping from the
@emph{unknown} type is discouraged.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@CCEDescriptorTypedef{cce,unknown,cce_descriptor_root_t}


@deftp {Struct Typedef} @CCEConditionObjectType{cce,unknown}
@deftpx {Struct Typedef} {cclib_exceptional_condition_object_type(cce_unknown)}
Structure type representing the exceptional--condition object.  It has the following public fields:

@table @code
@item cce_condition_root_t root
Core values of the exceptional--condition object.
@end table
@end deftp


@CCEConditionObjectNewNoArgsStatic{cce,unknown}


@CCEConditionObjectPredicate{cce,unknown}

@c ------------------------------------------------------------------------

@CCEConditionSubtypingFacilitiesNoArgs{cce,unknown}

@c page
@node conditions break
@section The @emph{break} exceptional--condition object


@ExceptionalConditionIndexEntries{break}


The @dfn{break} exceptional--condition object--type has the purpose of describing an exceptional
condition used to break out of a loop or a function call; this object--type does @strong{not}
represent an error of any kind.

There should be only one @emph{break} exceptional--condition object: the one predefined by
@value{PACKAGE} and built into the library as statically allocated structure.  Subtyping from this
object--type is fine to represent different reasons for escaping.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@CCEDescriptorTypedef{cce,break,cce_descriptor_root_t}


@deftp {Struct Typedef} cce_condition_break_t
@deftpx {Struct Typedef} {cclib_exceptional_condition_object_type(cce_break)}
Structure type representing the exceptional--condition object.  It has the following public fields:

@table @code
@item cce_condition_root_t root
Core values of the exceptional--condition object.
@end table
@end deftp


@CCEConditionObjectNewNoArgsStatic{cce,break}


@CCEConditionObjectPredicate{cce,break}

@c ------------------------------------------------------------------------

@CCEConditionSubtypingFacilitiesNoArgs{cce,break}

@c ------------------------------------------------------------------------

@ConditionSubtypingExample{break, break}

@c page
@node conditions error
@section The @emph{error} exceptional--condition object


@ExceptionalConditionIndexEntries{error}


The @dfn{error} exceptional--condition object--type has the purpose of describing an exceptional
condition caused by an unspecified error; this condition type is meant to be the base of more
specialised object--types.

There should be only one @emph{error} exceptional--condition object: the one predefined by
@value{PACKAGE} and built into the library as statically allocated structure.  Subtyping from this
object--type is fine.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@CCEDescriptorTypedef{cce,error,cce_descriptor_root_t}


@deftp {Struct Typedef} cce_condition_error_t
@deftpx {Struct Typedef} {cclib_exceptional_condition_object_type(cce_error)}
Structure type representing the exceptional--condition object.  It has the following public fields:

@table @code
@item cce_condition_root_t root
Core values of the exceptional--condition object.
@end table
@end deftp


@CCEConditionObjectNewNoArgsStatic{cce,error}


@CCEConditionObjectPredicate{cce,error}

@c ------------------------------------------------------------------------

@CCEConditionSubtypingFacilitiesNoArgs{cce,error}

@c ------------------------------------------------------------------------

@ConditionSubtypingExample{error, error}

@c page
@node conditions runtime error
@section The @emph{runtime error} exceptional--condition object


@ExceptionalConditionIndexEntries{runtime error}


The @dfn{runtime error} exceptional--condition object--type has the purpose of describing an
exceptional condition caused by a runtime error; these are mostly synchronisation errors like
failures to open a file or allocate memory.

There should be only one @emph{runtime error} exceptional--condition object: the one predefined by
@value{PACKAGE} and built into the library as statically allocated structure.  Subtyping from this
object--type is fine.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@CCEDescriptorTypedef{cce,runtime_error,cce_descriptor_error_t}


@deftp {Struct Typedef} cce_condition_runtime_error_t
@deftpx {Struct Typedef} {cclib_exceptional_condition_object_type(cce_runtime_error)}
Structure type representing a @emph{runtime error} exceptional--condition object.  It has the
following public fields:

@table @code
@item cce_condition_error_t error
Core values of the exceptional--condition object.
@end table
@end deftp


@CCEConditionObjectNewNoArgsStatic{cce,runtime_error}


@CCEConditionObjectPredicate{cce,runtime_error}

@c ------------------------------------------------------------------------

@CCEConditionSubtypingFacilitiesNoArgs{cce,runtime_error}

@c ------------------------------------------------------------------------

@ConditionSubtypingExample{runtime-error, runtime_error}

@c page
@node conditions logic error
@section The @emph{logic error} exceptional--condition object


@ExceptionalConditionIndexEntries{logic error}


The @dfn{logic error} exceptional--condition object--type has the purpose of describing an
exceptional condition caused by a logic error; these are mostly synchronisation errors like failures
to open a file or allocate memory.

There should be only one @emph{logic error} exceptional--condition object: the one predefined by
@value{PACKAGE} and built into the library as statically allocated structure.  Subtyping from this
object--type is fine.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@CCEDescriptorTypedef{cce,logic_error,cce_descriptor_error_t}


@deftp {Struct Typedef} cce_condition_logic_error_t
@deftpx {Struct Typedef} {cclib_exceptional_condition_object_type(cce_logic_error)}
Structure type representing a @emph{logic error} exceptional--condition object.  It has the
following public fields:

@table @code
@item cce_condition_error_t error
Core values of the exceptional--condition object.
@end table
@end deftp


@CCEConditionObjectNewNoArgsStatic{cce,logic_error}


@CCEConditionObjectPredicate{cce,logic_error}

@c ------------------------------------------------------------------------

@CCEConditionSubtypingFacilitiesNoArgs{cce,logic_error}

@c ------------------------------------------------------------------------

@ConditionSubtypingExample{logic-error, logic_error}

@c page
@node conditions unimplemented
@section The @emph{unimplemented} exceptional--condition object


@ExceptionalConditionIndexEntries{unimplemented}


The @dfn{unimplemented} exceptional--condition object--type has the purpose of describing an
exceptional condition caused by attempting to use an unimplemented feature.  For example: attempting
to call a system function adapter for which the underlying function is not available on the current
platform.

There should be only one @emph{unimplemented} exceptional--condition object: the one predefined by
@value{PACKAGE} and built into the library as statically allocated structure.  Subtyping from this
object--type is fine.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@CCEDescriptorTypedef{cce,unimplemented,cce_descriptor_logic_error_t}


@deftp {Struct Typedef} cce_condition_unimplemented_t
@deftpx {Struct Typedef} {cclib_exceptional_condition_object_type(cce_unimplemented)}
Structure type representing the exceptional--condition object.  It has the following public fields:

@table @code
@item cce_condition_logic_error_t logic_error
Core values of the exceptional--condition object.
@end table
@end deftp


@CCEConditionObjectNewNoArgsStatic{cce,unimplemented}


@CCEConditionObjectPredicate{cce,unimplemented}

@c ------------------------------------------------------------------------

@CCEConditionSubtypingFacilitiesNoArgs{cce,unimplemented}

@c ------------------------------------------------------------------------

@ConditionSubtypingExample{unimplemented, unimplemented}

@c page
@node conditions invalid arg
@section The @emph{invalid argument} exceptional--condition object


@ExceptionalConditionIndexEntries{invalid argument}


The @dfn{invalid argument} exceptional--condition object--type has the purpose of describing an
exceptional condition caused by a wrong function argument.  This condition object is meant to be
used to describe unexpected exceptions: we do not really expect the argument to be invalid, but we
want a fall--back just in case.

The function is meant to be used as follows:

@example
void
do_something (cce_destination_t L, unsigned N)
@{
  cce_check_argument(L, (0 == N), 1);

  /* do something with N */
@}
@end example

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@CCEDescriptorTypedef{cce,invalid_argument,cce_descriptor_logic_error_t}


@deftp {Struct Typedef} cce_condition_invalid_argument_t
@deftpx {Struct Typedef} {cclib_exceptional_condition_object_type(cce_invalid_argument)}
Structure type representing the exceptional--condition object.  It has the following public fields:

@table @code
@item cce_condition_logic_error_t logic_error
Core values of the exceptional--condition object.

@item char const * funcname
Pointer to a statically allocated @asciiz{} string representing the name of the function that raised
the exception.  It is usually generated with the preprocessor symbol @code{__func__}.

@item unsigned index
One--based index of the offending argument.
@end table
@end deftp


@CCEConditionObjectNew{cce,invalid_argument,{char const * @var{func}, unsigned @var{index}}}


@deftypefn {Preprocessor Macro} void cce_check_argument (cce_destination_t @var{L}, bool @var{EXPR}, unsigned @var{ARGNUM})
Expand to the following:

@example
if (! (@var{EXPR})) @{
  cce_raise((@var{L}),
    cce_condition_new_invalid_argument((@var{L}), __func__, (@var{ARGNUM})));
@}
@end example

@noindent
where @var{EXPR} is an expression evaluating to @ctrue{} if the argument is @strong{valid}.
@end deftypefn


@CCEConditionObjectPredicate{cce,invalid_argument}

@c ------------------------------------------------------------------------

@CCEConditionSubtypingFacilities{cce,invalid_argument,{char const * @var{func}, unsigned @var{index}}}

@c ------------------------------------------------------------------------

@ConditionSubtypingExample{invalid-arg, invalid_argument}

@c page
@node conditions unreachable
@section The @emph{unreachable code} exceptional--condition object


@ExceptionalConditionIndexEntries{unreachable code}


We can use the @dfn{unreachable code} exceptional--condition object--type to signal the execution of
unreachable code.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@CCEDescriptorTypedef{cce,unreachable,cce_descriptor_logic_error_t}


@deftp {Struct Typedef} cce_condition_unreachable_t
@deftpx {Struct Typedef} {cclib_exceptional_condition_object_type(cce_unreachable)}
Structure type representing the @emph{unreachable code} exceptional--condition object.  It has the
following public fields:

@table @code
@item cce_condition_logic_error_t logic_error
Core values of the exceptional--condition object--type descriptor.

@item char const * filename
Pointer to a statically allocated @asciiz{} string representing the pathname of the source file in
which the unreachable code is located.  This value is meant to be generated with the preprocessor
macro @code{__FILE__}.

@item char const * funcname
Pointer to a statically allocated @asciiz{} string representing the name of the function in which
the unreachable code is located.  This value is meant to be generated with the preprocessor macro
@code{__func__}.

@item int linenum
The line number in the source file in which the unreachable code is located.  This value is meant to
be generated with the preprocessor macro @code{__LINE__}.
@end table
@end deftp


@CCEConditionObjectNew{cce,unreachable,{char const * @var{filename}, char const * @var{funcname}, int @var{linenum}}}


@deftypefn {Preprocessor Macro} void cce_raise_unreachable (cce_destination_t @var{L})
@cindex @code{CCEXCEPTIONS_EXCLUDE_UNREACHABLE}, preprocessor symbol
@cindex Preprocessor symbol @code{CCEXCEPTIONS_EXCLUDE_UNREACHABLE}
If the preprocessor symbol @code{CCEXCEPTIONS_EXCLUDE_UNREACHABLE} @strong{is not} defined: raise an
exceptional condition of type @objtype{cce_condition_unreachable_t} by expanding into:

@example
cce_raise((L),
  cce_condition_new_unreachable((L),
    __FILE__, __func__, __LINE__));
@end example

If the preprocessor symbol @code{CCEXCEPTIONS_EXCLUDE_UNREACHABLE} @strong{is} defined: expand to
nothing.  By default @code{CCEXCEPTIONS_EXCLUDE_UNREACHABLE} is not defined.
@end deftypefn


@CCEConditionObjectPredicate{cce,unreachable}

@c ------------------------------------------------------------------------

@CCEConditionSubtypingFacilities{cce,unreachable,{char const * @var{filename}, char const * @var{funcname}, int @var{linenum}}}

@c ------------------------------------------------------------------------

@ConditionSubtypingExample{unreachable, unreachable}

@c page
@node conditions errno
@section The @code{errno} exceptional--condition object


@ExceptionalConditionIndexEntries{@code{errno}}


The @code{errno} exceptional--condition object--type has the purpose of describing an exceptional
condition caused by a system function setting @code{errno}.  This exceptional--condition
object--type is @strong{not} meant to be subtyped.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@CCEDescriptorTypedef{cce,errno,cce_descriptor_runtime_error_t}


@deftp {Struct Typedef} cce_condition_errno_t
@deftpx {Struct Typedef} {cclib_exceptional_condition_object_type(cce_errno)}
Structure type representing an @emph{errno} exceptional--condition object, signalled by a system
function by setting @code{errno} to a non--zero value.  It has the following public fields:

@table @code
@item cce_condition_runtime_error_t runtime_error
Core values of the exceptional--condition object--type descriptor.

@item int errnum
The value of @code{errno}.

@item char const * message
A statically allocated @asciiz{} string describing the error.
@end table
@end deftp


@deftypefun {cce_condition_t const *} cce_condition_new_errno (int @var{errnum})
@deftypefunx {cce_condition_t const *} {cclib_new(cclib_exceptional_condition_object_type(cce_errno))} (int @var{errnum})
Given the @code{errno} code @var{errnum}, return a pointer to the exceptional--condition object
associated to it.

If @var{errnum} is zero: return a pointer to an exceptional--condition object representing a
successful operation.  If @var{errnum} is not a valid @code{errno} code for the underlying platform:
return a pointer to an exceptional--condition object representing an invalid code.
@end deftypefun


@deftypefun {cce_condition_t const *} cce_condition_new_errno_clear (void)
@deftypefunx {cce_condition_t const *} {cclib_new(cclib_exceptional_condition_object_type(cce_errno), clear)} (void)
Consume the current value of @code{errno} and return the return value of
@cfunc{cce_condition_new_errno} applied to it.  Before returning: @code{errno} is reset to zero.
@end deftypefun


@CCEConditionObjectPredicate{cce,errno}


@deftypefun bool cce_condition_is_errno_with_code (cce_condition_t const * @var{C}, int @var{errnum})
@deftypefunx bool {cclib_is(cclib_exceptional_condition_object_type(cce_errno), with_code)} (cce_condition_t const * @var{C}, int @var{errnum})
Return @code{true} if the exceptional--condition object referenced by @var{C} is of type
@CCEConditionObjectTypeCode{cce,errno}, or it is derived from it, and its error code equals
@var{errnum}; otherwise return @code{false}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Structure field getters


@deftypefun int cce_condition_ref_errno_errnum (cce_condition_t const * @var{C})
Return the value of the field @code{errnum} in the exceptional--condition object referenced by
@var{C}, which must be of type @objtype{cce_condition_errno_t}
@end deftypefun


@deftypefun {char const *} cce_condition_ref_errno_message (cce_condition_t const * @var{C})
Return the value of the field @code{message} in the exceptional--condition object referenced by
@var{C}, which must be of type @objtype{cce_condition_errno_t}
@end deftypefun

@c ------------------------------------------------------------------------

@CCEConditionSubtypingFacilities{cce,errno,{int @var{errum}}}


@deftypefun void cce_condition_init_errno_clear (cce_condition_errno_t * @var{C})
@deftypefunx void {cclib_init(cclib_exceptional_condition_object_type(cce_errno), clear)} (cce_condition_errno_t * @var{C})
Like @cfunc{cce_condition_init_errno}, but consume the current value of @code{errno}.  Before
returning: @code{errno} is reset to zero.
@end deftypefun

@c ------------------------------------------------------------------------

@ConditionSubtypingExample{errno, errno}

@c page
@node conditions math
@section Predefined mathematical conditions


@menu
* conditions math error::       Error computing a mathematical expression.
* conditions math nan::         Mathematical not-a-number error.
* conditions math infinity::    Mathematical infinity error.
* conditions math overflow::    Mathematical overflow error.
* conditions math underflow::   Mathematical underflow error.
@end menu

@c page
@node conditions math error
@subsection Error computing a mathematical expression


@ExceptionalConditionIndexEntries{mathematical error}


The @dfn{mathematical error} exceptional--condition object--type has the purpose of describing an
exceptional condition caused by attempting to compute an invalid mathematical expression.

There should be only one @emph{mathematical error} exceptional--condition object: the one predefined
by @value{PACKAGE} and built into the library as statically allocated structure.  Subtyping from
this object--type is fine.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@CCEDescriptorTypedef{cce,math_error,cce_descriptor_runtime_error_t}


@deftp {Struct Typedef} cce_condition_math_error_t
@deftpx {Struct Typedef} {cclib_exceptional_condition_object_type(cce_math_error)}
Structure type representing a @emph{mathematical error} exceptional--condition object.  It has the
following public fields:

@table @code
@item cce_condition_runtime_error_t runtime_error
Core values of the exceptional--condition object--type descriptor.
@end table
@end deftp


@CCEConditionObjectNewNoArgsStatic{cce,math_error}


@CCEConditionObjectPredicate{cce,math_error}

@c ------------------------------------------------------------------------

@CCEConditionSubtypingFacilitiesNoArgs{cce,math_error}

@c ------------------------------------------------------------------------

@ConditionSubtypingExample{math-error, math_error}

@c page
@node conditions math nan
@subsection Mathematical not--a--number error


@ExceptionalConditionIndexEntries{mathematical not-a-number error}
@ExceptionalConditionIndexEntries{not-a-number error}


The @dfn{mathematical not--a--number} exceptional--condition object--type has the purpose of
describing an exceptional condition caused by a not--a--number result while computing a mathematical
expression.

There should be only one @emph{mathematical not--a--number} exceptional--condition object: the one
predefined by @value{PACKAGE} and built into the library as statically allocated structure.
Subtyping from this object--type is fine.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@CCEDescriptorTypedef{cce,math_nan,cce_descriptor_runtime_error_t}


@deftp {Struct Typedef} cce_condition_math_nan_t
@deftpx {Struct Typedef} {cclib_exceptional_condition_object_type(cce_math_nan)}
Structure type representing a @emph{mathematical not--a--number} exceptional--condition object.  It
has the following public fields:

@table @code
@item cce_condition_math_error_t math_error
Core values of the exceptional--condition object--type descriptor.
@end table
@end deftp


@CCEConditionObjectNewNoArgsStatic{cce,math_nan}


@CCEConditionObjectPredicate{cce,math_nan}

@c ------------------------------------------------------------------------

@CCEConditionSubtypingFacilitiesNoArgs{cce,math_nan}

@c ------------------------------------------------------------------------

@ConditionSubtypingExample{math-nan, math_nan}

@c page
@node conditions math infinity
@subsection Mathematical infinity error


@ExceptionalConditionIndexEntries{mathematical infinity error}
@ExceptionalConditionIndexEntries{infinity error}


The @dfn{mathematical infinity} exceptional--condition object--type has the purpose of describing an
exceptional condition caused by an infinite result while computing a mathematical expression.

There should be only one @emph{mathematical infinity} exceptional--condition object: the one
predefined by @value{PACKAGE} and built into the library as statically allocated structure.
Subtyping from this object--type is fine.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@CCEDescriptorTypedef{cce,math_infinity,cce_descriptor_runtime_error_t}


@deftp {Struct Typedef} cce_condition_math_infinity_t
@deftpx {Struct Typedef} {cclib_exceptional_condition_object_type(cce_math_infinity)}
Structure type representing a @emph{mathematical infinity} exceptional--condition object.  It has
the following public fields:

@table @code
@item cce_condition_math_error_t math_error
Core values of the exceptional--condition object--type descriptor.
@end table
@end deftp


@CCEConditionObjectNewNoArgsStatic{cce,math_infinity}


@CCEConditionObjectPredicate{cce,math_infinity}

@c ------------------------------------------------------------------------

@CCEConditionSubtypingFacilitiesNoArgs{cce,math_infinity}

@c ------------------------------------------------------------------------

@ConditionSubtypingExample{math-infinity, math_infinity}

@c page
@node conditions math overflow
@subsection Mathematical overflow error


@ExceptionalConditionIndexEntries{mathematical overflow error}
@ExceptionalConditionIndexEntries{overflow error}


The @dfn{mathematical overflow} exceptional--condition object--type has the purpose of describing an
exceptional condition caused by an overflow while computing a mathematical expression.

There should be only one @emph{mathematical overflow} exceptional--condition object: the one
predefined by @value{PACKAGE} and built into the library as statically allocated structure.
Subtyping from this object--type is fine.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@CCEDescriptorTypedef{cce,math_overflow,cce_descriptor_runtime_error_t}


@deftp {Struct Typedef} cce_condition_math_overflow_t
@deftpx {Struct Typedef} {cclib_exceptional_condition_object_type(cce_math_overflow)}
Structure type representing a @emph{mathematical overflow} exceptional--condition object.  It has
the following public fields:

@table @code
@item cce_condition_math_error_t math_error
Core values of the exceptional--condition object--type descriptor.
@end table
@end deftp


@CCEConditionObjectNewNoArgsStatic{cce,math_overflow}


@CCEConditionObjectPredicate{cce,math_overflow}

@c ------------------------------------------------------------------------

@CCEConditionSubtypingFacilitiesNoArgs{cce,math_overflow}

@c ------------------------------------------------------------------------

@ConditionSubtypingExample{math-overflow, math_overflow}

@c page
@node conditions math underflow
@subsection Mathematical underflow error


@ExceptionalConditionIndexEntries{mathematical underflow error}
@ExceptionalConditionIndexEntries{underflow error}


The @dfn{mathematical underflow} exceptional--condition object--type has the purpose of describing an
exceptional condition caused by an underflow while computing a mathematical expression.

There should be only one @emph{mathematical underflow} exceptional--condition object: the one
predefined by @value{PACKAGE} and built into the library as statically allocated structure.
Subtyping from this object--type is fine.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@CCEDescriptorTypedef{cce,math_underflow,cce_descriptor_runtime_error_t}


@deftp {Struct Typedef} cce_condition_math_underflow_t
@deftpx {Struct Typedef} {cclib_exceptional_condition_object_type(cce_math_underflow)}
Structure type representing a @emph{mathematical underflow} exceptional--condition object.  It has
the following public fields:

@table @code
@item cce_condition_math_error_t math_error
Core values of the exceptional--condition object--type descriptor.
@end table
@end deftp


@CCEConditionObjectNewNoArgsStatic{cce,math_underflow}


@CCEConditionObjectPredicate{cce,math_underflow}

@c ------------------------------------------------------------------------

@CCEConditionSubtypingFacilitiesNoArgs{cce,math_underflow}

@c ------------------------------------------------------------------------

@ConditionSubtypingExample{math-underflow, math_underflow}

@c page
@node conditions custom
@section Defining custom condition objects


The source distribution of @value{PACKAGE} comes with coding examples under the @file{examples}
directory of the source tree; we can take that code and use it as a starting point.

@menu
* conditions custom plain::     Plain exceptional-condition objects.
@end menu

@c page
@node conditions custom plain
@subsection Plain exceptional-condition objects


@include condition-example-plain.texi

@c page
@node system
@chapter System call adapters


@value{PACKAGE} defines function wrappers for some basic @posix{} system calls.  Each wrapper
accepts a pointer to @objtype{cce_location_t} as argument and, in case of error, it will perform a
non--local exit by jumping to the selected location.

The wrapper functions accept the same arguments of the system calls and return the same return value
of the system calls (if they complete successfully).

All the wrappers reset @code{errno} to zero before performing the system call and reset it to zero
before returning.  In case of error: the raised exceptional condition objects are of type
@objtype{cce_condition_errno_t}.

@menu
* system memory::               Memory allocation.
@end menu

@c page
@node system memory
@section Memory allocation


@menu
* system memory core::          Core memory allocation functions.
* system memory handlers::      Handlers for allocated memory.
* system memory gmalloc::       Guarded allocation: @cfunc{malloc}.
* system memory gcalloc::       Guarded allocation: @cfunc{calloc}.
* system memory grealloc::      Guarded allocation: @cfunc{realloc}.
@end menu

@c page
@node system memory core
@subsection Core memory allocation functions


The following symbols are defined in the header file @file{ccexceptions.h}.


@deftypefun {void *} cce_sys_malloc (cce_destination_t @var{L}, size_t @var{size})
Wrapper for @cfunc{malloc}.  This function never returns @cnull{}.
@end deftypefun


@deftypefun {void *} cce_sys_realloc (cce_destination_t @var{L}, void * @var{old_P}, size_t @var{newsize})
Wrapper for @cfunc{realloc}.  This function never returns @cnull{}.
@end deftypefun


@deftypefun {void *} cce_sys_calloc (cce_destination_t @var{L}, size_t @var{count}, size_t @var{eltsize})
Wrapper for @cfunc{calloc}.  This function never returns @cnull{}.
@end deftypefun

@c page
@node system memory handlers
@subsection Handlers for allocated memory


We can handle memory that must be released with the standard function @cfunc{free} as follows:

@example
cce_location_t       L[1];
cce_clean_handler_t  P_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  void *        P = cce_sys_malloc(L, 4096);
  cce_init_and_register_handler_malloc(L, P_H, P);
  cce_run_body_handlers(L);
@}
@end example


@deftypefun void cce_init_and_register_clean_handler_malloc (cce_destination_t @var{L}, cce_clean_handler_t * @var{H}, void * @var{P})
Register @var{H} as handler in the context of @var{L}.  The handler function will release the memory
block referenced by @var{P} using the standard function @cfunc{free}.
@end deftypefun


@deftypefun void cce_init_and_register_error_handler_malloc (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, void * @var{P})
Register @var{H} as handler in the context of @var{L}.  The handler function will release the memory
block referenced by @var{P} using the standard function @cfunc{free}.
@end deftypefun


@deftypefn {Preprocessor Macro} void cce_init_and_register_handler_malloc (cce_destination_t @var{L}, cce_clean_handler_t * @var{P_H}, void * @var{P})
@deftypefnx {Preprocessor Macro} void cce_init_and_register_handler_malloc (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, void * @var{P})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{P_H}; if the type is:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{cce_init_and_register_clean_handler_malloc}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{cce_init_and_register_error_handler_malloc}.
@end table
@end deftypefn

@c page
@node system memory gmalloc
@subsection Guarded allocation: @cfunc{malloc}


To allocate memory using a clean handler with a guarded function, we can do:

@example
cce_location_t          L[1];
cce_clean_handler_t     P_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  void *  P = cce_sys_malloc_guarded(L, P_H, 1024);

  /* Do something with P. */
  cce_run_body_handlers(L);
@}
@end example

@noindent
while to use an error handler we can do:

@example
cce_location_t          L[1];
cce_error_handler_t     P_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  void *  P = cce_sys_malloc_guarded(L, P_H, 1024);

  /* Do something with P. */
  cce_run_body_handlers(L);
@}
@end example


@deftypefun {void *} cce_sys_malloc_guarded_clean (cce_destination_t @var{L}, cce_clean_handler_t * @var{P_H}, size_t @var{size})
@deftypefunx {void *} cce_sys_malloc_guarded_error (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, size_t @var{size})
Like @cfunc{cce_sys_malloc}, but register the resulting pointer in the handler referenced by
@var{P_H}.
@end deftypefun


@deftypefn {Preprocessor Macro} {void *} cce_sys_malloc_guarded (cce_destination_t @var{L}, cce_clean_handler_t * @var{P_H}, size_t @var{size})
@deftypefnx {Preprocessor Macro} {void *} cce_sys_malloc_guarded (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, size_t @var{size})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{P_H}; if the type is:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{cce_sys_malloc_guarded_clean}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{cce_sys_malloc_guarded_error}.
@end table
@end deftypefn

@c page
@node system memory gcalloc
@subsection Guarded allocation: @cfunc{calloc}


To allocate memory using a clean handler with a guarded function, we can do:

@example
cce_location_t          L[1];
cce_clean_handler_t     P_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  void *  P = cce_sys_calloc_guarded(L, P_H, 4, 1024);

  /* Do something with P. */
  cce_run_body_handlers(L);
@}
@end example

@noindent
while to use an error handler we can do:

@example
cce_location_t          L[1];
cce_error_handler_t     P_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  void *  P = cce_sys_calloc_guarded(L, P_H, 4, 1024);

  /* Do something with P. */
  cce_run_body_handlers(L);
@}
@end example


@deftypefun {void *} cce_sys_calloc_guarded_clean (cce_destination_t @var{L}, cce_clean_handler_t * @var{P_H}, size_t @var{count}, size_t @var{eltsize})
@deftypefunx {void *} cce_sys_calloc_guarded_error (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, size_t @var{count}, size_t @var{eltsize})
Like @cfunc{cce_sys_calloc}, but register the resulting pointer in the handler referenced by
@var{P_H}.
@end deftypefun


@deftypefn {Preprocessor Macro} {void *} cce_sys_calloc_guarded (cce_destination_t @var{L}, cce_clean_handler_t * @var{P_H}, size_t @var{count}, size_t @var{eltsize})
@deftypefnx {Preprocessor Macro} {void *} cce_sys_calloc_guarded (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, size_t @var{count}, size_t @var{eltsize})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{P_H}; if the type is:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{cce_sys_calloc_guarded_clean}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{cce_sys_calloc_guarded_error}.
@end table
@end deftypefn

@c page
@node system memory grealloc
@subsection Guarded allocation: @cfunc{realloc}


To allocate and reallocate memory using a clean handler with a guarded function, we can do:

@example
cce_location_t          L[1];
cce_clean_handler_t     P_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  void *  P = cce_sys_calloc_guarded(L, P_H, 4, 1024);

  P = cce_sys_realloc_guarded(L, P_H, P, 16 * 1024);

  /* Do something with P. */
  cce_run_body_handlers(L);
@}
@end example

@noindent
while to use an error handler we can do:

@example
cce_location_t          L[1];
cce_error_handler_t     P_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  void *  P = cce_sys_calloc_guarded(L, P_H, 4, 1024);

  P = cce_sys_realloc_guarded(L, P_H, P, 16 * 1024);

  /* Do something with P. */
  cce_run_body_handlers(L);
@}
@end example


@deftypefun {void *} cce_sys_realloc_guarded_clean (cce_destination_t @var{L}, cce_clean_handler_t * @var{P_H}, void * @var{old_P}, size_t @var{newsize})
@deftypefunx {void *} cce_sys_realloc_guarded_error (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, void * @var{old_P}, size_t @var{newsize})
Like @cfunc{cce_sys_realloc}, but register the resulting pointer in the handler referenced by
@var{P_H}.  The handler is updated to reference the new memory pointer.  If, upon entering this
function, the handler @var{P_H} does not reference the pointer @var{old_P}: raise an exception by
performing a non--local exit to @var{L}, with condition object of type
@objtype{cce_condition_invalid_argument_t}.
@end deftypefun


@deftypefn {Preprocessor Macro} {void *} cce_sys_realloc_guarded (cce_destination_t @var{L}, cce_clean_handler_t * @var{P_H}, void * @var{old_P}, size_t @var{newsize})
@deftypefnx {Preprocessor Macro} {void *} cce_sys_realloc_guarded (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, void * @var{old_P}, size_t @var{newsize})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{P_H}; if the type is:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{cce_sys_realloc_guarded_clean}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{cce_sys_realloc_guarded_error}.
@end table
@end deftypefn

@c page
@node tracing
@chapter Printing execution traces


When code using @value{PACKAGE} is compiled with the preprocessor macro @code{CCEXCEPTIONS_TRACE}
defined before including @file{ccexceptions.h}: some tracing features are enabled.  It means debug
messages are printed on @code{stderr} following the execution path of raised exceptions representing
errors.  The affected functions and macros are:

@example
cce_location
cce_raise
cce_run_catch_handlers_raise
cce_run_catch_handlers_final
cce_run_body_handlers_raise
cce_run_body_handlers_final
@end example

Tracing features are completely transparent to the client code: we must do nothing different when
tracing is enabled.

As example, when the following code is run:

@example
#define CCEXCEPTIONS_TRACE      1
#include <ccexceptions.h>
#include <stdio.h>
#include <stdlib.h>

void
test_tracing_sub_sub_sub (cce_destination_t upper_L)
@{
  cce_location_t        L[1];

  if (cce_location(L)) @{
    cce_run_catch_handlers_raise(L, upper_L);
  @} else @{
    cce_raise(L, cce_condition_new_unknown());
    cce_run_body_handlers(L);
  @}
@}

void
test_tracing_sub_sub (cce_destination_t upper_L)
@{
  cce_location_t        L[1];

  if (cce_location(L)) @{
    cce_run_catch_handlers_raise(L, upper_L);
  @} else @{
    test_tracing_sub_sub_sub(L);
    cce_run_body_handlers(L);
  @}
@}

void
test_tracing_sub (cce_destination_t upper_L)
@{
  cce_location_t        L[1];

  if (cce_location(L)) @{
    cce_run_catch_handlers_raise(L, upper_L);
  @} else @{
    test_tracing_sub_sub(L);
    cce_run_body_handlers(L);
  @}
@}

void
test_tracing (void)
@{
  cce_location_t        L[1];

  if (cce_location(L)) @{
    cce_run_catch_handlers_final(L);
  @} else @{
    test_tracing_sub(L);
    cce_run_body_handlers(L);
  @}
@}

int
main (void)
@{
  test_tracing();
@}
@end example

@noindent
it prints:

@smallexample
raising:    ../tests/tracing.c:48, test_tracing_sub_sub_sub(): Unknown exceptional condition
catching:   ../tests/tracing.c:45, test_tracing_sub_sub_sub(): Unknown exceptional condition
re-raising: ../tests/tracing.c:46, test_tracing_sub_sub_sub(): Unknown exceptional condition
catching:   ../tests/tracing.c:58, test_tracing_sub_sub(): Unknown exceptional condition
re-raising: ../tests/tracing.c:59, test_tracing_sub_sub(): Unknown exceptional condition
catching:   ../tests/tracing.c:71, test_tracing_sub(): Unknown exceptional condition
re-raising: ../tests/tracing.c:72, test_tracing_sub(): Unknown exceptional condition
catching:   ../tests/tracing.c:84, test_tracing(): Unknown exceptional condition
finalising: ../tests/tracing.c:85, test_tracing(): Unknown exceptional condition
@end smallexample

@c page
@node cclibraries
@appendix The header file @file{cclibraries.h}


The header file @file{cclibraries.h} is meant to be included in the source files of all the
CCLibraries projects; it is included by @file{ccexceptions.h}; it is distributed with the
@value{PACKAGE} project because @value{PACKAGE} implements core facilities for all the CCLibraries
packages.

The header file @file{cclibraries.h} is meant to support the C11 language standard on @posix{}
platforms.  All the macro definitions are prefixed with @code{CCLIB_} or @code{cclib_}; all the type
names are prefixed with @code{cclib_} and suffixed with @code{_t}.

@menu
* cclibraries requisites::      Requirements.
* cclibraries attributes::      Compiler attributes for functions.
* cclibraries declarations::    Functions and variables visibility declarations.
* cclibraries macros::          Helper macros.
* cclibraries typedefs::        Common type definitions and related macros.
* cclibraries variadic::        Variadic preprocessor macros.
* cclibraries structs::         Defining data structure handling @api{}.
* cclibraries exceptions::      Exception handling helpers.
* cclibraries conditions::      Exceptional-condition objects.
@end menu

@c page
@node cclibraries requisites
@appendixsec Requirements


The header file @file{cclibraries.h} expects to be compiled in an environment set up by @gnu{}
Autoconf; there must be a project--specific @file{config.h} file that @file{cclibraries.h} will
include as:

@example
#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif
@end example

@noindent
and the template configuration script @file{configure.ac} must call the macro:

@example
CCLIB_CONFIG_SETUP()
@end example

@noindent
so the package distribution must include all the requires Autoconf macro files and load them
correctly.

@c page
@node cclibraries attributes
@appendixsec Compiler attributes for functions


The following definitions are in the header file @file{cclibraries.h}.  The header file tries to
determine, through the C preprocessor macros, which function attributes are implemented by the
compiler and defines the following macros accordingly.  If an attribute is not implemented: the
corresponding macro is defined to expand to the empty string.

A typical function prototype declaration for a function using the facilities of @value{PACKAGE}
looks like this:

@example
cclib_decl void * cce_sys_malloc (cce_destination_t L, size_t size)
  CCLIB_FUNC_ATTRIBUTE_NONNULL(1)
  CCLIB_FUNC_ATTRIBUTE_RETURNS_NONNULL
  CCLIB_FUNC_ATTRIBUTE_LEAF;
@end example

@noindent
while a @code{static} and @code{inline} function definition looks like this:

@example
CCLIB_FUNC_ATTRIBUTE_ALWAYS_INLINE
CCLIB_FUNC_ATTRIBUTE_PURE
CCLIB_FUNC_ATTRIBUTE_NONNULL(1)
CCLIB_FUNC_ATTRIBUTE_RETURNS_NONNULL
static inline cce_handler_t *
cce_clean_handler_handler (cce_clean_handler_t * const H)
@{
  ...
@}
@end example


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_ALWAYS_INLINE
Expand into:

@example
__attribute__((__always_inline__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_CONST
Expand into:

@example
__attribute__((__const__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_CONSTRUCTOR
Expand into:

@example
__attribute__((__constructor__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_DLLEXPORT
Expand into:

@example
__attribute__((__dllexport__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_DLLIMPORT
Expand into:

@example
__attribute__((__dllimport__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_FORMAT (...)
Expand into:

@example
__attribute__((__format__(__VA_ARGS__)))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_HOT
Expand into:

@example
__attribute__((__hot__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_LEAF
Expand into:

@example
__attribute__((__leaf__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_NONNULL (...)
Expand into:

@example
__attribute__((__nonnull__(__VA_ARGS__)))
@end example

We can use this macro as follows:

@example
cclib_decl void my_func (int * dst, int * src)
  CCLIB_FUNC_ATTRIBUTE_NONNULL(1,2);
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_NORETURN
Expand into:

@example
__attribute__((__noreturn__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_PURE
Expand into:

@example
__attribute__((__pure__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_RETURNS_NONNULL
Expand into:

@example
__attribute__((__returns_nonnull__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_UNUSED
Expand into:

@example
__attribute__((__unused__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_USED
Expand into:

@example
__attribute__((__used__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_VISIBILITY (...)
Expand into:

@example
__attribute__((__visibility__(__VA_ARGS__)))
@end example
@end deffn

@c page
@node cclibraries declarations
@appendixsec Functions and variables visibility declarations


The following definitions are in the header file @file{cclibraries.h}.


@deffn {Preprocessor Macro} cclib_decl
Expand into the qualifiers for a public @api{} declaration.  When using the @gnu{} C Compiler on a
@posix{} system, it should expand into:

@example
CCLIB_FUNC_ATTRIBUTE_VISIBILITY("default") extern
@end example
@end deffn


@deffn {Preprocessor Macro} cclib_private_decl
Expand into the qualifiers for a private @api{} declaration: entities qualified with this macro are
meant to be visible only inside the namespace of a shared library.  When using the @gnu{} C Compiler
on a @posix{} system, it should expand into:

@example
CCLIB_FUNC_ATTRIBUTE_VISIBILITY("hidden")  extern
@end example
@end deffn

@c page
@node cclibraries macros
@appendixsec Helper macros


The following definitions are in the header file @file{cclibraries.h}.


@deffn {Preprocessor Macro} CCLIB_CAST (@var{TYPE}, @var{X}, @var{Y})
Type cast helper.  It expands into:

@example
@var{TYPE} @var{X} = (@var{TYPE}) (@var{Y})
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_PC (@var{TYPE}, @var{X}, @var{Y})
Pointer--type cast helper.  It expands into:

@example
@var{TYPE} * @var{X} = (@var{TYPE} *) (@var{Y})
@end example

So, for example, instead of writing:

@example
cce_location_t    L[1];
cce_condition_t * C = cce_condition(L);
ccevents_timeval_invalid_t * K = (ccevents_timeval_invalid_t *) C;
@end example

@noindent
we can write:

@example
cce_location_t    L[1];
cce_condition_t * C = cce_condition(L);
CCLIB_PC(ccevents_timeval_invalid_t, K, C);
@end example

@noindent
or:

@example
cce_location_t    L[1];
CCLIB_PC(ccevents_timeval_invalid_t, C, cce_condition(L));
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_UNUSED
Preprocessor macro that is meant to expand into an attribute declaration.  It expands into:

@example
CCLIB_FUNC_ATTRIBUTE_UNUSED
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_STRUCT_TYPEDEF (@var{STRUCT})
Preprocessor macro that expands into a data structure typedef:

@example
typedef struct @var{STRUCT}      @var{STRUCT}
@end example
@end deffn

@c page
@node cclibraries typedefs
@appendixsec Common type definitions and related macros


@menu
* cclibraries typedefs opaque:: Opaque data structures handling.
@end menu

@c page
@node cclibraries typedefs opaque
@appendixsubsec Opaque data structures handling


@anchor{cclib_resource_data_t}
@deftp {Opaque Typedef} cclib_resource_data_t
An alias for @code{void}.
@end deftp


@anchor{cclib_resource_pointer_t}
@deftp {Pointer Typedef} cclib_resource_pointer_t
An alias for @code{cclib_resource_data_t *} we can use to document a pointer to an unspecified data
structure.  It is used, for example, by CCExceptions to reference a resource that must be released
by an exception handler.
@end deftp


@anchor{cclib_resource_pointer}
@deftypefn {Preprocessor Macro} cclib_resource_pointer_t cclib_resource_pointer (void * @var{expr})
Cast to @objtype{cclib_resource_pointer_t} the result of evaluating the expression @var{expr}.
@end deftypefn

@c page
@node cclibraries variadic
@appendixsec Variadic preprocessor macros


The following definitions are in the header file @file{cclibraries.h}.  The variadic macros
machinery implemented in the header file is derived from code found on Stack Overflow (@aurl{} last
accessed Apr 1, 2020):

@center @url{https://stackoverflow.com/a/26408195}

The machinery is composed of a number of preprocessor macros, of which only @cfunc{CCLIB_VNAME} is
public.


@deffn {Preprocessor Macro} CCLIB_VNAME (@var{FUNC}, @var{ARG}, ...)
Expand into the name of a C language function or preprocessor macro; the name has @var{FUNC} as
prefix and @code{_0}, @code{_1}, @code{_2}, @dots{} as suffix, depending on how many arguments are
in the macro use after the mandatory @var{FUNC}.  We can use up to 63 arguments, generating names
with suffix from @code{_1} to @code{_63}.

@strong{NOTE} It is @strong{mandatory} to use at least one argument after @var{FUNC}: @var{ARG} is
not optional!
@end deffn


We can use the machinery in multiple ways.

@c ------------------------------------------------------------------------

@subsubheading Mimicking variadic functions


With the single macro definition:

@example
#define my_one(...)     CCLIB_VNAME(my_one,__VA_ARGS__)
@end example

@noindent
we can obtain the following expansions:

@example
my_one(7)       @expansion{} my_one_1(7)
my_one(8,9)     @expansion{} my_one_1(8,9)
@end example

@noindent
so we can define the functions:

@example
int
my_one_1 (int arg)
@{
  return arg;
@}

int
my_one_2 (int arg1, int arg2)
@{
  return arg1 + arg2;
@}
@end example

@noindent
and call them as:

@example
my_one(7);
my_one(8, 9);
@end example

@c ------------------------------------------------------------------------

@subsubheading Function names composition

With the following macro definitions:

@example
#define my_two_1(A1)            my_two_ ## A1
#define my_two_2(A1,A2)         my_two_ ## A1 ## _ ## A2
#define my_two(...)             CCLIB_VNAME(my_two,__VA_ARGS__)
@end example

@noindent
we can obtain the following partial expansions:

@example
my_two(alpha)           @expansion{} my_two_1(alpha)
my_two(alpha,beta)      @expansion{} my_two_2(alpha,beta)
@end example

@noindent
and then the final expansions:

@example
my_two_1(alpha)         @expansion{} my_two_alpha
my_two_2(alpha,beta)    @expansion{} my_two_alpha_beta
@end example

So we can define the functions:

@example
int
my_two(alpha) (int arg)
@{
  return arg;
@}

int
my_two(alpha,beta) (int arg1, int arg2, int arg3)
@{
  return arg1 + arg2 + arg3;
@}
@end example

@noindent
and call them as:

@example
my_two(alpha)(1);
my_two(alpha,beta)(1,2,4);
@end example

@c page
@node cclibraries structs
@appendixsec Defining data structure handling @api{}


@menu
* cclibraries structs common::  Well known functions for @struct{} types.
* cclibraries structs values::  Data structures as values.
* cclibraries structs descr::   Data structures with descriptor.
* cclibraries structs traits::  Trait data structures.
@end menu

@c page
@node cclibraries structs common
@appendixsubsec Well known functions for @struct{} types


The following preprocessor macros define the ``well known functions @api{} for common data
structures passed by reference'': a set of basic operations on data structures.  Usually we allocate
a data structure on the stack, or embed it into another data structure, or we allocate it on the
heap, then we use a pointer to the structure as argument to functions; this @api{} is for this
scenario.

There is no better way to learn how to use this @api{} than to peruse the distributed and installed
examples, they are the files with stem @code{struct-no-descr}.

All the macros are variadic and accept from zero up to three @var{VARIANT} arguments;
@ref{cclibraries variadic, Variadic preprocessor macros}.


@defmac cclib_init (@var{STRUCT}, @var{VARIANT},  @dots{})
Given a data structure type name @var{STRUCT}, and an optional variant specification: expand into
the name of the @api{} function @cfunc{init}.

Functions with this name are constructors for @struct{} instances allocated on the stack or embedded
into enclosing @struct{} instances.  They allocate all the asynchronous resources and initialise the
@struct{} fields.
@end defmac


@defmac cclib_final (@var{STRUCT}, @var{VARIANT},  @dots{})
Given a data structure type name @var{STRUCT}, and an optional variant specification: expand into
the name of the @api{} function @cfunc{final}.

Functions with this name are destructors for @struct{} instances allocated on the stack or embedded
into enclosing @struct{} instances.  They release all the asynchronous resources associated to the
@struct{} fields.
@end defmac


@defmac cclib_alloc (@var{STRUCT}, @var{VARIANT},  @dots{})
Given a data structure type name @var{STRUCT}, and an optional variant specification: expand into
the name of the @api{} function @cfunc{alloc}.

Functions of this type are memory allocators for @struct{} instances allocated on the heap.
@end defmac


@defmac cclib_release (@var{STRUCT}, @var{VARIANT},  @dots{})
Given a data structure type name @var{STRUCT}, and an optional variant specification: expand into
the name of the @api{} function @cfunc{release}.

Functions of this type are memory releasers for @struct{} instances allocated on the heap.
@end defmac


@defmac cclib_new (@var{STRUCT}, @var{VARIANT},  @dots{})
Given a data structure type name @var{STRUCT}, and an optional variant specification: expand into
the name of the @api{} function @cfunc{new}.

Functions with this name are constructors for @struct{} instances allocated on the heap.  The memory
allocation is performed by calling the @cfunc{alloc} function.  The initialisation of the fields is
performed by calling the @cfunc{init} function.
@end defmac


@defmac cclib_delete (@var{STRUCT}, @var{VARIANT},  @dots{})
Given a data structure type name @var{STRUCT}, and an optional variant specification: expand into
the name of the @api{} function @cfunc{delete}.

Functions with this name are destructors for @struct{} instances allocated on the heap.  The
finalisation of the fields is performed by calling the @cfunc{final} function.  The memory release
is performed by calling the @cfunc{release} function.
@end defmac


@defmac cclib_is (@var{STRUCT}, @var{VARIANT},  @dots{})
Given a data structure type name @var{STRUCT}, and an optional variant specification: expand into
the name of the @api{} function @cfunc{is}.

Functions with this name are predicates that return @ctrue{} if their argument is of the given type;
otherwise they return @cfalse{}.  These functions can be implemented only when it is possible to
determine the type of a data structure at run--time.
@end defmac


The following code is a usage example of common function implementation for @struct{} types; this
example is distributed in source form under the directory @file{examples} of @value{PACKAGE}, with
the file stem @code{struct-no-methods}.

@smallexample
#include <ccexceptions.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

typedef my_coords_t     my_coords_t;

struct my_coords_t @{
  double  X;
  double  Y;
@};

void
cclib_init(my_coords_t, rec) (my_coords_t * S, double X, double Y)
@{
  S->X = X;
  S->Y = Y;
@}

void
cclib_init(my_coords_t, pol) (my_coords_t * S, double RHO, double THETA)
@{
  S->X = RHO * cos(THETA);
  S->Y = RHO * sin(THETA);
@}

void
cclib_final(my_coords_t) (my_coords_t * S)
@{
@}

static my_coords_t *
cclib_alloc(my_coords_t) (cce_destination_t L)
@{
  return (my_coords_t *)cce_sys_malloc(L, sizeof(my_coords_t));
@}

static void
cclib_release(my_coords_t) (my_coords_t * S)
@{
  free(S);
@}

my_coords_t *
cclib_new(my_coords_t, rec) (cce_destination_t L, double X, double Y)
@{
  my_coords_t * S = cclib_alloc(my_coords_t)(L);

  cclib_init(my_coords_t, rec)(S, X, Y);
  return S;
@}

my_coords_t *
cclib_new(my_coords_t, pol) (cce_destination_t L, double RHO, double THETA)
@{
  my_coords_t * S = cclib_alloc(my_coords_t)(L);

  cclib_init(my_coords_t, pol)(S, RHO, THETA);
  return S;
@}

void
cclib_delete(my_coords_t) (my_coords_t * S)
@{
  cclib_final(my_coords_t)(S);
  cclib_release(my_coords_t)(S);
@}

int
main (void)
@{
  cce_location_t        L[1];
  my_coords_t *         S;
  cce_clean_handler_t   S_H[1];

  if (cce_location(L)) @{
    cce_run_catch_handlers_final(L);
  @} else @{
    S = cclib_new(my_coords_t, rec)(L, 1.0, 2.0);
    cce_init_and_register_handler(L, S_H,
      cce_default_clean_handler_function,
      cce_resource_pointer(S),
      cce_resource_destructor(cclib_delete(my_coords_t)));

    printf("X=%f, Y=%f\n", S->X, S->Y);
  @}
  exit(EXIT_SUCCESS);
@}
@end smallexample

@c page
@node cclibraries structs values
@appendixsubsec Data structures as values


The following preprocessor macros define the ``well known functions @api{} for common data
structures passed by value: a set of basic operations on data structures.  Usually we allocate a
data structure then use a pointer to it as argument to functions; but if a data structure is
``small'' we can pass it by value, with no significant overhead.

There is no better way to learn how to use this @api{} than to peruse the distributed and installed
examples, they are the files with stem @code{struct-as-value}.

The header file @file{cclibraries.h} defines some macros especially for use with structures as
values.  Some of these macros are variadic and accept from zero up to three @var{VARIANT} arguments;
@ref{cclibraries variadic, Variadic preprocessor macros}.


@defmac cclib_make (@var{STRUCT}, @var{VARIANT}, @dots{})
Given a data structure type name @var{STRUCT} and an optional variant specification: expand into the
name of the @api{} function @cfunc{make}.  Functions with this name are constructors for @struct{}
instances passed by value.  Usage example:

@example
typedef struct my_complex_t     my_complex_t;

struct my_complex_t @{
  double  real_part;
  double  imag_part;
@};

my_complex_t
cclib_make(my_complex_t) (double re, double im)
@{
  my_complex_t Z = @{
    .real_part = re,
    .imag_part = im
  @};

  return Z;
@}
@end example
@end defmac


@defmac cclib_unmake (@var{STRUCT}, @var{VARIANT}, @dots{})
Given a data structure type name @var{STRUCT} and an optional variant specification: expand into the
name of the @api{} function @cfunc{unmake}.  Functions with this name are destructors for @struct{}
instances passed by value.
@end defmac

@c page
@node cclibraries structs descr
@appendixsubsec Data structures with descriptor


A ``data structure with descriptor (or ``struct with descr'') is just a regular C language data
structure in which a field is itself a data structure defined by the @file{cclibraries.h} @api{} of
preprocessor macros.  It is something like this pseudo--code:

@example
struct cclib_descr_t @{
  ...
@};

struct my_data_t @{
  ...
  struct cclib_descr_t cclib_descr;
  ...
@};
@end example

@noindent
the position of the descriptor field with respect to the other fields does not matter: there is no
requirement of it being the first field.  The descriptor contains meta--informations about the
structure, for example a ``table of methods'': a data structure holding pointers to functions
specialised to operate on the structure itself.  We can define a ``struct with descr'' along with
the common data structures @api{}, @ref{cclibraries structs common, Well known functions for
@struct{} types}.

There is no better way to learn how to use this @api{} than to peruse the distributed and installed
examples, they are the files with stem @code{struct-with-descr}.

Some macros in the following @api{} are variadic and accept from zero up to three @var{VARIANT}
arguments; @ref{cclibraries variadic, Variadic preprocessor macros}.


@defmac CCLIB_DEFINE_STRUCT_WITH_DESCRIPTOR (@var{STRUCT})
Given a data structure name @var{STRUCT}, which is meant to be a ``struct with descr'': expand into
a preamble of declarations and definitions required to define a ``struct with descr''.  This macro
should be used before declaring the data structure itself.  Usage example:

@example
CCLIB_DEFINE_STRUCT_WITH_DESCRIPTOR(my_complex_t);

typedef struct my_complex_t     my_complex_t;

struct my_complex_t @{
  cclib_struct_descriptor(my_complex_t);
  double        re;
  double        im;
@};
@end example
@end defmac


@defmac cclib_struct_descriptor_type (@var{STRUCT})
@defmacx cclib_struct_descriptor_t (@var{STRUCT})
Given a data structure name @var{STRUCT}, which is meant to be a ``struct with descr'': expand into
the type name of its descriptor field.  Usually we do not need to use this macro directly.
@end defmac


@defmac cclib_struct_descriptor (@var{STRUCT})
Given a data structure name @var{STRUCT}, which is meant to be a ``struct with descr'': expand into
the descriptor structure field declaration.  We must include a use of this macro in the declaration
of a structure:

@example
struct my_complex_t @{
  cclib_struct_descriptor(my_complex_t);
  double  real_part;
  double  imac_part;
@}
@end example
@end defmac


@defmac cclib_methods_table_type (@var{STRUCT}, @var{VARIANT}, @dots{})
@defmacx cclib_methods_table_t (@var{STRUCT}, @var{VARIANT}, @dots{})
Given a data structure name @var{STRUCT} (which is meant to be a ``struct with descr'') and an
optional variant specification: expand into the name of the methods table type.  For every ``struct
with descr'' we can define a single table of methods.  Usage example:

@example
struct cclib_methods_table_type(my_complex_t) @{
  cclib_method_type(my_complex_t, destroy) *    destroy;
@};
@end example
@end defmac


@defmac cclib_methods_table (@var{STRUCT_TYPE}, @var{VARIANT}, @dots{})
Given a data structure name @var{STRUCT} (which is meant to be a ``struct with descr'') and an
optional variant specification: expand into the name of the methods table for the @struct{} type.
For every table of methods type we can define as many structure instances as we desire.  Usage
example:

@example
static cclib_methods_table_type(my_complex_t) const
    cclib_methods_table(my_complex_t, embedded) = @{
  .destroy      = cclib_method(my_complex_t, destroy, embedded)
@};

static cclib_methods_table_type(my_complex_t) const
    cclib_methods_table(my_complex_t, standalone) = @{
  .destroy      = cclib_method(my_complex_t, destroy, standalone)
@};
@end example
@end defmac


@defmac cclib_method_type (@var{STRUCT}, @var{METHOD}, @var{VARIANT}, @dots{})
@defmacx cclib_method_t (@var{STRUCT}, @var{METHOD}, @var{VARIANT}, @dots{})
Given a data structure name @var{STRUCT} (which is meant to be a ``struct with descr''), a method
name @var{METHOD}, and an optional variant specification: expand into the type name of that variant
of the method function.  Usage example to define the type signature of a method's implementation
function:

@example
typedef void cclib_method_type(my_complex_t, destroy) (my_complex_t * self);
@end example
@end defmac


@defmac cclib_method (@var{STRUCT}, @var{METHOD}, @var{VARIANT}, @dots{})
Given a data structure name @var{STRUCT} (which is meant to be a ``struct with descr''), a method
name @var{METHOD}, and an optional variant specification: expand into the name of that variant of
method's implementation function.  Usage example to define a couple of method implementations:

@example
void
cclib_method(my_complex_t, destroy, embedded) (my_complex_t * self)
@{
  cclib_final(my_complex_t)(self);
@}

void
cclib_method(my_complex_t, destroy, standalone) (my_complex_t * self)
@{
  cclib_delete(my_complex_t)(self);
@}
@end example
@end defmac


@defmac cclib_struct_descriptor_ref_methods_table_pointer (@var{PTR})
Given a pointer do data structure @var{PTR} (which is meant to be a ``struct with descr''): return a
pointer to its methods table usable as both lvalue and rvalue.
@end defmac


@defmac cclib_struct_descriptor_set_methods_table_pointer (@var{PTR}, @var{METHODS_TABLE_POINTER})
Given a pointer do data structure @var{PTR} (which is meant to be a ``struct with descr''): set its
pointer to methods table to @var{METHODS_TABLE_POINTER}.  Usage example:

@example
void
cclib_init(my_complex_t, rec) (my_complex_t * S, double re, double im)
@{
  cclib_struct_descriptor_set_methods_table_pointer(S,
    &cclib_methods_table(my_complex_t, embedded));
  S->real_part = re;
  S->imag_part = im;
@}
@end example
@end defmac


@defmac cclib_method_pointer (@var{PTR}, @var{METHOD})
Given a struct type name @var{STRUCT} (which is meant to be a ``struct with descr''), a method name
@var{METHOD}: expand into an expression evaluating to a pointer to the method implementation.  Usage
example:

@example
cce_location_t          L[1];
my_complex_t            Z[1];
cce_clean_handler_t     Z_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  cclib_init(my_complex_t, rec)(Z, 1.0, 2.0);
  cce_init_and_register_handler(L, Z_H,
    cce_default_clean_handler_function,
    cce_resource_pointer(Z),
    cce_resource_destructor(cclib_method_pointer(Z, destroy)));

  cce_run_body_handlers(L);
@}
@end example
@end defmac


@defmac cclib_call (@var{METHOD}, @var{PTR}, @dots{})
Given the name of a method @var{METHOD}, the name of a variable @var{PTR} holding a data structure
pointer (which is meant to be a ``struct with descr''), any number of optional arguments: expand
into an expression that calls the selected method applying it to the pointer @var{PTR} itself (as
first argument) and the optional arguments.  Usage example:

@example
my_complex_t  Z[1];

cclib_init(my_complex_t, rec)(Z, 1.0, 2.0);
...
cclib_call(destroy, Z);
@end example
@end defmac


@defmac cclib_vcall (@var{METHOD}, @var{VAR}, @dots{})
Given the name of a method @var{METHOD}, the name of a variable @var{VAR} holding a data structure
as value (which is meant to be a ``struct with descr''), any number of optional arguments: expand
into an expression that calls the selected method applying it to the value @var{VAR} itself (as
first argument) and the optional arguments.  Usage example:

@example
my_complex_t  Z;

Z = cclib_make(my_complex_t, rec)(1.0, 2.0);
...
cclib_vcall(print, Z, stderr);
@end example
@end defmac

@c page
@node cclibraries structs traits
@appendixsubsec Trait data structures


The purpose of traits is to implement a unified interface for some behaviour different resources
implement; for example: different C language string implementations might implement the same
``string'' trait to provide a unified @api{} to some string operations; different file system
pathname implementations might implement the same ``pathname'' trait to provide a unified @api{} to
file system pathname operations.

Traits are data structures with the following characteristics:

@itemize
@item
Traits implement the @file{cclibraries.h} common data structures @api{}.

@item
Traits are passed by value as arguments to functions, @ref{cclibraries structs values, Data
structures as values}.

@item
Traits have only two fields:

@itemize -
@item
A descriptor as defined by the @file{cclibraries.h} @api{}, @ref{cclibraries structs descr, Data
structures with descriptor}.

@item
A pointer to a resource that the trait operates upon; typically another data structure.
@end itemize

@item
Traits implement a table of methods; every method accepts as first argument the trait data structure
itself, passed by value.  This way every method can call the other methods in the table.

@item
Traits have no state, there must be no trait destructor functions; when we have finished using a
trait: we just forget it like we forget an @objtype{int} or @objtype{double} variable.

@item
While trait data structures hold a pointer to the underlying resource, they do not ``own'' it:
stopping to use of a trait data structure must not cause the underlying resource to be destroyed
too, neither must cause the underlying resource to be leaked (it is our responsibility to ensure
this).

@item
By convention: we should select, as name of a trait, a C language identifier ending with @code{_T}.
@end itemize

There is no better way to learn how to use this @api{} than to peruse the distributed and installed
examples, they are the files with stem @code{trait}.


@defmac CCLIB_DEFINE_TRAIT (@var{TRAIT})
Define what is needed as preamble for a trait data structure.  To define a new
@objtype{my_destructor_T} trait, we should use this function as:

@example
CCLIB_DEFINE_TRAIT(my_destructor_T);
@end example

To finish the trait definition: we must define a table of methods in the same way we do for a
``struct with descr'', @ref{cclibraries structs descr, Data structures with descriptor}.
@end defmac


@deftypefn {Preprocessor Macro} {cclib_resource_data_t const *} cclib_trait_resource_pointer (@var{VAR})
Given a trait data structure @var{VAR} as argument: return a pointer to the underlying resource the
@var{TRAIT} operates upon.
@end deftypefn

@c page
@node cclibraries exceptions
@appendixsec Exception handling helpers


The location handlers @api{} defined by @value{PACKAGE} requires data types and functions with
specific roles, @ref{handlers, The location handlers @api{}}.  The header file @file{cclibraries.h}
defines some preprocessor macros to tag the names of such definitions with their intended purpose.

There is no better way to learn how to use this @api{} than to peruse the distributed and installed
examples; all the examples defining a data structure type also implement the associated
exception--handlers.

All the macros are variadic and accept from zero up to three @var{VARIANT} arguments;
@ref{cclibraries variadic, Variadic preprocessor macros}.


@defmac cclib_exception_handler_type (@var{STRUCT}, @var{VARIANT}, @dots{})
@defmacx cclib_exception_handler_t (@var{STRUCT}, @var{VARIANT}, @dots{})
Given the name of a data structure type @var{STRUCT}, and an optional variant specification: expand
into the name of an exception--handler structure to be used to finalise instances of the structure
type.  The data structure types should be wrappers for @objtype{cce_clean_handler_t} and
@objtype{cce_error_handler_t}.
@end defmac


@defmac cclib_exception_handler_function (@var{STRUCT}, @var{VARIANT}, @dots{})
Given the name of a data structure type @var{STRUCT}, and an optional variant specification: expand
into the name of a function to be used as exception--handler.  These functions should have the type
signature defined by the types @objtype{cce_clean_handler_fun_t} and
@objtype{cce_error_handler_fun_t}.
@end defmac


@defmac cclib_exception_handler_init_and_register (@var{STRUCT}, @var{VARIANT}, @dots{})
Given the name of a data structure type @var{STRUCT}, and an optional variant specification: expand
into the name of a function to be used to initialise an exception handler to finalise an instance of
the structure type.  These functions should call @cfunc{cce_init_and_register_handler} to perform
the operation.
@end defmac

@c page
@node cclibraries conditions
@appendixsec Exceptional--condition objects


The exceptional--condition objects @api{} defined by @value{PACKAGE} requires data types and
functions with specific roles, @ref{conditions, Exceptional condition descriptors}.  The header file
@file{cclibraries.h} defines some preprocessor macros to tag the names of such definitions with
their intended purpose.

There is no better way to learn how to use this @api{} than to peruse the distributed and installed
examples, they are the files with stem @code{condition-object}.

All the macros are variadic and accept from zero up to three @var{VARIANT} arguments;
@ref{cclibraries variadic, Variadic preprocessor macros}.  The @var{STEM} argument to a macro must
uniquely identify an exceptional--condition object type; it should be composed by:

@itemize
@item
A library or context prefix, like @code{cce_} for CCExceptions types.

@item
An exceptional--condition description, like @code{logic_error}.
@end itemize


@defmac cclib_exceptional_condition_descriptor_type (@var{STEM}, @var{VARIANT}, @dots{})
@defmacx cclib_exceptional_condition_descriptor_t (@var{STEM}, @var{VARIANT}, @dots{})
Expand into the name of an exceptional--condition descriptor type.  Usage example:

@example
struct cclib_exceptional_condition_descriptor_type(my_error) @{
  cce_descriptor_t      descriptor;
@};
@end example
@end defmac


@defmac cclib_exceptional_condition_descriptor (@var{STEM}, @var{VARIANT}, @dots{})
Expand into the name of an exceptional--condition descriptor variable.  Usage example:

@example
static cclib_exceptional_condition_descriptor_type(my_error)
    cclib_exceptional_condition_descriptor(my_error) = @{
  .descriptor.parent            = ...,
  .descriptor.final             = ...,
  .descriptor.delete            = ...,
  .descriptor.static_message    = ...
@};
@end example
@end defmac


@deftypefn {Preprocessor Macro} {cce_descriptor_t *} cclib_exceptional_condition_descriptor_pointer (@var{STEM}, @var{VARIANT}, @dots{})
This macro is similar to @cfunc{cce_descriptor_pointer}, @ref{conditions descriptors,
cce_descriptor_pointer}.  Expand into an expression evaluating to the pointer to an
exceptional--condition descriptor variable.  The expression:

@example
cclib_exceptional_condition_descriptor_pointer(my_error)
@end example

@noindent
expands into the address of the field @code{descriptor} in the data structure variable:

@example
cclib_exceptional_condition_descriptor(my_error)
@end example
@end deftypefn


@defmac cclib_exceptional_condition_descriptor_set_parent_to (@var{STEM}, @var{VARIANT}, @dots{})
This macro is similar to @cfunc{cce_descriptor_set_parent_to}, @ref{conditions descriptors,
cce_descriptor_set_parent_to}.  Expand into the name of a function that set the parent of a
descriptor.  Usage example:

@example
void
cclib_exceptional_condition_descriptor_set_parent_to(my_error) (cce_descriptor_t * const D)
@{
  D->parent = cclib_exceptional_condition_descriptor_pointer(my_error);
@}
@end example
@end defmac


@defmac cclib_exceptional_condition_object_type (@var{STEM}, @var{VARIANT}, @dots{})
@defmacx cclib_exceptional_condition_object_t (@var{STEM}, @var{VARIANT}, @dots{})
Expand into the name of an exceptional--condition object type.
@end defmac


@defmac cclib_exceptional_condition_object_is (@var{STEM}, @var{VARIANT}, @dots{})
Expand into the name of a predicate function which, applied to an argument of type
@code{cce_condition_t const *}, returns @ctrue{} if the argument is a pointer to an
exceptional--condition object of type:

@example
cclib_exceptional_condition_object_type (@var{STEM}, @var{VARIANT}, @dots{})
@end example

Usage example:

@example
bool
cclib_exceptional_condition_object_is(my_error) (cce_condition_t const * C)
@{
  return cce_condition_is(C, cclib_exceptional_condition_descriptor_pointer(my_error));
@}
@end example
@end defmac

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
the latest release of this package can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
@c Local Variables:
@c ispell-local-dictionary: "en_GB"
@c End:
