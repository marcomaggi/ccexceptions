\input texinfo.tex
@c %**start of header
@setfilename ccexceptions.info
@settitle CCExceptions
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCExceptions

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCExceptions

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccexceptions

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2016-2017

@c ------------------------------------------------------------

@set GITHUB_URL                 @url{http://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BITBUCKET_URL              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DOWNLOAD_URL               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DOCUMENTATION_URL          @url{http://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C11 Standard language library;
it implements an interface to non--local exits, which is somewhat similar to exceptions handling.
The library targets @posix{} systems.

The package is distributed under the terms of the @gnu{} General Public License (@gpl{}).

The latest release can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} General
Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccexceptions: (ccexceptions).       CCExceptions a C language library
                                      implementing exceptions handling.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* setjmp::                      Brief introduction to non-local exits.
* locations::                   The locations @api{}.
* handlers::                    The handlers @api{}.
* conditions::                  Exceptional condition descriptors.
* syscalls::                    System call adapters.
* syshandlers::                 Predefined exception handlers.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library; it
implements an interface to non--local exits, which is somewhat similar to exceptions handling.  The
library targets @posix{} systems but supports some @gnu{} C Library functions and some Linux
functions.

This tiny library will not solve the problem of error handling in the C language, it just brings a
little order in the complexity resulting from hand--coding the error handling logic.
@value{PACKAGE}'s location mechanism has the following purposes:

@enumerate
@item
Implement non--local exits in a way that allows client source code to be shorter and simpler to
understand.

@item
Implement non--local exit handlers to perform synchronous clean--up operations.

@item
Implement a simple exceptional condition descriptors architecture.
@end enumerate

@noindent
these features come at the cost of slowing down execution in a possibly sensible way (with respect
to, for example, hand--coded @code{goto} instructions that jump to labels).

@value{PACKAGE} installs the main header file @file{ccexceptions.h} along with other headers with
names in the pattern @file{ccexceptions-*.h}.  All the function names in the @api{} are prefixed
with @code{cce_}; all the preprocessor symbol names are prefixed with @code{CCE_}; all the type
names are prefixed with @code{cce_} and suffixed with @code{_t}.

@strong{IMPORTANT} To use the library we must enable the @posix{} features when including the
standard header files; so either we include @file{ccexceptions.h} as first header, or we include the
following definitions before including @strong{all} the header files:

@example
#define _POSIX_C_SOURCE         200809L
@end example

@menu
* overview linking::            Linking code with the library.
@end menu

@c page
@node overview linking
@section Linking code with the library


@subsubheading Using the @gnu{} Autotools

This package installs a data file for @command{pkg-config}; when searching for the installed library
with the @gnu{} Autotools, we can add the following macro use to @file{configure.ac}:

@example
PKG_CHECK_MODULES([CCEXCEPTIONS],[ccexceptions >= 0.5])
@end example

@noindent
which will set the variables @code{CCEXCEPTIONS_LIBS} and @code{CCEXCEPTIONS_CFLAGS}.

Alternatively we can use the raw @gnu{} Autoconf macros:

@example
AC_CHECK_LIB([ccexceptions],[cce_version_string],,
  [AC_MSG_FAILURE([test for CCExceptions library failed])])
AC_CHECK_HEADERS([ccexceptions.h],,
  [AC_MSG_FAILURE([test for CCExceptions header failed])])
@end example

We need to remember that client code using @value{PACKAGE}'s library must be written using the C11
language.

@c ------------------------------------------------------------------------

@subsubheading One--shot compilation, Unix command line

For the one--shot compilation of a file named @file{demo.c}, we can do:

@example
gcc -std=c11 -Wall \
   `pkg-config ccexceptions --cflags` \
   `pkg-config ccexceptions --libs` \
   -o demo demo.c
@end example

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the
@gnu{} Autotools.  For an explanation of interface numbers as managed by
@gnu{} Libtool @xref{Libtool versioning, interface, Libtool's versioning
system, libtool, Shared library support for @gnu{}}.


@deftypefun {const char *} cce_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing
the interface version number.
@end deftypefun


@deftypefun int cce_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int cce_version_interface_revision (void)
Return an integer representing the library interface current revision
number.
@end deftypefun


@deftypefun int cce_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node setjmp
@chapter Brief introduction to non--local exits


Let's recall briefly how the standard, C language, non--local exits mechanism works; for the full
documentation refer to the C Library.  @glibcref{Non-Local Exits, Non-Local Exits}.

To use @cfunc{setjmp} and @cfunc{longjmp} we write chunks of code like the following:

@example
#define JMP_ERROR_CODE          1

jmp_buf  here;

if (setjmp(here))
  @{
    handle_the_error();
  @}
else
  @{
    do_something();
    if (an_error_occurred()) @{
      longjmp(here, JMP_ERROR_CODE);
    @}
    do_something_else();
  @}
@end example

@noindent
this is what happens:

@itemize
@item
When @cfunc{setjmp} is invoked: it saves the current ``position'' in @var{here}, then it returns
zero.

@item
If @cfunc{longjmp} is not applied to @var{here}, nothing strange happens and the execution flow goes
on as usual.

@item
If @cfunc{longjmp} is applied to @var{here}: the execution jumps back to the call to @cfunc{setjmp}
with @code{JMP_ERROR_CODE} as return value.
@end itemize

This mechanism allows us to separate the exception handling code from the main code.  By using
@var{here} as argument to nested function calls: we can perform non--local exits across functions;
something that is not possible with @code{goto} statements.

As always, care must be taken when the body allocates asynchronous resources.  For each resource:
the exception handler must detect if the allocation took place and execute release code.  For
example:

@example
jmp_buf         here;
volatile void * P = NULL;

if (setjmp(here))
  @{
    if (P)
      free(P);
  @}
else
  @{
    ...
    P = malloc(4096);
    ...
  @}
@end example

Let's see some logic example; we will assume the following preamble:

@example
#include <assert.h>
#include <stdlib.h>
#include <setjmp.h>

#define JUMP_TO_ERROR           2
#define JUMP_TO_RETRY           3
@end example

In the following code no jump is performed; we just call @cfunc{setjmp} once and never call
@cfunc{longjmp}:

@example
jmp_buf         L;
int             flag = 0, code;

code = setjmp(L);
if (code) @{
  flag = 2;
@} else @{
  flag = 1;
@}
assert(0 == code);
assert(1 == flag);
@end example

In the following code we perform a jump and handle the logic with an @code{if} statement:

@example
jmp_buf         L;
int             flag = 0, code;

code = setjmp(L);
if (JUMP_TO_ERROR == code) @{
  flag = 2;
@} else @{
  flag = 1;
  longjmp(L, JUMP_TO_ERROR);
@}
assert(JUMP_TO_ERROR == code);
assert(2 == flag);
@end example

In the following code we perform a jump and handle the logic with a @code{switch} statement:

@example
jmp_buf         L;
int             flag = 0, code;

code = setjmp(L);
switch (code) @{
case JUMP_TO_ERROR:
  flag = 2;
  break;
default:
  flag = 1;
  longjmp(L, JUMP_TO_ERROR);
@}
assert(JUMP_TO_ERROR == code);
assert(2 == flag);
@end example

In the following code we perform a jump and try an alternative body; we handle the logic with a
@code{switch} statement:

@example
jmp_buf         L;
int             flag = 0, code;

code = setjmp(L);
switch (code) @{
case JUMP_TO_ERROR:
  flag = 2;
  longjmp(L, JUMP_TO_RETRY);
  break;
case JUMP_TO_RETRY:
  // the alternative body
  flag = 3;
  break;
default:
  // the body
  flag = 1;
  longjmp(L, JUMP_TO_ERROR);
@}
assert(JUMP_TO_RETRY == code);
assert(3 == flag);
@end example

In the following code we perform a jump and retry the body several times:

@example
jmp_buf         L;
int             flag = 0, code;
volatile int    times = 0;

code = setjmp(L);
switch (code) @{
case JUMP_TO_ERROR:
  flag = 2;
  longjmp(L, JUMP_TO_RETRY);
  break;
default:
  if ((JUMP_TO_RETRY == code) && (times < 5)) @{
    // retrying
    ++times;
    longjmp(L, JUMP_TO_ERROR);
  @} else if (JUMP_TO_RETRY == code) @{
    flag = 3;
  @} else @{
    // the body
    flag = 1;
    longjmp(L, JUMP_TO_ERROR);
  @}
@}
assert(JUMP_TO_RETRY == code);
assert(3 == flag);
@end example

@c page
@node locations
@chapter The locations @api{}


Non--local exits are a way to transfer execution from one point to another in a program; they are
implemented by the standard C library through the @cfunc{setjmp} and @cfunc{longjmp} functions.
@value{PACKAGE} uses the @posix{} variants @cfunc{sigsetjmp} and @cfunc{siglongjmp}: it does
@strong{not} save the signals mask.

The main usage pattern for this module is the following:

@example
cce_location_t  L[1];

if (CCE_ENTER == cce_location(L)) @{
  /* do something useful here */
  cce_run_cleanup_handlers(L);
@} else @{
  /* handle the exception here */
  cce_run_error_handlers(L);
  cce_condition_delete(cce_condition(L));
@}
@end example

@noindent
or alternatively the following:

@example
cce_location_t  L[1];

if (cce_location(L)) @{
  /* handle the exception here */
  cce_run_error_handlers(L);
  cce_condition_delete(cce_condition(L));
@} else @{
  /* do something useful here */
  cce_run_cleanup_handlers(L);
@}
@end example

We can use the slightly shorter versions:

@example
cce_location_t  L[1];

if (CCE_ENTER == cce_location(L)) @{
  /* do something useful here */
  cce_run_cleanup_handlers(L);
@} else @{
  /* handle the exception here */
  cce_run_error_handlers_final(L);
@}
@end example

@noindent
and:

@example
cce_location_t  L[1];

if (cce_location(L)) @{
  /* handle the exception here */
  cce_run_error_handlers_final(L);
@} else @{
  /* do something useful here */
  cce_run_cleanup_handlers(L);
@}
@end example


@noindent
it is usually useful to define variables of type @objtype{cce_location_t} as one--element arrays.
When using @value{PACKAGE} we should consider configuring our code editor to automatically insert
this code template.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_location_t
Struct type representing the location context.  This type is ``derived'' from @objtype{sigjmp_buf}
in the sense that a pointer to @objtype{cce_location_t} is also a pointer to @objtype{sigjmp_buf}.

Instances of this structure reference an instance of type @objtype{cce_condition_t}; it is set by
@cfunc{cce_raise} and @cfunc{cce_retry}.  The client code is responsible for releasing resources
associated to this value by retrieving a pointer to it with @cfunc{cce_condition} and releasing it
with @cfunc{cce_condition_delete}.

Before terminating the use of instances of this type we must always call
@cfunc{cce_run_error_handlers} or @cfunc{cce_run_cleanup_handlers}.  We must assume that the
handlers might access the @objtype{cce_condition_t} object, so: first we call the handlers, then we
release the condition object.
@end deftp


@deftypefun void cce_location_init (cce_location_t * @var{L})
Initialise the location @var{L}, but do @strong{not} call @cfunc{sigsetjmp}.  We are not meant to
call this function directly; rather we should use the macro @cfunc{cce_location}.
@end deftypefun


@deftypefn {Preprocessor Macro} int cce_location (cce_location_t * @var{L})
Initialise the location @var{L}; call @cfunc{sigsetjmp} and return its return value.
@end deftypefn


@deftypevr Constant int CCE_ENTER
@deftypevrx Constant int CCE_SUCCESS
Constants used by the library as non--local exit codes.  They are defined as @code{0} and represent
the return value of @cfunc{cce_location} at the first evaluation.
@end deftypevr


@deftypevr Constant int CCE_EXCEPT
@deftypevrx Constant int CCE_ERROR
Constants used by the library as non--local exit codes.  They are defined as @code{1} and are the
return value of @cfunc{cce_location} when a non--local exit is performed by @cfunc{cce_raise}.
@end deftypevr


@deftypevr Constant int CCE_RETRY
Constant used by the library as non--local exit code.  It is the return value of
@cfunc{cce_location} when a non--local exit is performed by @cfunc{cce_retry}.
@end deftypevr


@deftypefun void cce_raise (cce_location_t * @var{L}, const cce_condition_t * @var{C})
Raise an exception associated to the location @var{L}, with exceptional condition object @var{C}.
This function performs the call to @cfunc{siglongjmp} with code @code{CCE_EXCEPT}.

With a call to this function: the client code is put in charge of releasing resources associated to
@var{C}.  If @var{C} is @cnull{}: an internal, statically allocated, exceptional condition object is
selected to represent an ``unknown exceptional condition''; we can transparently apply the function
@cfunc{cce_condition_delete} to this object.
@end deftypefun


@deftypefun void cce_retry (cce_location_t * @var{L})
Raise an exception associated to the location @var{L} with the purpose or retrying the body
evaluation.  This function performs the call to @cfunc{siglongjmp} with code @code{CCE_RETRY}.

This function selects an internal, statically allocated, exceptional condition object to represent
an ``unknown exceptional condition''; we can transparently apply the function
@cfunc{cce_condition_delete} to this object.
@end deftypefun


@deftypefn {Generic Macro} {cce_condition_t *} cce_condition (cce_location_t * @var{L})
Return the condition object associated to the location @var{L}; this value is @strong{never}
@cnull{}.

If we apply this function to a location without calling @cfunc{cce_raise} or @cfunc{cce_retry}: the
returned pointer references an internal, statically allocated, exceptional condition object
representing an ``unknown exceptional condition''; we can transparently apply the function
@cfunc{cce_condition_delete} to this object.
@end deftypefn


As examples of logic, consider the following:

@itemize
@item
If we want to evaluate a body of code and catch its raised exceptions locally, we can use the
following template code:

@example
cce_location_t  L[1];

if (cce_location(L)) @{
  /* handle the exception here */
  cce_run_error_handlers_final(L);
@} else @{
  /* do something useful here */
  cce_run_cleanup_handlers(L);
@}
@end example

@item
If we want to evaluate a body of code, catch its raised exceptions locally and then re--raise them
to another location, we can use the following template code:

@example
void
outer (void)
@{
  cce_location_t  L[1];

  if (cce_location(L)) @{
    /* handle the exception here */
    cce_run_error_handlers_final(L);
  @} else @{
    inner(L);
    cce_run_cleanup_handlers(L);
  @}
@}

void
inner (cce_location_t * there)
@{
  cce_location_t  L[1];

  if (cce_location(L)) @{
    cce_run_error_handlers(L);
    cce_raise(there, cce_condition(L));
  @} else @{
    /* do something useful here */
    cce_run_cleanup_handlers(L);
  @}
@}
@end example

@item
When attempting to evaluate a body of code multiple times with the retry facility, it is suggested
to use @code{switch} statements to organise the logic of location mechanisms.  If we want to
distinguish between the main body and the retry body, we do:

@example
cce_location_t  L[1];

switch (cce_location(L)) @{
case CCE_EXCEPT:
  /* handle the error */
  cce_run_error_handlers_final(L);
  break;

case CCE_RETRY:
  /* retry the operation here */
  if (some_recoverable_error()) @{
    cce_retry(L);
  @} else if (some_error()) @{
    cce_raise(L, NULL);
  @}
  break;

default:
  /* do something useful here */
  if (some_recoverable_error()) @{
    cce_retry(L);
  @} else if (some_error()) @{
    cce_raise(L, NULL);
  @}
@}
@end example

@noindent
and we can fall through:

@example
cce_location_t  L[1];

switch (cce_location(L)) @{
case CCE_EXCEPT:
  /* handle the exception here */
  cce_run_error_handlers_final(L);
  break;

case CCE_RETRY:
  /* prepare to retry here, fall through */

default:
  /* do something useful here */
  do_something();
  if (some_recoverable_error()) @{
    cce_retry(L);
  @} else if (some_error()) @{
    cce_raise(L, NULL);
  @}
@}
@end example
@end itemize

@c page
@node handlers
@chapter The handlers @api{}


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_handler_t
Structure type representing a cleanup or error handler.  Instances of this type are associated to a
location by calling one of the functions @cfunc{cce_register_*_handler}.  Handlers are invoked by
calling one of the functions @cfunc{cce_run_*_handlers}; before terminating the use of a
@objtype{cce_location_t} instance we must always call the handlers.

We are meant to wrap instances of this type into an enclosing struct definition as follows:

@example
struct resource_handler_t @{
  cce_handler_t 	handler;
  void *		resourcep;
@};
@end example

@noindent
in which the instance of @code{cce_handler_t} is the first field.

The structure has the following public fields:

@table @code
@item cce_handler_fun_t * function
Pointer to the function implementing the handler.
@end table

@noindent
the following fields are members of an anonymous union:

@table @code
@item void * pointer
Pointer available to the client code.

@item char * pathname
Pointer available to the client code.

@item int filedes
An integer meant to be used for file descriptors.

@item int pipedes[2]
Integers meant to be used for pipe descriptors.
@end table
@end deftp


@deftypefn {Function Typedef} void cce_handler_fun_t (const cce_condition_t * @var{C}, cce_handler_t * @var{H})
Type of handler functions meant to release some asynchronous resource.  The argument @var{C}
references the object representing the exceptional condition; the handler must leave it untouched,
it must @strong{not} mutate or release it.  The argument @var{H} references the handler context.

If an error occurs: the handler function must take care of itself and return to the caller, it must
@strong{not} raise an exceptional condition and jump to a remote location.

If the structure referenced by @var{H} is dynamically allocated: the handler function is responsible
to release its memory.
@end deftypefn


@deftypefun void cce_register_cleanup_handler (cce_location_t * @var{L}, cce_handler_t * @var{H})
Register the cleanup handler referenced by @var{H} in the list of handlers associated to the
location @var{L}.  The pointer @var{H} must reference an instance of structure whose first field is
a structure of type @code{cce_handler_t}; such structure can either be allocated on the same stack
frame of the function also defining the location object @var{L}, or be dynamically allocated on the
heap.

A cleanup handler is meant to be called whenever the execution flow leaves the dynamic extent of a
location, whether with an exception or as part of the successful execution path.
@end deftypefun


@deftypefun void cce_register_error_handler (cce_location_t * @var{L}, cce_handler_t * @var{H})
Register the error handler referenced by @var{H} in the list of handlers associated to the location
@var{L}.  The pointer @var{H} must reference an instance of structure whose first field is a
structure of type @code{cce_handler_t}; such structure can either be allocated on the same stack
frame of the function also defining the location object @var{L}, or be dynamically allocated on the
heap.

An error handler is meant to be called whenever the execution flow leaves the dynamic extent of a
location in case of an exceptional condition; it must @strong{not} be called as part of the
successful execution path.
@end deftypefun


@deftypefun void cce_run_cleanup_handlers (cce_location_t * @var{L})
Run all the cleanup handlers associated to the location @var{L}.  Each handler must return to its
caller, taking care of itself regarding internal error handling and asynchronous resources
allocation.  Handlers are called starting from the last registered one.

This is a destructive function: once the list has been traversed, it is not valid anymore.  When the
handler function is applied to the handler structure: the handler structure is completely detached
from the context of @var{L}, so it can be finalised and its memory released.
@end deftypefun


@deftypefun void cce_run_error_handlers (cce_location_t * @var{L})
Run all the cleanup and error handlers associated to the location @var{L}.  Each handler must return
to its caller, taking care of itself regarding internal error handling and asynchronous resources
allocation.  Handlers are called starting from the last registered one.

This is a destructive function: once the list has been traversed, it is not valid anymore.  When the
handler function is applied to the handler structure: the handler structure is completely detached
from the context of @var{L}, so it can be finalised and its memory released.

@strong{NOTE} It must assume that an error handler might access the exceptional condition object
associated to @var{L}, so this function should always be called @strong{before} applying
@cfunc{cce_condition_delete} to the return value of @cfunc{cce_condition}.
@end deftypefun


@deftypefun void cce_run_error_handlers_final (cce_location_t * @var{L})
Equivalent to calling:

@example
cce_run_error_handlers(L);
cce_condition_delete(cce_condition(L));
@end example
@end deftypefun


@deftypefun void cce_run_cleanup_handlers_final (cce_location_t * @var{L})
Equivalent to calling:

@example
cce_run_cleanup_handlers(L);
cce_condition_delete(cce_condition(L));
@end example
@end deftypefun


@deftypefun void cce_run_error_handlers_raise (cce_location_t * @var{L}, cce_location_t * @var{upper_L})
Equivalent to calling:

@example
cce_run_error_handlers(L);
cce_raise(upper_L, cce_condition(L));
@end example
@end deftypefun


@deftypefun void cce_run_cleanup_handlers_raise (cce_location_t * @var{L}, cce_location_t * @var{upper_L})
Equivalent to calling:

@example
cce_run_cleanup_handlers(L);
cce_raise(upper_L, cce_condition(L));
@end example
@end deftypefun


We could define and call a list of cleanup handlers as follows:

@example
void handler1 (const cce_condition_t * C, cce_handler_t * H) @{
  do_some_cleanup();
@}
void handler2 (const cce_condition_t * C, cce_handler_t * H) @{
  do_some_cleanup();
@}
void handler3 (const cce_condition_t * C, cce_handler_t * H) @{
  do_some_cleanup();
@}

@{
  cce_location_t L[1];
  cce_handler_t  H1 = @{ .function = handler1 @};
  cce_handler_t  H2 = @{ .function = handler2 @};
  cce_handler_t  H3 = @{ .function = handler3 @};

  cce_location_init(L);
  cce_register_cleanup_handler(L, &H1);
  cce_register_cleanup_handler(L, &H2);
  cce_register_cleanup_handler(L, &H3);
  cce_run_cleanup_handlers(L);
@}
@end example

@noindent
and we could define and call a list of error handlers as follows:

@example
void handler1 (const cce_condition_t * C, cce_handler_t * H) @{
  do_some_error_handling();
@}
void handler2 (const cce_condition_t * C, cce_handler_t * H) @{
  do_some_error_handling();
@}
void handler3 (const cce_condition_t * C, cce_handler_t * H) @{
  do_some_error_handling();
@}

@{
  cce_location_t L[1];
  cce_handler_t  H1 = @{ .function = handler1 @};
  cce_handler_t  H2 = @{ .function = handler2 @};
  cce_handler_t  H3 = @{ .function = handler3 @};

  cce_location_init(L);
  cce_register_error_handler(L, &H1);
  cce_register_error_handler(L, &H2);
  cce_register_error_handler(L, &H3);
  cce_run_error_handlers(L);
@}
@end example

Let's say we need to allocate memory with @cfunc{malloc}, and to release it with @cfunc{free}
whenever the dynamic extent of the local function terminates; we can use built--in functions for
this, @ref{syshandlers malloc}.  To show the mechanism, in the following example: we implement a
handler explicitly.

@example
typedef struct handler_t @{
  cce_handler_t handler;
  void *        pointer;
@} handler_t;

static void
P_handler (const cce_condition_t * C, cce_handler_t * _H)
@{
  handler_t * H = (handler_t *)_H;
  free(H->pointer);
@}

@{
  cce_location_t        L[1];
  handler_t             H;
  void *                P;

  H.handler.function = P_handler;

  if (cce_location(L)) @{
    cce_run_error_handlers_final(L);
  @} else @{
    errno = 0;
    P = malloc(4096);
    if (P) @{
      cce_register_cleanup_handler(L, &H.handler);
    @} else @{
      cce_raise(L, cce_condition_new_errno(errno));
    @}
    do_something(L, P);
    cce_run_cleanup_handlers(L);
  @}
@}
@end example

@noindent
whether @cfunc{do_something} raises an exception or not: the cleanup handler is invoked and the
memory is released.

Let's say we are writing a constructor and we need to allocate memory, do something and, if
successful, return the memory to the caller; to better show the mechanism: we do not use the field
@code{pointer} of @objtype{cce_handler_t}; we can organise the code as follows, using an error
handler in the constructor and a cleanup handler in the caller:

@example
typedef struct handler_t @{
  cce_handler_t handler;
  void *        pointer;
@} handler_t;

static void
P_handler (const cce_condition_t * C, cce_handler_t * _H)
@{
  handler_t * H = (handler_t *)_H;
  free(H->pointer);
@}

void *
constructor (cce_location_t * there)
@{
  cce_location_t    L;
  handler_t         H;
  void *            P;

  H.handler.function = P_handler;

  if (cce_location(L)) @{
    cce_run_error_handlers_raise(L, there);
  @} else @{
    errno = 0;
    P = malloc(4096);
    if (P) @{
      H.pointer = P;
      cce_register_error_handler(L, &H.handler);
    @} else @{
      cce_raise(L, cce_condition_new_errno(errno));
    @}
    do_some_initialisation_in(P);
    cce_run_cleanup_handlers(L);
  @}
  return P;
@}

void caller (void)
@{
  cce_location_t    L[1];
  handler_t         H;
  void *            P;

  H.handler.function = P_handler;

  if (cce_location(L)) @{
    cce_run_error_handlers_final(L);
  @} else @{
    P = constructor(L);
    H.pointer = P;
    cce_register_cleanup_handler(L, &H.handler);
    do_something_with(P);
    cce_run_cleanup_handlers(L);
  @}
@}
@end example

@c page
@node conditions
@chapter Exceptional condition descriptors


In the context of the @value{PACKAGE} framework, we represent exceptional conditions with a tree
hierarchy of data structures; this way it is possible to react to a raised exception by branching at
run--time according to the type of raised structure.

@menu
* conditions intro::            Introduction to condition objects.
* conditions descriptors::      Condition descriptor type.
* conditions objects::          Condition object type.
* conditions root::             Predefined root condition descriptor.
* conditions unknown::          Predefined unknown condition object.
* conditions unimplemented::    Predefined unimplemented condition
                                object.
* conditions invalid arg::      Predefined invalid argument conditions.
* conditions errno::            Predefined @code{errno} conditions.
* conditions custom::           Defining custom condition objects.
@end menu

@c page
@node conditions intro
@section Introduction to condition objects


The purpose of @value{PACKAGE}'s condition objects module is to allow us to write code like this:

@example
if (cce_location(L)) @{
  // handle the exceptional condition
  if (my_condition_is_alpha(cce_condition(L)))
    @{
      // react to exception "alpha"
    @}
  else if (my_condition_is_beta(cce_condition(L)))
    @{
      // react to exception "beta"
    @}
  else
    @{
      // default reaction to any exception
    @}
  cce_run_error_handlers_final(L);
@} else @{
  // do something useful
  cce_run_cleanup_handlers(L);
@}
@end example

@noindent
in which we use some, previously defined, conditional exception types @samp{alpha} and @samp{beta}.
From the point of view of our ability to react to an exception at run--time: a flexible situation is
the one in which the conditional exception types are organised in a tree hierarchy.  It allows us to
select the level of granularity we desire in the branching logic.

The tree hierarchy implemented by @value{PACKAGE} uses single inheritance; multiple inheritance
would be more general, but also more complex.

@c ------------------------------------------------------------------------

@subsubheading How the hierarchy is implemented

Exceptional condition objects are C language structures referencing a type descriptor, which is also
a C language structure.  Type descriptors are usually statically allocated and mostly have a
hard--coded initialisation.  Condition object instances are either dynamically allocated and
initialised or statically allocated with hard--coded initialisation.

Every type descriptor data structure encloses a data structure of type @objtype{cce_descriptor_t},
which must be its first field.  The instances of @objtype{cce_descriptor_t} hold the pointers that
define the tree hierarchy; every type descriptor can be referenced by multiple condition objects: it
can represent the type of multiple objects; every type descriptor has a single parent and can have
zero, one or more children.  Each pointer to @objtype{cce_descriptor_t} is a unique run--time value
identifying the type of condition objects.

Every exceptional condition object data structure encloses a data structure of type
@objtype{cce_condition_t}, which must be its first field.  The condition object holds a pointer to
the associated type descriptor.

The root of the tree is represented by the type descriptor @objtype{cce_descriptor_root_t} and
condition objects of descriptor have type @objtype{cce_condition_root_t}.  We can think of the root
structure types as follows:

@example
typedef struct cce_condition_root_t     cce_descriptor_root_t;
typedef struct cce_condition_root_t     cce_condition_root_t;

struct cce_descriptor_root_t @{
  cce_descriptor_t	descriptor;
@};

struct cce_condition_root_t @{
  cce_condition_t	condition;
@};

/* Pointer to the predefined root type descriptor. */
extern const cce_condition_root_t * const cce_condition_root_ptr;
@end example

We define a new condition object type, child of the root type, as follows (more code is needed for
full initialisation of data structures):

@example
typedef struct my_descriptor_error_t  my_descriptor_error_t;
typedef struct my_condition_error_t   my_condition_error_t;

struct my_descriptor_error_t @{
  cce_descriptor_t     descriptor;
  /* Put some custom fields here. */
@};

struct my_error_C_t @{
  cce_condition_root_t  root;
  /* Put some custom fields here. */
@};

my_descriptor_error_t my_error_descriptor;

void
initialisation_function (void)
@{
  cce_descriptor_set_root_parent(&my_descriptor_error.condition);
@}
@end example

@noindent
the field of type @objtype{cce_descriptor_t} is the first in its data structure; the field of type
@objtype{cce_condition_root_t} is the first in its data structure.  The initialisation function
links the new type descriptor to the root type descriptor.

In the following picture: the type descriptor @samp{alpha} is a child of the root descriptor; the
type descriptor @samp{beta} is a child of the type descriptor @samp{alpha}.  We can say that: a
condition object of type @samp{alpha} is also of type root; a condition object of type @samp{beta}
is also of type @samp{alpha} and of type root.

@example
 ---------------------------
| condition descriptor root |
 ---------------------------
              ^
              |
 ----------------------------       ------------------------
| condition descriptor alpha | <-- | condition object alpha |
 ----------------------------       ------------------------
              ^
              |
 ---------------------------        -----------------------
| condition descriptor beta | <--- | condition object beta |
 ---------------------------        -----------------------
@end example

The data types that represent such hierarchy look as follows:

@example
typedef struct my_descriptor_alpha_t my_descriptor_alpha_t;
typedef struct my_descriptor_beta_t  my_descriptor_beta_t;
typedef struct my_condition_alpha_t  my_condition_alpha_t;
typedef struct my_condition_beta_t   my_condition_beta_t;

/*** Descriptors types. ***/

struct my_descriptor_alpha_t @{
  cce_descriptor_t     condition;
@};

struct my_descriptor_beta_t @{
  cce_descriptor_t     condition;
@};

/*** Object types. ***/

struct my_condition_alpha_t @{
  cce_condition_root_t  root;
@};

struct my_condition_beta_t @{
  my_condition_alpha_t  alpha;
@};
@end example

@noindent
we can statically allocate and initialise the type descriptors as follows:

@example
my_descriptor_alpha_t my_descriptor_alpha = @{
  .parent = NULL
@};

my_descriptor_beta_t  my_descriptor_beta = @{
  .parent = &my_descriptor_alpha.condition
@};

void
initialisation_function (void)
@{
  cce_condition_set_root_parent(&my_descriptor_alpha.condition));
@}
@end example

@c page
@node conditions descriptors
@section Condition descriptor type


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftypefn {Function Prototype} void cce_condition_final_fun_t (cce_condition_t * @var{C})
Release all the dynamic resources associated to the fields of the condition object referenced by
@var{C}; leave untouched the condition object itself.
@end deftypefn


@deftypefn {Function Prototype} void cce_condition_delete_fun_t (cce_condition_t * @var{C})
Release the memory block referenced by @var{C}, if appropriate.  If the structure is allocated with
@cfunc{malloc}, the @code{delete} function can just be:

@example
void
my_condition_delete_stuff (my_condition_stuff_t * C)
@{
  free(C);
@}
@end example
@end deftypefn


@deftypefn {Function Prototype} {const char *} cce_condition_static_message_fun_t (const cce_condition_t * @var{C})
Return a statically allocated @asciiz{} string describing the exceptional condition @var{C}.  A
static message must always be defined; another client--defined function can build a dynamic and more
descriptive message.

For example, an instance of this function can be:

@example
const char *
my_condition_static_message_stuff (const my_condition_stuff_t * C)
@{
  return "error doing stuff";
@}
@end example
@end deftypefn


@deftp {Struct Typedef} cce_descriptor_t
Type of structures holding a table of function pointers to handle exceptional condition objects.  It
has the following fields:

@table @code
@item const cce_descriptor_t * parent
Pointer to the condition descriptor that is parent of this one in the tree hierarchy.  This pointer
is set to @cnull{} only for the root condition descriptor, @xref{conditions root, Predefined root
condition descriptor}.

@item cce_condition_final_fun_t * delete
Pointer to function releasing the condition object's memory block itself.  This pointer can be
@cnull{}, meaning that: the condition object is statically allocated.

@item cce_condition_final_fun_t * final
Pointer to function releasing all the dynamic resources associated to the fields in the condition
object.  This pointer can be @cnull{}, meaning that: there are no dynamic resources in the condition
object fields.

@item cce_condition_static_message_fun_t * static_message
Pointer to function returning a statically allocated @asciiz{} string describing the exceptional
condition.
@end table
@end deftp


@deftypefun bool cce_descriptor_child_and_ancestor (const cce_descriptor_t * @var{child}, const cce_descriptor_t * @var{ancestor})
Establish if two condition descriptors are child and ancestor.  Return @true{} if @var{child} is
equal to @var{ancestor} or @var{ancestor} is in the hierarchy of @var{child}'s ancestors; otherwise
return @false{}.
@end deftypefun


@deftypefn {Generic Macro} {cce_descriptor_t *} cce_descriptor (@var{X})
This generic macro dispatches its expansion according to its argument's type:

@itemize
@item
Given a pointer to condition object: retrieve the pointer to its descriptor and cast it to a pointer
to @objtype{cce_descriptor_t}.

@item
Given a pointer to condition descriptor: cast it to a pointer to @objtype{cce_descriptor_t}.
@end itemize

This generic macro performs compile--time type--checking so that the cast operation is applied only
on values of suitable types; we can apply this macro to pointers to all the types defined by
@value{PACKAGE} for which it makes sense.
@end deftypefn

@c page
@node conditions objects
@section Condition object type


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_condition_t
Type of structure representing an exceptional condition object.  It has the following public fields:

@table @code
@item const cce_descriptor_t * condition
Pointer to the condition descriptor associated to this condition object.
@end table
@end deftp


@deftypefun void cce_condition_init (cce_condition_t * @var{C}, const cce_descriptor_t * @var{D})
Initialise the core fields of an already allocated condition object.  The argument @var{D} must be a
pointer to the condition descriptor: it is stored in the condition object referenced by @var{C}.
This function is usually called from a type--specific constructor function.
@end deftypefun


@deftypefun void cce_condition_final (cce_condition_t * @var{C})
@strong{Usually we do not need to call this function directly; rather, we should use
@cfunc{cce_condition_delete}.}

Traverse, from leave to root, the hierarchy of descriptors for the condition object in @var{C} and
apply to @var{C} the @code{final} functions referenced by the descriptors' functions tables.  The
finalisation functions are applied from leave to root.
@end deftypefun


@deftypefun void cce_condition_delete (cce_condition_t * @var{C})
Apply @cfunc{cce_condition_final} to @var{C}; then apply to @var{C} the @code{delete} function
referenced by the descriptor's functions table.
@end deftypefun


@deftypefun {const char *} cce_condition_static_message (const cce_condition_t * @var{C})
Apply to @var{C} the @code{static_message} function referenced by its descriptor's functions
table.
@end deftypefun


@deftypefun bool cce_is_condition (const cce_condition_t * @var{C}, const cce_descriptor_t * @var{D})
Establish if a condition object is of a selected type.  Return @true{} if @var{C} is an instance of
type @var{D}, or an instance of a type that is ancestor of @var{D}; otherwise return @false{}.
@end deftypefun


@deftypefn {Generic Macro} {cce_condition_t *} cce_condition (@var{X})
This generic macro dispatches its expansion according to its argument's type:

@itemize
@item
Given a pointer to @objtype{cce_location_t}: retrieve a pointer to the associated condition object
and cast it to a pointer to @objtype{cce_condition_t}.

@item
Given a pointer to condition object: cast it to a pointer to @objtype{cce_condition_t}.
@end itemize

This generic macro performs compile--time type--checking so that the cast operation is applied only
on values of suitable types; we can apply this macro to pointers to all the types defined by
@value{PACKAGE} for which it makes sense.

This macro allows us to compare pointers without raising a warning:

@example
cce_condition_errno_t * A = ...;
cce_condition_t *       B = ...;

/* This raises a warning: */
A == B;

/* This does not raise a warning: */
cce_condition(A) == cce_condition(B);
@end example
@end deftypefn


The basic usage pattern of condition objects is as follows:

@example
cce_location_t      L[1];

if (cce_location(L)) @{
  fprintf(stderr, "log: %s\n", \
      cce_condition_static_message(cce_condition(L)));
  cce_run_error_handlers(L);
  cce_condition_delete(cce_condition(L));
@} else @{
  do_something();
  if (an_error_occurred()) @{
    cce_raise(L, select_condition_object());
  @}
  cce_run_cleanup_handlers(L);
@}
@end example

If we need to hand the condition object to an upper level location we can do it as follows:

@example
void
upper_function (void)
@{
  cce_location_t        L[1];

  if (cce_location(L)) @{
    fprintf(stderr, "log: %s\n", \
        cce_condition_static_message(cce_condition(L)));
    cce_run_error_handlers(L);
    cce_condition_delete(cce_condition(L));
  @} else @{
    lower_function(L);
    cce_run_cleanup_handlers(L);
  @}
@}

void
lower_function (cce_location_t * upper_L)
@{
  cce_location_t        L[1];

  if (cce_location(L)) @{
    cce_run_error_handlers(L);
    cce_raise(upper_L, cce_condition(L));
  @} else @{
    do_something();
    if (an_error_occurred()) @{
      cce_raise(L, select_condition_object());
    @}
   cce_run_cleanup_handlers(L);
  @}
@}
@end example

If we need to branch according to a condition object's type, we can do it as follows using wrappers
for @cfunc{cce_is_condition}:

@example
cce_location_t      L[1];

if (cce_location(L)) @{
  if (cce_condition_is_unknown(cce_condition(L)))
    @{
      do_something();
    @}
  else if (cce_condition_is_errno(cce_condition(L)))
    @{
      do_something();
    @}
  else
    @{
      do_something();
    @}
  cce_run_error_handlers(L);
  cce_condition_delete(cce_condition(L));
@} else @{
  do_something();
  if (an_exception_occurred()) @{
    cce_raise(L, select_condition_object());
  @}
  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node conditions root
@section Predefined root condition descriptor


The @dfn{root exceptional--condition descriptor} has the only purpose of being the root of the
condition descriptors tree; there should be no condition objects having this descriptor.  The
@emph{root} descriptor has @code{parent} field set to @cnull{}; this should be the only descriptor
with such a property.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_descriptor_root_t
Type of the exceptional condition descriptor representing the root of the conditions hierarchy tree.
This descriptor has a single instance built into the library.
@end deftp


@deftypefun void cce_descriptor_set_root_parent (cce_descriptor_t * @var{D})
Configure the descriptor @var{D} so that its parent is the unique @emph{root} condition descriptor.
@end deftypefun


@deftypefun bool cce_condition_is_root (const cce_condition_t * @var{C})
Return @true{} if the condition object @var{C} is derived from the @emph{root} condition type;
otherwise return @false{}.  With a correctly built conditions hierarchy: this function always
returns @true{}.
@end deftypefun


To define an exceptional condition type @code{my_descriptor_error_t} whose parent is the @emph{root}
condition, we must write initialisation code as follows:

@example
typedef struct my_descr_error_t  my_descr_error_t;

struct my_descr_error_t @{
  cce_descriptor_t     descriptor;
@};

static const char *
my_error_static_message (const cce_condition_t * C CCE_UNUSED)
@{
  return "my error message";
@}

my_descr_error_t my_descr_error_stru = @{
  .descriptor.parent          = NULL,
  .descriptor.delete          = NULL,
  .descriptor.final           = NULL,
  .descriptor.static_message  = my_error_static_message
@};

void
condition_descriptors_initialisation (void)
@{
  cce_descriptor_set_root_parent(&my_descr_error.descriptor);
@}
@end example

@noindent
and the function @cfunc{condition_descriptors_initialisation} must be called prior to using the
conditions system.

@c page
@node conditions unknown
@section Predefined unknown condition object


The @dfn{unknown exceptional--condition object} has the purpose of describing an exceptional
condition with unknown cause; it should be used only by:

@itemize
@item
The function @cfunc{cce_raise} when the condition object argument is set to @cnull{}.

@item
The function @cfunc{cce_retry}.
@end itemize

There should be only one @emph{unknown} condition object: the one predefined by @value{PACKAGE} and
built into the library as statically allocated structure.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_descriptor_unknown_t
Structure type representing the descriptor for @emph{unknown} condition objects.  This descriptor
has the @emph{root} descriptor as parent.
@end deftp


@deftp {Struct Typedef} cce_condition_unknown_t
Structure type representing an @emph{unknown} condition object.
@end deftp


@deftypefun {const cce_condition_t *} cce_condition_new_unknown (void)
Return a pointer to the statically allocated structure representing the single @emph{unknown}
condition object.
@end deftypefun


@deftypefn {Inline Function} bool cce_condition_is_unknown (const cce_condition_t * @var{C})
Return @true{} if @var{C} is an @emph{unknown} condition object; otherwise return @false{}.
@end deftypefn


@deftypefn {Generic Macro} {const cce_condition_unknown_t *} cce_condition_unknown (cce_location_t * @var{L})
@deftypefnx {Generic Macro} {const cce_condition_unknown_t *} cce_condition_unknown (cce_condition_t * @var{C})
@deftypefnx {Generic Macro} {const cce_condition_unknown_t *} cce_condition_unknown (cce_condition_unknown_t * @var{C})
@deftypefnx {Generic Macro} {const cce_condition_unknown_t *} cce_condition_unknown (const cce_condition_t * @var{C})
@deftypefnx {Generic Macro} {const cce_condition_unknown_t *} cce_condition_unknown (const cce_condition_unknown_t * @var{C})
This generic macro dispatches its expansion according to its argument's type.  Cast a pointer to a
pointer to @objtype{cce_condition_unknown_t}.

This macro performs compile--time type--checking so that the cast operation is applied only to
values of suitable types; we can apply this macro to pointers of all the types defined by
@value{PACKAGE} for which it makes sense.
@end deftypefn


@deftypevr {Dynamic Constant} {const cce_descriptor_unknown_t * const} cce_descriptor_unknown_ptr
Pointer to a statically allocated structure representing the @emph{unknown} condition descriptor for
the single @emph{unknown} condition object.  The parent of this descriptor is the root descriptor,
@ref{conditions root}.
@end deftypevr


@deftypevr {Dynamic Constant} {const cce_condition_unknown_t * const} cce_condition_unknown_ptr
Pointer to a statically allocated structure representing the @emph{unknown} condition object.
@end deftypevr

@c page
@node conditions unimplemented
@section Predefined unimplemented condition object


The @dfn{unimplemented exceptional--condition object} has the purpose of describing an exceptional
condition caused by attempting to use an unimplemented feature.  For example: attempting to call a
system function adapter for which the underlying function is not available on the current platform
(@pxref{syscalls}).

There should be only one @emph{unimplemented} condition object: the one predefined by
@value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_descriptor_unimplemented_t
Structure type representing the descriptor for @emph{unimplemented} condition objects.  This
descriptor has the @emph{root} descriptor as parent.
@end deftp


@deftp {Struct Typedef} cce_condition_unimplemented_t
Structure type representing an @emph{unimplemented} condition object.
@end deftp


@deftypefun {const cce_condition_t *} cce_condition_new_unimplemented (void)
Return a pointer to the statically allocated structure representing the single @emph{unimplemented}
condition object.
@end deftypefun


@deftypefun bool cce_is_condition_unimplemented (const cce_condition_t * @var{C})
Return @true{} if @var{C} is an @emph{unimplemented} condition object; otherwise return @false{}.
@end deftypefun


@deftypefn {Generic Macro} {const cce_condition_unimplemented_t *} cce_condition_unimplemented (cce_location_t * @var{L})
@deftypefnx {Generic Macro} {const cce_condition_unimplemented_t *} cce_condition_unimplemented (cce_condition_t * @var{C})
@deftypefnx {Generic Macro} {const cce_condition_unimplemented_t *} cce_condition_unimplemented (const cce_condition_t * @var{C})
This generic macro dispatches its expansion according to its argument's type.  Cast a pointer to
@objtype{cce_condition_unimplemented_t}.

This macro performs compile--time type--checking so that the cast operation is applied only to
values of suitable types; we can apply this macro to pointers of all the types defined by
@value{PACKAGE} for which it makes sense.
@end deftypefn


@deftypevr {Dynamic Constant} {const cce_descriptor_unimplemented_t * const} cce_descriptor_unimplemented_ptr
Pointer to a statically allocated structure representing the @emph{unimplemented} condition
descriptor for the single @emph{unimplemented} condition object.
@end deftypevr


@deftypevr {Dynamic Constant} {const cce_condition_unimplemented_t * const} cce_condition_unimplemented_ptr
Pointer to a statically allocated structure representing the @emph{unimplemented} condition object.
@end deftypevr

@c page
@node conditions invalid arg
@section Predefined invalid argument conditions


The @dfn{invalid argument exceptional--condition object} has the purpose of describing an
exceptional condition caused by a wrong function argument.  This condition object is meant to be
used to describe unexpected exceptions: we do not really expect the argument to be invalid, but we
want a fall--back just in case.

The function is meant to be used as follows:

@example
void
do_something (unsigned N)
@{
  cce_location_t        L[1];

  if (cce_location(L)) @{
    cce_run_error_handlers_final(L);
  @} else @{
    if (0 == N) @{
      cce_raise(L,
          cce_condition_new_invalid_argument(L, __func__, 1));
    @}
    cce_run_cleanup_handlers(L);
  @}
@}
@end example

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_descriptor_invalid_argument_t
Structure type representing the descriptor of the condition objects.  This descriptor has the
@emph{root} descriptor as parent.
@end deftp


@deftp {Struct Typedef} cce_condition_invalid_argument_t
Structure type representing the condition object.  It has the following public fields:

@table @code
@item const char * funcname
Pointer to a statically allocated @asciiz{} string representing the name of the function that raised
the exception.  It is usually generated with @code{__func__}.

@item unsigned index
One--based index of the offending argument.
@end table
@end deftp


@deftypefun {cce_condition_invalid_argument_t *} cce_condition_new_invalid_argument (cce_location_t * @var{L}, const char * @var{func}, unsigned @var{index})
Build and return a new condition object.  If building the object fails: raise an exception to the
location @var{L}.
@end deftypefun


@deftypefn {Inline Function} bool cce_condition_is_invalid_argument (const cce_condition_t * @var{C})
Return @true{} if @var{C} is a condition object of the specified type; otherwise return @false{}.
@end deftypefn


@deftypefn {Generic Macro} {const cce_condition_invalid_argument_t *} cce_condition_invalid_argument (cce_location_t * @var{L})
@deftypefnx {Generic Macro} {const cce_condition_invalid_argument_t *} cce_condition_invalid_argument (cce_condition_t * @var{C})
@deftypefnx {Generic Macro} {const cce_condition_invalid_argument_t *} cce_condition_invalid_argument (cce_condition_invalid_argument_t * @var{C})
@deftypefnx {Generic Macro} {const cce_condition_invalid_argument_t *} cce_condition_invalid_argument (const cce_condition_t * @var{C})
@deftypefnx {Generic Macro} {const cce_condition_invalid_argument_t *} cce_condition_invalid_argument (const cce_condition_invalid_argument_t * @var{C})
This generic macro dispatches its expansion according to its argument's type.  Cast a pointer to a
pointer to @objtype{cce_condition_invalid_argument_t}.

This macro performs compile--time type--checking so that the cast operation is applied only to
values of suitable types; we can apply this macro to pointers of all the types defined by
@value{PACKAGE} for which it makes sense.
@end deftypefn


@deftypevr {Dynamic Constant} {const cce_descriptor_invalid_argument_t * const} cce_descriptor_invalid_argument
Pointer to a statically allocated structure representing the condition descriptor.
@end deftypevr

@c page
@node conditions errno
@section Predefined @code{errno} conditions


The @dfn{errno exceptional--condition object} has the purpose of describing an exceptional condition
caused by a system function setting @code{errno}.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_descriptor_errno_t
Structure type representing the descriptor for @emph{errno} condition objects.  This descriptor has
the @emph{root} descriptor as parent.
@end deftp


@deftp {Struct Typedef} cce_condition_errno_t
Structure type representing an @emph{errno} exceptional condition object, signalled by a system
function by setting @code{errno} to a non--zero value.  It has the following public fields:

@table @code
@item int errnum
The value of @code{errno}.

@item const char * message
A statically allocated string describing the error.
@end table
@end deftp


@deftypefun {const cce_condition_errno_t *} cce_condition_new_errno (int @var{errnum})
Given the @code{errno} code @var{errnum}, return the pointer to the condition object associated to
it.

If @var{errnum} is zero: return a pointer to condition object representing a successful operation.
If @var{errnum} is not a valid @code{errno} code for the underlying platform: return a pointer to
condition object representing an invalid code.
@end deftypefun


@deftypefun {const cce_condition_errno_t *} cce_condition_new_errno_clear (void)
Consume the current value of @code{errno} and return the return value of
@cfunc{cce_condition_new_errno} applied to it.  Before returning: @code{errno} is reset to zero.
@end deftypefun


@deftypefn {Inline Function} bool cce_condition_is_errno (const cce_condition_t * @var{C})
Return @true{} if @var{C} is a condition object of type @emph{errno}; otherwise return @false{}.
@end deftypefn


@deftypefn {Generic Macro} {const cce_condition_errno_t *} cce_condition_errno (cce_location_t * @var{L})
@deftypefnx {Generic Macro} {const cce_condition_errno_t *} cce_condition_errno (cce_condition_t * @var{C})
@deftypefnx {Generic Macro} {const cce_condition_errno_t *} cce_condition_errno (cce_condition_errno_t * @var{C})
@deftypefnx {Generic Macro} {const cce_condition_errno_t *} cce_condition_errno (const cce_condition_t * @var{C})
@deftypefnx {Generic Macro} {const cce_condition_errno_t *} cce_condition_errno (const cce_condition_errno_t * @var{C})
This generic macro dispatches its expansion according to its argument's type.  Cast a pointer to a
pointer to @objtype{cce_condition_errno_t}.

This macro performs compile--time type--checking so that the cast operation is applied only to
values of suitable types; we can apply this macro to pointers of all the types defined by
@value{PACKAGE} for which it makes sense.
@end deftypefn


@deftypevr {Dynamic Constant} {const cce_descriptor_errno_t * const} cce_descriptor_errno_ptr
Pointer to a statically allocated structure representing the condition descriptor of all the
@emph{errno} condition objects.
@end deftypevr

@c page
@node conditions custom
@section Defining custom condition objects


Let's say we want to define the following condition descriptors hierarchy:

@example
 ------       -------       ------       -------
| root | <-- | alpha | <-- | beta | <-- | gamma |
 ------       -------       ------       -------
@end example

@noindent
where the condition objects of type @emph{alpha}, @emph{beta} and @emph{gamma} have custom data
structures.  As client code example: we show a possible implementation.

We start with this preamble:

@example
#include <ccexceptions.h>
#include <stdlib.h>
#include <assert.h>
@end example

The exceptional condition @emph{alpha} has @emph{root} as parent type; we define it as follows:

@smallexample
typedef struct descriptor_alpha_t @{
  cce_descriptor_t      descriptor;
@} descriptor_alpha_t;

typedef struct condition_alpha_t @{
  cce_condition_root_t  root;
  int                   alpha;
@} condition_alpha_t;

cce_condition_t * condition_new_alpha (cce_location_t * L, int alpha);
void condition_init_alpha (condition_alpha_t * C, int alpha);
bool condition_is_alpha (const cce_condition_t * condition);

static void condition_delete_alpha (cce_condition_t * C);
static void condition_final_alpha (cce_condition_t * C);
static const char * condition_static_message_alpha (const cce_condition_t * C);

/* Instance of condition descriptor.   The "parent" field is initialised
   to  NULL   here  and  reinitialised   to  the  "root"  later   by  an
   initialisation function. */
static descriptor_alpha_t descriptor_alpha = @{
  .descriptor.parent            = NULL,
  .descriptor.delete            = condition_delete_alpha,
  .descriptor.final             = condition_final_alpha,
  .descriptor.static_message    = condition_static_message_alpha
@};

cce_condition_t *
condition_new_alpha (cce_location_t * L, int alpha)
/* Allocate a condition object and initialise it. */
@{
  condition_alpha_t *   C = cce_sys_malloc(L, sizeof(condition_alpha_t));
  cce_condition_init((cce_condition_t *)C, &descriptor_alpha.descriptor);
  condition_init_alpha(C, alpha);
  return (cce_condition_t *) C;
@}

void
condition_delete_alpha (cce_condition_t * C)
/* Release the condition object memory. */
@{
  fprintf(stderr, "%s\n\n", __func__);
  free(C);
@}

void
condition_init_alpha (condition_alpha_t * C, int alpha)
/* Initialise an already allocated condition object. */
@{
  C->alpha = alpha;
@}

void
condition_final_alpha (cce_condition_t * C CCE_UNUSED)
/* Finalise a condition object; do not release memory. */
@{
  fprintf(stderr, "%s\n", __func__);
@}

static const char *
condition_static_message_alpha (const cce_condition_t * C CCE_UNUSED)
@{
  return "exceptional condition A";
@}

bool
condition_is_alpha (const cce_condition_t * condition)
@{
  return cce_is_condition(condition, &descriptor_alpha.descriptor);
@}

#define condition_alpha(S)                                              \
  _Generic((S),                                                         \
           cce_condition_t              *: (condition_alpha_t *)(S),    \
           condition_alpha_t            *: (condition_alpha_t *)(S),    \
           condition_beta_t             *: (condition_alpha_t *)(S),    \
           condition_gamma_t            *: (condition_alpha_t *)(S),    \
           const cce_condition_t        *: (condition_alpha_t *)(S),    \
           const condition_alpha_t      *: (condition_alpha_t *)(S),    \
           const condition_beta_t       *: (condition_alpha_t *)(S),    \
           const condition_gamma_t      *: (condition_alpha_t *)(S))
@end smallexample

For this type we need the following initialisation code.

@example
cce_descriptor_set_root_parent(&descriptor_alpha.descriptor);
@end example

@c ------------------------------------------------------------------------

The exceptional condition @emph{beta} has @emph{alpha} as parent type; we define it as follows:

@smallexample
typedef struct descriptor_beta_t @{
  cce_descriptor_t      descriptor;
@} descriptor_beta_t;

typedef struct condition_beta_t @{
  condition_alpha_t     alpha;
  int                   beta;
@} condition_beta_t;

cce_condition_t * condition_new_beta (cce_location_t * L, int alpha, int beta);
void condition_init_beta (condition_beta_t * C, int alpha, int beta);
bool condition_is_beta (const cce_condition_t * condition);

static void condition_delete_beta  (cce_condition_t * C);
static void condition_final_beta (cce_condition_t * C);
static const char * condition_static_message_beta (const cce_condition_t * C);

/* Instance of condition descriptor.   The "parent" field is initialised
   to  NULL   here  and  reinitialised   to  the  "root"  later   by  an
   initialisation function. */
static descriptor_beta_t descriptor_beta = @{
  .descriptor.parent            = &descriptor_alpha.descriptor,
  .descriptor.delete            = condition_delete_beta,
  .descriptor.final             = condition_final_beta,
  .descriptor.static_message    = condition_static_message_beta
@};

cce_condition_t *
condition_new_beta (cce_location_t * L, int alpha, int beta)
/* Allocate a condition object and initialise it. */
@{
  condition_beta_t *    C = cce_sys_malloc(L, sizeof(condition_beta_t));
  cce_condition_init((cce_condition_t *)C, &descriptor_beta.descriptor);
  condition_init_beta(C, alpha, beta);
  return (cce_condition_t *) C;
@}

void
condition_delete_beta (cce_condition_t * C)
/* Release the condition object memory. */
@{
  fprintf(stderr, "%s\n\n", __func__);
  free(C);
@}

void
condition_init_beta (condition_beta_t * C, int alpha, int beta)
/* Initialise an already allocated condition object. */
@{
  condition_init_alpha(&(C->alpha),  alpha);
  C->beta = beta;
@}

void
condition_final_beta (cce_condition_t * C CCE_UNUSED)
/* Finalise a condition object; do not release memory. */
@{
  fprintf(stderr, "%s\n", __func__);
@}

static const char *
condition_static_message_beta (const cce_condition_t * C CCE_UNUSED)
@{
  return "exceptional condition A";
@}

bool
condition_is_beta (const cce_condition_t * condition)
@{
  return cce_is_condition(condition, &descriptor_beta.descriptor);
@}

#define condition_beta(S)                                               \
  _Generic((S),                                                         \
           cce_condition_t              *: (condition_beta_t *)(S),     \
           condition_alpha_t            *: (condition_beta_t *)(S),     \
           condition_beta_t             *: (condition_beta_t *)(S),     \
           condition_gamma_t            *: (condition_beta_t *)(S),     \
           const cce_condition_t        *: (condition_beta_t *)(S),     \
           const condition_alpha_t      *: (condition_beta_t *)(S),     \
           const condition_beta_t       *: (condition_beta_t *)(S),     \
           const condition_gamma_t      *: (condition_beta_t *)(S))
@end smallexample

@c ------------------------------------------------------------------------

The exceptional condition @emph{gamma} has @emph{beta} as parent type; we define it as follows:

@smallexample
typedef struct descriptor_gamma_t @{
  cce_descriptor_t      descriptor;
@} descriptor_gamma_t;

typedef struct condition_gamma_t @{
  condition_beta_t      beta;
  int                   gamma;
@} condition_gamma_t;

cce_condition_t * condition_new_gamma (cce_location_t * L, int alpha, int beta, int gamma);
void condition_init_gamma (condition_gamma_t * C, int alpha, int beta, int gamma);
bool condition_is_gamma (const cce_condition_t * condition);

static void condition_delete_gamma  (cce_condition_t * C);
static void condition_final_gamma (cce_condition_t * C);
static const char * condition_static_message_gamma (const cce_condition_t * C);

/* Instance of condition descriptor.   The "parent" field is initialised
   to  NULL   here  and  reinitialised   to  the  "root"  later   by  an
   initialisation function. */
static descriptor_gamma_t descriptor_gamma = @{
  .descriptor.parent            = &descriptor_beta.descriptor,
  .descriptor.delete            = condition_delete_gamma,
  .descriptor.final             = condition_final_gamma,
  .descriptor.static_message    = condition_static_message_gamma
@};

cce_condition_t *
condition_new_gamma (cce_location_t * L, int alpha, int beta, int gamma)
/* Allocate a condition object and initialise it. */
@{
  condition_gamma_t *   C = cce_sys_malloc(L, sizeof(condition_gamma_t));
  cce_condition_init((cce_condition_t *)C, &descriptor_gamma.descriptor);
  condition_init_gamma(C, alpha, beta, gamma);
  return (cce_condition_t *) C;
@}

void
condition_delete_gamma (cce_condition_t * C)
/* Release the condition object memory. */
@{
  fprintf(stderr, "%s\n\n", __func__);
  free(C);
@}

void
condition_init_gamma (condition_gamma_t * C, int alpha, int beta, int gamma)
/* Initialise an already allocated condition object. */
@{
  condition_init_beta(&(C->beta), alpha, beta);
  C->gamma = gamma;
@}

void
condition_final_gamma (cce_condition_t * C CCE_UNUSED)
/* Finalise a condition object; do not release memory. */
@{
  fprintf(stderr, "%s\n", __func__);
@}

static const char *
condition_static_message_gamma (const cce_condition_t * C CCE_UNUSED)
@{
  return "exceptional condition A";
@}

bool
condition_is_gamma (const cce_condition_t * condition)
@{
  return cce_is_condition(condition, &descriptor_gamma.descriptor);
@}

#define condition_gamma(S)                                              \
  _Generic((S),                                                         \
           cce_condition_t              *: (condition_gamma_t *)(S),    \
           condition_alpha_t            *: (condition_gamma_t *)(S),    \
           condition_beta_t             *: (condition_gamma_t *)(S),    \
           condition_gamma_t            *: (condition_gamma_t *)(S),    \
           const cce_condition_t        *: (condition_gamma_t *)(S),    \
           const condition_alpha_t      *: (condition_gamma_t *)(S),    \
           const condition_beta_t       *: (condition_gamma_t *)(S),    \
           const condition_gamma_t      *: (condition_gamma_t *)(S))
@end smallexample

@c ------------------------------------------------------------------------

Now we can use the code as in the following example:

@smallexample
@{
  cce_location_t        L[1];
  int                   flag;

  if (cce_location(L)) @{
    if (condition_is_gamma(cce_condition(L))) @{
      condition_gamma_t * C = condition_gamma(cce_condition(L));
      flag = C->gamma;
    @} else if (condition_is_beta(cce_condition(L))) @{
      condition_beta_t  * C = condition_beta(cce_condition(L));
      flag = C->beta;
    @} else if (condition_is_alpha(cce_condition(L))) @{
      condition_alpha_t * C = condition_alpha(cce_condition(L));
      flag = C->alpha;
    @} else @{
      flag = 0;
    @}
    cce_run_error_handlers_final(L);
  @} else @{
    cce_raise(L, condition_new_beta(L, 1, 2));
    cce_run_cleanup_handlers(L);
  @}
@}
@end smallexample

@c page
@node syscalls
@chapter System call adapters


@value{PACKAGE} defines function wrappers for the most common @posix{}, @gnu{} C Library and Linux
system calls.  Each wrapper accepts a pointer to @objtype{cce_location_t} as argument and, in case
of error, it will perform a non--local exit by jumping to the selected location.

The wrapper functions accept the same arguments of the system call and return the same return value
of the system call (if it completes successfully).

All the wrappers reset @code{errno} to zero before performing the system call and reset it to zero
before returning.  In case of error: the raised exceptional condition objects are of type
@objtype{cce_condition_errno_t}.

The library assumes to run on a @posix{} system, so the @posix{} system calls are available by
default.  The @gnu{} C Library and Linux calls are available only if the package was configured
with, respectively, @option{--enable-glibc} and @option{--enable-linux}.  If a system call is not
available: the associated wrapper will raise an exception of type
@objtype{cce_condition_unimplemented_t}.

@menu
* syscalls alloc::              Memory allocation.
* syscalls mlock::              Locking memory pages.
* syscalls io::                 Input/output system calls.
* syscalls mmap::               Memory mapping system calls.
* syscalls fs::                 File system system calls.
* syscalls sockets::            Socket system calls.
* syscalls process::            Process system calls.
@end menu

@c page
@node syscalls alloc
@section Memory allocation


The following symbols are defined in the header file @file{ccexceptions.h}.


@deftypefun {void *} cce_sys_malloc (cce_location_t * @var{L}, size_t @var{size})
Wrapper for @cfunc{malloc}.  This function never returns @cnull{}.
@end deftypefun


@deftypefun {void *} cce_sys_realloc (cce_location_t * @var{L}, void * @var{ptr}, size_t @var{newsize})
Wrapper for @cfunc{realloc}.  This function never returns @cnull{}.
@end deftypefun


@deftypefun {void *} cce_sys_calloc (cce_location_t * @var{L}, size_t @var{count}, size_t @var{eltsize})
Wrapper for @cfunc{calloc}.  This function never returns @cnull{}.
@end deftypefun

@c page
@node syscalls mlock
@section Locking memory pages


The following symbols are defined in the header file @file{ccexceptions-system.h}.


@deftypefun void cce_sys_mlock (cce_location_t * L, const void * addr, size_t len)
Wrapper for @cfunc{mlock}.
@end deftypefun


@deftypefun void cce_sys_munlock (cce_location_t * L, const void * addr, size_t len)
Wrapper for @cfunc{munlock}.
@end deftypefun


@deftypefun void cce_sys_mlockall (cce_location_t * L, int flags)
Wrapper for @cfunc{mlockall}.
@end deftypefun


@deftypefun void cce_sys_munlockall (cce_location_t * L)
Wrapper for @cfunc{munlockall}.
@end deftypefun

@c page
@node syscalls io
@section Input/output system calls


The following symbols are defined in the header file @file{ccexceptions-system.h}.


@deftypefun int cce_sys_open (cce_location_t * @var{L}, const char * @var{filename}, int @var{flags}, mode_t @var{mode})
Wrapper for @cfunc{open}.
@end deftypefun


@deftypefun int cce_sys_openat (cce_location_t * @var{L}, int @var{dirfd}, const char * @var{filename}, int @var{flags}, mode_t @var{mode})
Wrapper for @cfunc{openat}.
@end deftypefun


@deftypefun int cce_sys_close (cce_location_t * @var{L}, int @var{filedes})
Wrapper for @cfunc{close}.
@end deftypefun


@deftypefun size_t cce_sys_read (cce_location_t * @var{L}, int @var{filedes}, void * @var{buffer}, size_t @var{size})
Wrapper for @cfunc{read}.  Notice the return value of type @objtype{size_t}: the negative values
returned by @cfunc{read} are consumed by this function, so the return value is an unsigned integer.
@end deftypefun


@deftypefun size_t cce_sys_pread (cce_location_t * @var{L}, int @var{filedes}, void * @var{buffer}, size_t @var{size}, off_t @var{offset})
Wrapper for @cfunc{pread}.  Notice the return value of type @objtype{size_t}: the negative values
returned by @cfunc{pread} are consumed by this function, so the return value is an unsigned integer.
@end deftypefun


@deftypefun size_t cce_sys_write (cce_location_t * @var{L}, int @var{filedes}, const void * @var{buffer}, size_t @var{size})
Wrapper for @cfunc{write}.  Notice the return value of type @objtype{size_t}: the negative values
returned by @cfunc{write} are consumed by this function, so the return value is an unsigned integer.
@end deftypefun


@deftypefun size_t cce_sys_pwrite (cce_location_t * @var{L}, int @var{filedes}, const void * @var{buffer}, size_t @var{size}, off_t @var{offset})
Wrapper for @cfunc{pwrite}.  Notice the return value of type @objtype{size_t}: the negative values
returned by @cfunc{pwrite} are consumed by this function, so the return value is an unsigned
integer.
@end deftypefun


@deftypefun off_t cce_sys_lseek (cce_location_t * @var{L}, int @var{filedes}, off_t @var{offset}, int @var{whence})
Wrapper for @cfunc{lseek}.
@end deftypefun


@deftypefun size_t cce_sys_readv (cce_location_t * @var{L}, int @var{filedes}, const struct iovec * @var{vector}, int @var{count})
Wrapper for @cfunc{readv}.  Notice the return value of type @objtype{size_t}: the negative values
returned by @cfunc{readv} are consumed by this function, so the return value is an unsigned integer.
@end deftypefun


@deftypefun size_t cce_sys_writev (cce_location_t * @var{L}, int @var{filedes}, const struct iovec * @var{vector}, int @var{count})
Wrapper for @cfunc{writev}.  Notice the return value of type @objtype{size_t}: the negative values
returned by @cfunc{writev} are consumed by this function, so the return value is an unsigned
integer.
@end deftypefun


@deftypefun int cce_sys_select (cce_location_t * @var{L}, int @var{nfds}, fd_set * @var{read_fds}, fd_set * @var{write_fds}, fd_set * @var{except_fds}, struct timeval * @var{timeout})
Wrapper for @cfunc{select}.
@end deftypefun


@deftypefun int cce_sys_dup (cce_location_t * @var{L}, int @var{old})
Wrapper for @cfunc{dup}.
@end deftypefun


@deftypefun int cce_sys_dup2 (cce_location_t * @var{L}, int @var{old}, int @var{new})
Wrapper for @cfunc{dup2}.
@end deftypefun


@deftypefun void cce_sys_pipe (cce_location_t * @var{L}, int @var{pipefd}[2])
Wrapper for @cfunc{pipe}.
@end deftypefun


@deftypefun void cce_sys_mkfifo (cce_location_t * @var{L}, const char * @var{pathname}, mode_t @var{mode})
Wrapper for @cfunc{mkfifo}.
@end deftypefun

@c page
@node syscalls mmap
@section Memory mapping system calls


The following symbols are defined in the header file @file{ccexceptions-system.h}.


@deftypefun {void *} cce_sys_mmap (cce_location_t * @var{L}, void * @var{address}, size_t @var{length}, int @var{protect}, int @var{flags}, int @var{filedes}, off_t @var{offset})
Wrapper for @cfunc{mmap}.
@end deftypefun


@deftypefun int cce_sys_munmap (cce_location_t * @var{L}, void * @var{addr}, size_t @var{length})
Wrapper for @cfunc{munmap}.
@end deftypefun


@deftypefun int cce_sys_msync (cce_location_t * @var{L}, void * @var{address}, size_t @var{length}, int @var{flags})
Wrapper for @cfunc{msync}.
@end deftypefun


@deftypefun int cce_sys_mprotect (cce_location_t * @var{L}, void * @var{addr}, size_t @var{len}, int @var{prot})
Wrapper for @cfunc{mprotect}.
@end deftypefun


@deftypefun {void *} cce_sys_mremap (cce_location_t * @var{L}, void * @var{address}, size_t @var{length}, size_t @var{new_length}, int @var{flag})
Wrapper for @cfunc{mremap}.

@quotation
@strong{NOTE}  This function is implemented by the @gnu{} C Library.
@end quotation
@end deftypefun


@deftypefun void cce_sys_madvise (cce_location_t * @var{L}, void * @var{address}, size_t @var{length}, int @var{advice})
Wrapper for @cfunc{madvise}.

@quotation
@strong{NOTE}  This function is implemented by the @gnu{} C Library.
@end quotation
@end deftypefun

@c page
@node syscalls fs
@section File system system calls


The following symbols are defined in the header file @file{ccexceptions-system.h}.


@subsubheading Current working directory


@deftypefun void cce_sys_getcwd (cce_location_t * @var{L}, char * @var{buffer}, size_t @var{size})
Wrapper for @cfunc{getcwd}.
@end deftypefun


@deftypefun void cce_sys_chdir (cce_location_t * @var{L}, const char * @var{pathname})
Wrapper for @cfunc{chdir}.
@end deftypefun


@deftypefun void cce_sys_fchdir (cce_location_t * @var{L}, int @var{dirfd})
Wrapper for @cfunc{fchdir}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Reading directory entries


@deftypefun {DIR *} cce_sys_opendir (cce_location_t * @var{L}, const char * @var{pathname})
Wrapper for @cfunc{opendir}.
@end deftypefun


@deftypefun {DIR *} cce_sys_fdopendir (cce_location_t * @var{L}, int @var{dirfd})
Wrapper for @cfunc{fdopendir}.
@end deftypefun


@deftypefun {struct dirent *} cce_sys_readdir (cce_location_t * @var{L}, DIR * @var{dirstream})
Wrapper for @cfunc{readdir}.
@end deftypefun


@deftypefun void cce_sys_closedir (cce_location_t * @var{L}, DIR * @var{dirstream})
Wrapper for @cfunc{closedir}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Making and removing directories


@deftypefun void cce_sys_mkdir (cce_location_t * @var{L}, const char * @var{pathname}, mode_t @var{mode})
Wrapper for @cfunc{mkdir}.
@end deftypefun


@deftypefun void cce_sys_rmdir (cce_location_t * @var{L}, const char * @var{pathname})
Wrapper for @cfunc{rmdir}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Hard and symbolic links


@deftypefun void cce_sys_link (cce_location_t * @var{L}, const char * @var{oldname}, const char * @var{newname})
Wrapper for @cfunc{link}.
@end deftypefun


@deftypefun void cce_sys_linkat (cce_location_t * @var{L}, int @var{olddirfd}, const char * @var{oldname}, int @var{newdirfd}, const char * @var{newname}, int @var{flags})
Wrapper for @cfunc{linkat}.
@end deftypefun


@deftypefun void cce_sys_symlink (cce_location_t * @var{L}, const char * @var{oldname}, const char * @var{newname})
Wrapper for @cfunc{symlink}.
@end deftypefun


@deftypefun void cce_sys_symlinkat (cce_location_t * @var{L}, const char * @var{oldname}, int @var{newdirfd}, const char * @var{newname})
Wrapper for @cfunc{symlinkat}.
@end deftypefun


@deftypefun size_t cce_sys_readlink (cce_location_t * @var{L}, const char * @var{filename}, char * @var{buffer}, size_t @var{size})
Wrapper for @cfunc{readlink}.  Notice the return value of type @objtype{size_t}, rather than the
original @objtype{ssize_t}: the wrapper function returns a non--negative integer because the error
conditions cause a non--local exit.
@end deftypefun


@deftypefun size_t cce_sys_readlinkat (cce_location_t * @var{L}, int @var{dirfd}, const char * @var{filename}, char * @var{buffer}, size_t @var{size})
Wrapper for @cfunc{readlinkat}.  Notice the return value of type @objtype{size_t}, rather than the
original @objtype{ssize_t}: the wrapper function returns a non--negative integer because the error
conditions cause a non--local exit.
@end deftypefun


@deftypefun {char *} cce_sys_realpath (cce_location_t * @var{L}, const char * @var{pathname}, char * @var{resolved_path})
Wrapper for @cfunc{realpath}.  Notice that this function never returns @cnull{}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Temporary files and directories


@deftypefun int cce_sys_mkstemp (cce_location_t * @var{L}, char * @var{template})
Wrapper for @cfunc{mkstemp}.  Remember that this call will mutate @var{template}.
@end deftypefun


@deftypefun {char *} cce_sys_mkdtemp (cce_location_t * @var{L}, char * @var{template})
Wrapper for @cfunc{mkdtemp}.  This function never returns @cnull{}.  Remember that this call will
mutate @var{template}.

@quotation
@strong{NOTE} This function is implemented by the @gnu{} C Library.  The feature is available only
if the package is configured with @option{--enable-glibc}; otherwise the function will raise an
exception with condition object of type @objtype{cce_unimplemented_C_t}.
@end quotation
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Removing files


@deftypefun void cce_sys_unlink (cce_location_t * @var{L}, const char * @var{filename})
Wrapper for @cfunc{unlink}.
@end deftypefun


@deftypefun void cce_sys_unlinkat (cce_location_t * @var{L}, int @var{dirfd}, const char * @var{filename}, int @var{flags})
Wrapper for @cfunc{unlinkat}.
@end deftypefun


@deftypefun void cce_sys_remove (cce_location_t * @var{L}, const char * @var{pathname})
Wrapper for @cfunc{remove}.  This function removes both files and empty directories.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Renaming files


@deftypefun void cce_sys_rename (cce_location_t * @var{L}, const char * @var{oldname}, const char * @var{newname})
Wrapper for @cfunc{rename}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Inspecting the file system


@deftypefun void cce_sys_stat (cce_location_t * @var{L}, const char * @var{pathname}, struct stat * @var{buf})
Wrapper for @cfunc{stat}.
@end deftypefun


@deftypefun void cce_sys_fstat (cce_location_t * @var{L}, int @var{fd}, struct stat * @var{buf})
Wrapper for @cfunc{fstat}.
@end deftypefun


@deftypefun void cce_sys_lstat (cce_location_t * @var{L}, const char * @var{pathname}, struct stat * @var{buf})
Wrapper for @cfunc{lstat}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading File system attributes


@deftypefun void cce_sys_chown (cce_location_t * @var{L}, const char * @var{pathname}, uid_t @var{owner}, gid_t @var{group})
Wrapper for @cfunc{chown}.
@end deftypefun


@deftypefun void cce_sys_fchown (cce_location_t * @var{L}, int @var{filedes}, uid_t @var{owner}, gid_t @var{group})
Wrapper for @cfunc{fchown}.
@end deftypefun


@deftypefun void cce_sys_lchown (cce_location_t * @var{L}, const char * @var{pathname}, uid_t @var{owner}, gid_t @var{group})
Wrapper for @cfunc{lchown}.
@end deftypefun


@deftypefun void cce_sys_fchownat (cce_location_t * @var{L}, int @var{dirfd}, const char * @var{pathname}, uid_t @var{owner}, gid_t @var{group}, int @var{flags})
Wrapper for @cfunc{fchownat}.
@end deftypefun


@deftypefun void cce_sys_chmod (cce_location_t * @var{L}, const char * @var{pathname}, mode_t @var{mode})
Wrapper for @cfunc{chmod}.
@end deftypefun


@deftypefun void cce_sys_fchmod (cce_location_t * @var{L}, int @var{filedes}, mode_t @var{mode})
Wrapper for @cfunc{fchmod}.
@end deftypefun


@deftypefun void cce_sys_fchmodat (cce_location_t * @var{L}, int @var{dirfd}, const char * @var{pathname}, mode_t @var{mode}, int @var{flags})
Wrapper for @cfunc{fchmodat}.
@end deftypefun


@deftypefun int cce_sys_access (cce_location_t * @var{L}, const char * @var{pathname}, int @var{how})
Wrapper for @cfunc{access}.  The return value is @samp{0} if access is denied; the return value is
@samp{-1} if access is granted.
@end deftypefun


@deftypefun int cce_sys_faccessat (cce_location_t * @var{L}, int @var{dirfd}, const char * @var{pathname}, int @var{how}, int @var{flags})
Wrapper for @cfunc{faccessat}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading File times


@deftypefun void cce_sys_utime (cce_location_t * @var{L}, const char * @var{pathname}, const struct utimbuf * @var{times})
Wrapper for @cfunc{utime}.
@end deftypefun


@deftypefun void cce_sys_utimes (cce_location_t * @var{L}, const char * @var{pathname}, const struct timeval @var{TVP} [2])
Wrapper for @cfunc{utimes}.
@end deftypefun


@deftypefun void cce_sys_lutimes (cce_location_t * @var{L}, const char * @var{pathname}, const struct timeval @var{TVP} [2])
Wrapper for @cfunc{lutimes}.
@end deftypefun


@deftypefun void cce_sys_futimes (cce_location_t * @var{L}, int @var{filedes}, const struct timeval @var{TVP} [2])
Wrapper for @cfunc{futimes}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Truncating files


@deftypefun void cce_sys_truncate (cce_location_t * @var{L}, const char * @var{pathname}, off_t @var{length})
Wrapper for @cfunc{truncate}.
@end deftypefun


@deftypefun void cce_sys_ftruncate (cce_location_t * @var{L}, int @var{filedes}, off_t @var{length})
Wrapper for @cfunc{ftruncate}.
@end deftypefun


@c page
@node syscalls sockets
@section Socket system calls


The following symbols are defined in the header file @file{ccexceptions-networking.h}.


@deftypefun void cce_sys_bind (cce_location_t * @var{L}, int @var{socket}, struct sockaddr * @var{addr}, socklen_t @var{length})
Wrapper for @cfunc{bind}.
@end deftypefun


@deftypefun void cce_sys_getsockname (cce_location_t * @var{L}, int @var{socket}, struct sockaddr * @var{addr}, socklen_t * @var{length_ptr})
Wrapper for @cfunc{getsockname}.
@end deftypefun


@deftypefun void cce_sys_inet_aton (cce_location_t * @var{L}, const char * @var{name}, struct in_addr * @var{addr})
Wrapper for @cfunc{inet_aton}.
@end deftypefun


@deftypefun in_addr_t cce_sys_inet_network (cce_location_t * @var{L}, const char * @var{name})
Wrapper for @cfunc{inet_network}.
@end deftypefun


@deftypefun int cce_sys_socket (cce_location_t * @var{L}, int @var{namespace}, int @var{style}, int @var{protocol})
Wrapper for @cfunc{socket}.
@end deftypefun


@deftypefun void cce_sys_shutdown (cce_location_t * @var{L}, int @var{socket}, int @var{how})
Wrapper for @cfunc{shutdown}.
@end deftypefun


@deftypefun void cce_sys_socketpair (cce_location_t * @var{L}, int @var{namespace}, int @var{style}, int @var{protocol}, int @var{filedes}[2])
Wrapper for @cfunc{socketpair}.
@end deftypefun


@deftypefun void cce_sys_connect (cce_location_t * @var{L}, int @var{socket}, struct sockaddr * @var{addr}, socklen_t @var{length})
Wrapper for @cfunc{connect}.
@end deftypefun


@deftypefun void cce_sys_listen (cce_location_t * @var{L}, int @var{socket}, int @var{N})
Wrapper for @cfunc{listen}.
@end deftypefun


@deftypefun int cce_sys_accept (cce_location_t * @var{L}, int @var{socket}, struct sockaddr * @var{addr}, socklen_t * @var{length_ptr})
Wrapper for @cfunc{accept}.
@end deftypefun


@deftypefun void cce_sys_getpeername (cce_location_t * @var{L}, int @var{socket}, struct sockaddr * @var{addr}, socklen_t * @var{length}_ptr)
Wrapper for @cfunc{getpeername}.
@end deftypefun


@deftypefun size_t cce_sys_send (cce_location_t * @var{L}, int @var{socket}, const void * @var{buffer}, size_t @var{size}, int @var{flags})
Wrapper for @cfunc{send}.
@end deftypefun


@deftypefun size_t cce_sys_recv (cce_location_t * @var{L}, int @var{socket}, void * @var{buffer}, size_t @var{size}, int @var{flags})
Wrapper for @cfunc{recv}.
@end deftypefun


@deftypefun size_t cce_sys_sendto (cce_location_t * @var{L}, int @var{socket}, const void * @var{buffer}, size_t @var{size}, int @var{flags}, struct sockaddr * @var{addr}, socklen_t @var{length})
Wrapper for @cfunc{sendto}.
@end deftypefun


@deftypefun size_t cce_sys_recvfrom (cce_location_t * @var{L}, int @var{socket}, void * @var{buffer}, size_t @var{size}, int @var{flags}, struct sockaddr * @var{addr}, socklen_t * @var{length_ptr})
Wrapper for @cfunc{recvfrom}.
@end deftypefun


@deftypefun void cce_sys_getsockopt (cce_location_t * @var{L}, int @var{socket}, int @var{level}, int @var{optname}, void * @var{optval}, socklen_t * @var{optlen_ptr})
Wrapper for @cfunc{getsockopt}.
@end deftypefun


@deftypefun void cce_sys_setsockopt (cce_location_t * @var{L}, int @var{socket}, int @var{level}, int @var{optname}, const void * @var{optval}, socklen_t @var{optlen})
Wrapper for @cfunc{setsockopt}.
@end deftypefun

@c page
@node syscalls process
@section Process system calls


The following symbols are defined in the header file @file{ccexceptions-system.h}.


@deftypefun int cce_sys_system (cce_location_t * @var{L}, const char * @var{command})
Wrapper for @cfunc{system}.
@end deftypefun


@deftypefun pid_t cce_sys_fork (cce_location_t * @var{L})
Wrapper for @cfunc{fork}.
@end deftypefun


@deftypefun void cce_sys_execv (cce_location_t * @var{L}, const char * @var{filename}, char * const @var{argv} [])
Wrapper for @cfunc{execv}.
@end deftypefun


@deftypefun void cce_sys_execve (cce_location_t * @var{L}, const char * @var{filename}, char * const @var{argv} [], char * const @var{env} [])
Wrapper for @cfunc{execve}.
@end deftypefun


@deftypefun void cce_sys_execvp (cce_location_t * @var{L}, const char * @var{filename}, char * const @var{argv} [])
Wrapper for @cfunc{execvp}.
@end deftypefun


@deftypefun void cce_sys_waitpid (cce_location_t * @var{L}, pid_t @var{pid}, int * @var{wstatus}, int @var{options})
Wrapper for @cfunc{waitpid}.
@end deftypefun

@c page
@node syshandlers
@chapter Predefined exception handlers


@menu
* syshandlers malloc::          Handler for allocated memory.
* syshandlers filedes::         Handler for file descriptors.
* syshandlers pipedes::         Handler for pipe descriptors.
* syshandlers tmpfile::         Handler for temporary files.
* syshandlers tmpdir::          Handler for temporary directories.
* syshandlers dirstream::       Handler for directory streams.
@end menu

@c page
@node syshandlers malloc
@section Handler for allocated memory


We can handle memory that must be released with the standard function @cfunc{free} as follows:

@example
cce_location_t  L[1];
cce_handler_t   H[1];

if (cce_location(L)) @{
  cce_run_error_handlers(L);
  cce_condition_delete(cce_condition(L));
@} else @{
  void *        P = cce_sys_malloc(L, 4096);
  cce_cleanup_handler_malloc_init(L, H, P);
  cce_run_cleanup_handlers(L);
@}
@end example

The following symbols are defined in the header file @file{ccexceptions.h}.


@deftypefun void cce_cleanup_handler_malloc_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, void * @var{P})
@deftypefunx void cce_error_handler_malloc_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, void * @var{P})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
release the memory block referenced by @var{P} using the standard function @cfunc{free}.
@end deftypefun

@c page
@node syshandlers filedes
@section Handler for file descriptors


We can handle file descriptors that must be released with the standard function @cfunc{close} as
follows:

@example
cce_location_t  L[1];
cce_handler_t   H[1];

if (cce_location(L)) @{
  cce_run_error_handlers(L);
  cce_condition_delete(cce_condition(L));
@} else @{
  int   fd = cce_sys_open(L, "name.ext", O_CREAT, S_IRWXU);
  cce_cleanup_handler_filedes_init(L, H, fd);
  cce_run_cleanup_handlers(L);
@}
@end example

The following symbols are defined in the header file @file{ccexceptions-system.h}.


@deftypefun void cce_cleanup_handler_filedes_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, int @var{fd})
@deftypefunx void cce_error_handler_filedes_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, int @var{fd})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
release the file descriptor @var{fd} using the standard function @cfunc{close}; errors in
@cfunc{close} are @strong{ignored}.
@end deftypefun

@c page
@node syshandlers pipedes
@section Handler for file descriptors


We can handle file descriptors that must be released with the standard function @cfunc{close} as
follows:

@example
cce_location_t  L[1];
cce_handler_t   H[1];

if (cce_location(L)) @{
  cce_run_error_handlers(L);
  cce_condition_delete(cce_condition(L));
@} else @{
  int   pipedes[2]
  cce_sys_pipe(L, pipedes);
  cce_cleanup_handler_pipedes_init(L, H, pipedes);
  cce_run_cleanup_handlers(L);
@}
@end example

The following symbols are defined in the header file @file{ccexceptions-system.h}.


@deftypefun void cce_cleanup_handler_pipedes_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, int @var{pipedes}[2])
@deftypefunx void cce_error_handler_pipedes_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, int @var{pipedes}[2])
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
release the file descriptors in @var{pipedes} using the standard function @cfunc{close}; errors in
@cfunc{close} are @strong{ignored}.
@end deftypefun

@c page
@node syshandlers tmpfile
@section Handler for temporary files


We can remove temporary files with the standard function @cfunc{remove} as follows:

@example
cce_location_t  L[1];
cce_handler_t   H[1];

if (cce_location(L)) @{
  cce_run_error_handlers(L);
  cce_condition_delete(cce_condition(L));
@} else @{
  int   fd = cce_sys_open(L, "name.ext", O_CREAT|O_EXCL,
                          S_IRUSR|S_IWUSR);
  cce_cleanup_handler_filedes_init(L, H, fd);
  cce_cleanup_handler_tmpfile_init(L, H, "name.ext");
  cce_run_cleanup_handlers(L);
@}
@end example

The handler documented here will ignore errors returned by @cfunc{remove}, which is generally bad;
we can use the source code of this handler as template to implement a more complete procedure.
Remember that a good way to create temporary files is to use the @posix{} standard function
@cfunc{mkstemp}.

The following symbols are defined in the header file @file{ccexceptions-system.h}.


@deftypefun void cce_cleanup_handler_tmpfile_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, const char * @var{pathname})
@deftypefunx void cce_error_handler_tmpfile_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, const char * @var{pathname})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
remove the file whose pathname is @var{pathname} using the standard function @cfunc{remove}; errors
in @cfunc{remove} are @strong{ignored}.

The string referenced by @var{pathname} is duplicated and stored in the structure referenced by
@var{H}.

If an error occurs while configuring the handler: an exception is raised by performing a non--local
exit to @var{L}.
@end deftypefun

@c page
@node syshandlers tmpdir
@section Handler for temporary files


We can remove @strong{empty} temporary directories with the standard function @cfunc{rmdir} as
follows:

@example
cce_location_t  L[1];
cce_handler_t   tmpdir_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers(L);
  cce_condition_delete(cce_condition(L));
@} else @{
  cce_sys_mkdir(L, "name.d", 0);
  cce_cleanup_handler_tmpdir_init(L, tmpdir_H, "name.ext");
  cce_run_cleanup_handlers(L);
@}
@end example

The handler documented here will ignore errors returned by @cfunc{rmdir}, which is generally bad; we
can use the source code of this handler as template to implement a more complete procedure.
Remember that a good way to create temporary files is to use the function @cfunc{mkdtemp}
implemented by the @gnu{} C Library.

The following symbols are defined in the header file @file{ccexceptions-system.h}.


@deftypefun void cce_cleanup_handler_tmpdir_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, const char * @var{pathname})
@deftypefunx void cce_error_handler_tmpdir_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, const char * @var{pathname})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
remove the directory whose pathname is @var{pathname} using the standard function @cfunc{rmdir};
errors in @cfunc{rmdir} are @strong{ignored}.  The directory is removed only if it is empty.

The string referenced by @var{pathname} is duplicated and stored in the structure referenced by
@var{H}.

If an error occurs while configuring the handler: an exception is raised by performing a non--local
exit to @var{L}.
@end deftypefun

@c page
@node syshandlers dirstream
@section Handler for directory streams


We can read the contents of a directory opening a directory stream with @cfunc{cce_sys_opendir} and
closing it with @cfunc{closedir}:

@example
cce_location_t  L[1];
cce_handler_t   dirstream_H[1];
const char *    pathname = "./";

if (cce_location(L)) @{
  cce_run_error_handlers(L);
  cce_condition_delete(cce_condition(L));
@} else @{
  DIR *               dirstream;
  struct dirent *     direntry;

  dirstream = cce_sys_opendir(L, pathname);
  cce_cleanup_handler_dirstream_init(L, dirstream_H, dirstream);
  for (direntry = cce_sys_readdir(L, dirstream);
       direntry;
       direntry = cce_sys_readdir(L, dirstream)) @{
    printf("%s\n", direntry->d_name);
    fflush(stdout);
  @}
  cce_run_cleanup_handlers(L);
@}
@end example

The handler documented here will ignore errors returned by @cfunc{closedir}, which is generally bad;
we can use the source code of this handler as template to implement a more complete procedure.

The following symbols are defined in the header file @file{ccexceptions-system.h}.


@deftypefun void cce_cleanup_handler_dirstream_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, DIR * @var{dirstream})
@deftypefunx void cce_error_handler_dirstream_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, DIR * @var{dirstream})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
finalise the directory stream using the standard function @cfunc{closedir}; errors in
@cfunc{closedir} are @strong{ignored}.
@end deftypefun

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DOCUMENTATION_URL}

@noindent
the latest release of this package can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

