\input texinfo.tex
@c %**start of header
@setfilename ccexceptions.info
@settitle CCExceptions
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCExceptions

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCExceptions

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccexceptions

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2016-2017

@c ------------------------------------------------------------

@set GITHUB_URL                 @url{http://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BITBUCKET_URL              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DOWNLOAD_URL               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DOCUMENTATION_URL          @url{http://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library requiring
@gcc{} extensions; it implements an interface to non--local exits, which is somewhat similar to
exceptions handling.  The library targets @posix{} systems.

The package is distributed under the terms of the @gnu{} General Public License (@gpl{}).

The latest release can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front--Cover Texts, and no
Back--Cover Texts.  A copy of the license is included in the section
entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccexceptions: (ccexceptions).       CCExceptions a C language library
                                      implementing exceptions handling.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* setjmp::                      Brief introduction to non-local exits.
* extensions::                  Introduction to @code{plan9-extensions}.
* locations::                   The locations @api{}.
* handlers::                    The handlers @api{}.
* conditions::                  Exceptional condition descriptors.
* posix::                       @posix{} system calls.
* helpers::                     Helper functions and macros.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library requiring
@gcc{} extensions; it implements an interface to non--local exits, which is somewhat similar to
exceptions handling.  The library targets @posix{} systems.

This tiny library will not solve the problem of error handling in the C language, it just brings a
little order in the mess resulting from hand--coding the error handling logic.

@value{PACKAGE} installs the single header file @file{ccexceptions.h}.  All the function names in
the @api{} are prefixed with @code{cce_}; all the constant names are prefixed with @code{CCE_}; all
the type names are prefixed with @code{cce_} and suffixed with @code{_t}.

@value{PACKAGE}'s location mechanism has the following purposes:

@enumerate
@item
Implement non--local exits in a way that allows client code to be
shorter and simpler to understand.

@item
Implement non--local exit handlers to perform synchronous clean--up operations.

@item
Implement a simple exceptional condition descriptors interface.
@end enumerate

@noindent
these features come at the cost of slowing down execution in a possibly sensible way (with respect
to, for example, hand--coded @code{goto} instructions that jump to labels).

@menu
* overview linking::            Linking code with the library.
@end menu

@c page
@node overview linking
@section Linking code with the library


This package installs a data file for @command{pkg-config}, so when searching for the installed
library with the @gnu{} Autotools, we can:

@itemize
@item
Add the following macro use to @file{configure.ac}:

@example
PKG_CHECK_MODULES([CCEXCEPTIONS],[ccexceptions >= 0.4])
@end example

@noindent
which will set the variables @code{CCEXCEPTIONS_LIBS} and @code{CCEXCEPTIONS_CFLAGS}.
@end itemize

Alternatively we can use the raw @gnu{} Autoconf macros:

@example
AC_CHECK_LIB([ccexceptions],[cce_version_string],,
  [AC_MSG_FAILURE([test for CCExceptions library failed])])
AC_CHECK_HEADERS([ccexceptions.h],,
  [AC_MSG_FAILURE([test for CCExceptions header failed])])
@end example

We need to remember that client code using @value{PACKAGE}'s library must be written using the C11
language and the @gcc{} extensions enabled by @option{-fplan9-extensions}.

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the
@gnu{} Autotools.  For an explanation of interface numbers as managed by
@gnu{} Libtool @xref{Libtool versioning, interface, Libtool's versioning
system, libtool, Shared library support for @gnu{}}.


@deftypefun {const char *} cce_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing
the interface version number.
@end deftypefun


@deftypefun int cce_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int cce_version_interface_revision (void)
Return an integer representing the library interface current revision
number.
@end deftypefun


@deftypefun int cce_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node setjmp
@chapter Brief introduction to non--local exits


Let's recall briefly how the standard, C language, non--local exits mechanism works; for the full
documentation refer to the C Library.  @glibcref{Non-Local Exits, Non-Local Exits}.

To use @cfunc{setjmp} and @cfunc{longjmp} we write chunks of code like the following:

@example
#define JMP_ERROR_CODE          1

jmp_buf  here;

if (setjmp(here))
  @{
    handle_the_error();
  @}
else
  @{
    do_something();
    if (an_error_occurred()) @{
      longjmp(here, JMP_ERROR_CODE);
    @}
    do_something_else();
  @}
@end example

@noindent
this is what happens:

@itemize
@item
When @cfunc{setjmp} is invoked: it saves the current ``position'' in @var{here}, then it returns
zero.

@item
If @cfunc{longjmp} is not applied to @var{here}, nothing strange happens and the execution flow goes
on as usual.

@item
If @cfunc{longjmp} is applied to @var{here}: the execution jumps back to the call to @cfunc{setjmp}
with @code{JMP_ERROR_CODE} as return value.
@end itemize

This mechanism allows us to separate the exception handling code from the main code.  By using
@var{here} as argument to nested function calls: we can perform non--local exits across functions;
something that is not possible with @code{goto} statements.

As always, care must be taken when the body allocates asynchronous resources.  For each resource:
the exception handler must detect if the allocation took place and execute release code.  For
example:

@example
#define DO_NOT_SAVE_SIGS        0
#define JMP_ERROR_CODE          1

jmp_buf         here;
volatile void * P = NULL;

if (setjmp(here))
  @{
    if (P)
      free(P);
  @}
else
  @{
    ...
    P = malloc(4096);
    ...
  @}
@end example

Let's see some logic example; we will assume the following preamble:

@example
#include <assert.h>
#include <stdlib.h>
#include <setjmp.h>

#define DO_NOT_SAVE_SIGS        0
#define JUMP_TO_ERROR           2
#define JUMP_TO_RETRY           3
@end example

In the following code no jump is performed; we just call @cfunc{setjmp} once and never call
@cfunc{longjmp}:

@example
jmp_buf         L;
int             flag = 0, code;

code = setjmp(L);
if (code) @{
  flag = 2;
@} else @{
  flag = 1;
@}
assert(0 == code);
assert(1 == flag);
@end example

In the following code we perform a jump and handle the logic with an @code{if} statement:

@example
jmp_buf         L;
int             flag = 0, code;

code = setjmp(L);
if (JUMP_TO_ERROR == code) @{
  flag = 2;
@} else @{
  flag = 1;
  longjmp(L, JUMP_TO_ERROR);
@}
assert(JUMP_TO_ERROR == code);
assert(2 == flag);
@end example

In the following code we perform a jump and handle the logic with a @code{switch} statement:

@example
jmp_buf         L;
int             flag = 0, code;

code = setjmp(L);
switch (code) @{
case JUMP_TO_ERROR:
  flag = 2;
  break;
default:
  flag = 1;
  longjmp(L, JUMP_TO_ERROR);
@}
assert(JUMP_TO_ERROR == code);
assert(2 == flag);
@end example

In the following code we perform a jump and try an alternative body; we handle the logic with a
@code{switch} statement:

@example
jmp_buf         L;
int             flag = 0, code;

code = setjmp(L);
switch (code) @{
case JUMP_TO_ERROR:
  flag = 2;
  longjmp(L, JUMP_TO_RETRY);
  break;
case JUMP_TO_RETRY:
  // the alternative body
  flag = 3;
  break;
default:
  // the body
  flag = 1;
  longjmp(L, JUMP_TO_ERROR);
@}
assert(JUMP_TO_RETRY == code);
assert(3 == flag);
@end example

In the following code we perform a jump and retry the body several times:

@example
jmp_buf         L;
int             flag = 0, code;
volatile int    times = 0;

code = setjmp(L);
switch (code) @{
case JUMP_TO_ERROR:
  flag = 2;
  longjmp(L, JUMP_TO_RETRY);
  break;
default:
  if ((JUMP_TO_RETRY == code) && (times < 5)) @{
    // retrying
    ++times;
    longjmp(L, JUMP_TO_ERROR);
  @} else if (JUMP_TO_RETRY == code) @{
    flag = 3;
  @} else @{
    // the body
    flag = 1;
    longjmp(L, JUMP_TO_ERROR);
  @}
@}
assert(JUMP_TO_RETRY == code);
assert(3 == flag);
@end example

@c page
@node extensions
@chapter Introduction to @code{plan9-extensions}


The @url{http://www.gnu.org/software/gcc/, @gnu{} C language compiler} supports the
@url{https://en.wikipedia.org/wiki/C11_(C_standard_revision), C11} standard, with some extensions,
through the @option{-fplan9-extensions} option.  From a certain point of view, these extensions are
just the default offered by the C++ language; but under the C language they are very useful.
@value{PACKAGE} is meant to use such extensions.

Here is an example:

@example
/* demo.c --
 *
 * Compile this with:
 *
 *  $ gcc -std=c11 -Wall -fplan9-extensions -o demo demo.c
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct @{
  int   one;
@} alpha_t;

typedef struct @{
  alpha_t;
  int           two;
@} beta_t;

void
print_alpha (alpha_t * self)
@{
  fprintf(stderr, "alpha: %d\n", self->one);
@}
void
print_beta (beta_t * self)
@{
  fprintf(stderr, "beta: %d %d\n", self->one, self->two);
@}

int
main (int argc, const char *const argv[])
@{
  beta_t        B = @{ .one = 1, .two = 2 @};
  print_alpha(&B);
  print_beta (&B);
  exit(EXIT_SUCCESS);
@}

/* end of file */
@end example

@noindent
we see that the definition of @code{beta_t} contains an unnamed field of type
@code{alpha_t}:

@example
typedef struct @{
  alpha_t;
  int           two;
@} beta_t;
@end example

@noindent
and we can access its fields, nested in an instance of @code{beta_t}, transparently
both in the initialiser:

@example
beta_t B = @{ .one = 1, .two = 2 @};
@end example

@noindent
and from a pointer to @code{beta_t} in the function @cfunc{print_beta}:

@example
fprintf(stderr, "beta: %d %d\n", self->one, self->two);
@end example

Also, when a pointer to @code{beta_t} is used as operand for a function expecting a
pointer to @code{alpha_t} as argument: the pointer conversion is performed
automatically by the compiler, without the need to cast it explicitly.  So we can
simply write:

@example
print_alpha(&B);
@end example

@noindent
rather than:

@example
print_alpha((alpha_t *)&B);
@end example

@c page
@node locations
@chapter The locations @api{}


Non--local exits are a way to transfer execution from one point to another in a program; they are
implemented by the standard C library through the @cfunc{setjmp} and @cfunc{longjmp} functions.  The
main usage pattern for this module is the following:

@example
cce_location_t  L[1];

if (cce_loction(L)) @{
  /* handle the error here */
  cce_run_error_handlers(L);
  cce_condition_free(cce_condition(L));
@} else @{
  /* do something useful here */
  cce_run_cleanup_handlers(L);
@}
@end example

@noindent
it is usually useful to defined variables of type @objtype{cce_location_t} as one--element arrays.
When using @value{PACKAGE} we should consider configuring our code editor to automatically insert
this code template.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_location_t
Struct type representing the location context.  This type is ``derived'' from @objtype{setjmp_buf}
in the sense that a pointer to @objtype{cce_location_t} is also a pointer to @objtype{setjmp_buf}.

Instances of this structure reference an instance of type @objtype{cce_condition_t}; it is set by
@cfunc{cce_raise} and @cfunc{cce_retry}.  The client code is responsible for releasing resources
associated to this value by retrieving a pointer to it with @cfunc{cce_condition} and
releasing it with @cfunc{cce_condition_free}.

Before terminating the use of instances of this type we must always call
@cfunc{cce_run_error_handlers} or @cfunc{cce_run_cleanup_handlers}.  We must assume that the
handlers might access the @objtype{cce_condition_t} object, so first we call the handlers and then
we release the condition object.
@end deftp


@deftypefun void cce_location_init (cce_location_t * @var{L})
Initialise the location @var{L}, but do @strong{not} call @cfunc{setjmp}.  We are not meant to call
this function directly; rather we should use the macro @cfunc{cce_location}.
@end deftypefun


@deftypefn {Preprocessor Macro} int cce_location (cce_location_t * @var{L})
Initialise the location @var{L}; call @cfunc{setjmp} and return its return value.
@end deftypefn


@deftypevr Constant int CCE_SUCCESS
Constant used by the library as non--local exit code.  It is defined as @code{0} and it represents
the return value of @cfunc{cce_location} at the first evaluation.
@end deftypevr


@deftypevr Constant int CCE_ERROR
Constant used by the library as non--local exit code.  It is the return value of
@cfunc{cce_location} when a non--local exit is performed by @cfunc{cce_raise}.
@end deftypevr


@deftypevr Constant int CCE_RETRY
Constant used by the library as non--local exit code.  It is the return value of
@cfunc{cce_location} when a non--local exit is performed by @cfunc{cce_retry}.
@end deftypevr


@deftypefun void cce_raise (cce_location_t * @var{L}, const cce_condition_t * @var{C})
Raise an exception associated to the location @var{L} and with exceptional condition object @var{C}.
This function performs the call to @cfunc{longjmp} with code @code{CCE_ERROR}.

With a call to this function: the client code is put in charge of releasing resources associated to
@var{C}.  If @var{C} is @cnull{}: an internal, statically allocated, exceptional condition object is
selected to represent an ``unknown exceptional condition''; we can transparently apply the function
@cfunc{cce_condition_free} to this object.
@end deftypefun


@deftypefun void cce_retry (cce_location_t * @var{L})
Raise an exception associated to the location @var{L} with the purpose or retrying the body
evaluation.  This function performs the call to @cfunc{longjmp} with code @code{CCE_RETRY}.

This function selects an internal, statically allocated, exceptional condition object to represent
an ``unknown exceptional condition''; we can transparently apply the function
@cfunc{cce_condition_free} to this object.
@end deftypefun


@deftypefn {Inline Function} {cce_condition_t *} cce_condition (cce_location_t * @var{L})
Return the condition object associated to the location @var{L}; this value is @strong{never}
@cnull{}.

If we apply this function to a location without calling @cfunc{cce_raise} or @cfunc{cce_retry}: the
returned pointer references an internal, statically allocated, exceptional condition object
representing an ``unknown exceptional condition''; we can transparently apply the function
@cfunc{cce_condition_free} to this object.
@end deftypefn


If we want to evaluate a body of code and catch its raised exceptions locally, we can use the
following template code:

@example
cce_location_t  L[1];

if (cce_loction(L)) @{
  /* handle the error here */
  cce_run_error_handlers(L);
  cce_condition_free(cce_condition(L));
@} else @{
  /* do something useful here */
  cce_run_cleanup_handlers(L);
@}
@end example

If we want to evaluate a body of code, catch its raised exceptions locally and then re--raise them
to another location, we can use the following template code:

@example
void
outer (void)
@{
  cce_location_t  L[1];

  if (cce_loction(L)) @{
    cce_run_error_handlers(L);
    cce_condition_free(cce_condition(L));
  @} else @{
    inner(L);
    cce_run_cleanup_handlers(L);
  @}
@}

void
inner (cce_location_t * there)
@{
  cce_location_t  L[1];

  if (cce_loction(L)) @{
    cce_run_error_handlers(L);
    cce_raise(there, cce_condition(L));
  @} else @{
    /* do something useful here */
    cce_run_cleanup_handlers(L);
  @}
@}
@end example

When attempting to evaluate a body of code multiple times with the retry faciliy, it is suggested to
use @code{switch} statements to organise the logic of location mechanisms.  If we want to
distinguish between the main body and the retry body, we do:

@example
cce_location_t  L[1];

switch (cce_location(L)) @{
case CCE_ERROR:
  cce_run_error_handlers(L);
  cce_condition_free(cce_condition(L));
  break;

case CCE_RETRY:
  retry_doing_something();
  break;

default:
  do_something();
  if (some_recoverable_error()) @{
    cce_retry(L);
  @} else if (some_error()) @{
    cce_raise(L, NULL);
  @}
@}
@end example

@noindent
and we can fall through:

@example
cce_location_t  L[1];

switch (cce_location(L)) @{
case CCE_ERROR:
  cce_run_error_handlers(L);
  cce_condition_free(cce_condition(L));
  break;

case CCE_RETRY:
  prepare_to_retry();
  // fall through

default:
  do_something();
  if (some_recoverable_error()) @{
    cce_retry(L);
  @} else if (some_error()) @{
    cce_raise(L, NULL);
  @}
@}
@end example

@c page
@node handlers
@chapter The handlers @api{}


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_handler_t
Structure type representing a cleanup or error handler.  Instances of this type are associated to a
location by calling one of the functions @cfunc{cce_register_*_handler}.  Handlers are invoked by
calling one of the functions @cfunc{cce_run_*_handlers}; before terminating the use of a
@objtype{cce_location_t} instance we must always call the handlers.

We are meant to wrap instances of this type into an enclosing struct definition as follows:

@example
struct resource_handler_t @{
  cce_handler_t 	handler;
  void *		resourcep;
@};
@end example

@noindent
in which the instance of @code{cce_handler_t} is the first field.

The structure has the following public fields:

@table @code
@item cce_handler_fun_t * handler_function
Pointer to the function implementing the handler.
@end table
@end deftp


@deftypefn {Function Typedef} void cce_handler_fun_t (const cce_condition_t * @var{C}, cce_handler_t * @var{H})
Type of handler functions meant to release some asynchronous resource.  The argument @var{C}
references the object representing the exceptional condition; the handler must leave it untouched,
it must @strong{not} mutate or release it.  The argument @var{H} references the handler context.

If an error occurs: the handler function must take care of itself and return to the caller, it must
@strong{not} raise an exceptional condition and jump to a remote location.

If the structure referenced by @var{H} is dynamically allocated: the handler function is responsible
to release its memory.
@end deftypefn


@deftypefun void cce_register_cleanup_handler (cce_location_t * @var{L}, cce_handler_t * @var{H})
Register the cleanup handler referenced by @var{H} in the list of handlers associated to the
location @var{L}.  The pointer @var{H} must reference an instance of structure whose first field is
a structure of type @code{cce_handler_t}; such structure can either be allocated on the same stack
frame of the function also defining the location object @var{L}, or be dynamically allocated on the
heap.

A cleanup handler is meant to be called whenever the execution flow leaves the dynamic extent of a
location, whether with an exception or as part of the successful execution path.
@end deftypefun


@deftypefun void cce_register_error_handler (cce_location_t * @var{L}, cce_handler_t * @var{H})
Register the error handler referenced by @var{H} in the list of handlers associated to the location
@var{L}.  The pointer @var{H} must reference an instance of structure whose first field is a
structure of type @code{cce_handler_t}; such structure can either be allocated on the same stack
frame of the function also defining the location object @var{L}, or be dynamically allocated on the
heap.

An error handler is meant to be called whenever the execution flow leaves the dynamic extent of a
location in case of an exceptional condition; it must @strong{not} be called as part of the
successful execution path.
@end deftypefun


@deftypefun void cce_run_cleanup_handlers (cce_location_t * @var{L})
Run all the cleanup handlers associated to the location @var{L}.  Each handler must return to its
caller, taking care of itself regarding internal error handling and asynchronous resources
allocation.  Handlers are called starting from the last registered one.

This is a destructive function: once the list has been traversed, it is not valid anymore.  When the
handler function is applied to the handler structure: the handler structure is completely detached
from the context of @var{L}, so it can be finalised and its memory released.
@end deftypefun


@deftypefun void cce_run_error_handlers (cce_location_t * @var{L})
Run all the error handlers associated to the location @var{L}.  Each handler must return to its
caller, taking care of itself regarding internal error handling and asynchronous resources
allocation.  Handlers are called starting from the last registered one.

This is a destructive function: once the list has been traversed, it is not valid anymore.  When the
handler function is applied to the handler structure: the handler structure is completely detached
from the context of @var{L}, so it can be finalised and its memory released.

@strong{NOTE} It must assume that an error handler might access the exceptional condition object
associated to @var{L}, so this function should always be called @strong{before} applying
@cfunc{cce_condition_free} to the return value of @cfunc{cce_condition}.
@end deftypefun


For convenience, in the following examples: we will use nested C function definitions, which are a
@gnu{} C Compiler's extension.  We could define and call a list of cleanup handlers as follows:

@example
void handler1 (const cce_condition_t * C, cce_handler_t * H) @{
  do_some_cleanup();
@}
void handler2 (const cce_condition_t * C, cce_handler_t * H) @{
  do_some_cleanup();
@}
void handler3 (const cce_condition_t * C, cce_handler_t * H) @{
  do_some_cleanup();
@}

cce_location_t L[1];
cce_handler_t  H1 = @{ .handler_function = handler1 @};
cce_handler_t  H2 = @{ .handler_function = handler2 @};
cce_handler_t  H3 = @{ .handler_function = handler3 @};

cce_location_init(L);
cce_register_cleanup_handler(L, &H1);
cce_register_cleanup_handler(L, &H2);
cce_register_cleanup_handler(L, &H3);
cce_run_cleanup_handlers(L);
@end example

@noindent
and we could define and call a list of error handlers as follows:

@example
void handler1 (const cce_condition_t * C, cce_handler_t * H) @{
  do_some_error_handling();
@}
void handler2 (const cce_condition_t * C, cce_handler_t * H) @{
  do_some_error_handling();
@}
void handler3 (const cce_condition_t * C, cce_handler_t * H) @{
  do_some_error_handling();
@}

cce_location_t L[1];
cce_handler_t  H1 = @{ .handler_function = handler1 @};
cce_handler_t  H2 = @{ .handler_function = handler2 @};
cce_handler_t  H3 = @{ .handler_function = handler3 @};

cce_location_init(L);
cce_register_error_handler(L, &H1);
cce_register_error_handler(L, &H2);
cce_register_error_handler(L, &H3);
cce_run_error_handlers(L);
@end example

Let's say we need to allocate memory, and to release it whenever the dynamic extent of the local
function terminates; we can organise the code as follows, using a cleanup handler:

@example
cce_location_t      L[1];
cce_handler_t       H[1];
void *              P;

void P_handler (const cce_condition_t * C, cce_handler_t * H)
@{
  free(P);
@}
H->handler_function = P_handler;

if (cce_location(L)) @{
  cce_run_error_handlers(L);
  cce_condition_free(cce_condition(L));
@} else @{
  errno = 0;
  P = malloc(4096);
  if (P) @{
    cce_register_cleanup_handler(L, H);
  @} else @{
    cce_raise(L, cce_errno_C(errno));
  @}
  do_something(L, P);
  cce_run_cleanup_handlers(L);
@}
@end example

@noindent
whether @cfunc{do_something} raises an exception or not: the cleanup handler is invoked and the
memory is released.

Let's say we are writing a constructor and we need to allocate memory, do something and, if
successful, return the memory to the caller; we can organise the code as follows, using an error
handler in the constructor and a cleanup handler in the caller:

@example
void *
constructor (cce_location_t * there)
@{
  typedef struct handler_t @{
    cce_handler_t  H[1];
    void *         pointer;
  @} handler_t;
  cce_location_t    L[1];
  handler_t         H[1];
  void *            P;

  void P_handler (const cce_condition_t * C, cce_handler_t * _H)
  @{
    handler_t * H = (handler_t *)_H;
    free(H->pointer);
  @}
  H->handler_function = P_handler;

  if (cce_location(L)) @{
    cce_run_error_handlers(L);
    cce_raise(there, cce_condition(L));
  @} else @{
    errno = 0;
    P = malloc(4096);
    if (P) @{
      H->pointer = P;
      cce_register_error_handler(L, H);
    @} else @{
      cce_raise(L, cce_errno_C(errno));
    @}
    do_some_initialisation_in(P);
    cce_run_cleanup_handlers(L);
  @}
  return P;
@}

void caller (void)
@{
  typedef struct handler_t @{
    cce_handler_t  H[1];
    void *         pointer;
  @} handler_t;
  cce_location_t    L[1];
  handler_t         H[1];
  void *            P;

  void P_handler (const cce_condition_t * C, cce_handler_t * _H)
  @{
    handler_t * H = (handler_t *)_H;
    free(H->pointer);
  @}
  H->handler_function = P_handler;

  if (cce_location(L)) @{
    cce_run_error_handlers(L);
    cce_condition_free(cce_condition(L));
  @} else @{
    P = constructor(L);
    H->pointer = P;
    cce_register_cleanup_handler(L, H);
    do_something_with(P);
    cce_run_cleanup_handlers(L);
  @}
@}
@end example

@c page
@node conditions
@chapter Exceptional condition descriptors


To represent exceptional conditions @value{PACKAGE} allows us to define a tree hierarchy of
exceptional condition objects.  With such a tree it is possible to react to a raised exception by
branching according to the type of raised condition object.

Every condition object is a structure of type @objtype{cce_condition_t}, which references a
condition descriptor of type @objtype{cce_condition_descriptor_t}.  The instances of
@objtype{cce_condition_descriptor_t} hold the pointers that define the tree hierarchy.

To define the hierarchy we must ``derive'' descriptor types from
@objtype{cce_condition_descriptor_t} as follows:

@example
typedef struct my_error_D_t @{
  cce_condition_descriptor_t;
  /* Put some custom fields here. */
@} my_error_D_t;
@end example

@noindent
and ``derive'' object types from @objtype{cce_condition_t} as follows:

@example
typedef struct my_error_C_t @{
  cce_condition_t;
  /* Put some custom fields here. */
@} my_error_C_t;
@end example

@noindent
notice the naming convention: the suffix @samp{_D_t} stands for ``exceptional condition descriptor
type''; the suffix @samp{_C_t} stands for ``exceptional condition object type''.

In the following picture: the condition descriptor @samp{A} is a child of the root descriptor; the
condition descriptor @samp{B} is a child of the condition descriptor @samp{A}.  We can say that: a
condition object of type @samp{A} is also of type root; a condition object of type @samp{B} is also
of type @samp{A} and of type root.

@example
                           ---------------------------
                          | root condition descriptor |
                           ---------------------------
                                        ^
                                        |
 --------------------        ------------------------
| condition object A |----> | condition descriptor A |
 --------------------        ------------------------
                                        ^
                                        |
 --------------------        ------------------------
| condition object B |----> | condition descriptor B |
 --------------------        ------------------------
@end example

@menu
* conditions types::            Core condition object types.
* conditions operations::       Acting upon condition objects.
* conditions root::             Predefined root condition descriptor.
* conditions unknown::          Predefined unknown condition object.
* conditions errno::            Predefined @code{errno} conditions.
* conditions custom::           Defining custom condition objects.
@end menu

@c page
@node conditions types
@section Core condition object types


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftypefn {Function Prototype} void cce_condition_free_fun_t (cce_condition_t * @var{C})
Applied to a pointer to condition object: release all the dynamic resources associated to @var{C}.
@end deftypefn


@deftypefn {Function Prototype} void cce_condition_static_message_fun_t (const cce_condition_t * @var{C})
Applied to a pointer to condition object: return a statically allocated @asciiz{} string describing
the exceptional condition @var{C}.  A static message must always be defined; another client--defined
function can build a dynamic and more descriptive message.
@end deftypefn


@deftp {Struct Typedef} cce_condition_descriptor_t
Type of structures holding a table of function pointers to handle exceptional condition objects.  It
has the following fields:

@table @code
@item const cce_condition_descriptor_t * parent
Pointer to the condition descriptor that is parent of this one.  This pointer is set to @cnull{}
only for the root condition descriptor, @xref{conditions root, Predefined root condition
descriptor}.

@item cce_condition_free_fun_t * free
Pointer to function which releases all the dynamic resources associated to the object.  This pointer
can be @cnull{}, meaning that: there are no dynamic resources in the condition object and the data
structure itself is statically allocated.

@item cce_condition_static_message_fun_t * static_message
Pointer to function which returns a statically allocated @asciiz{} string describing the exceptional
condition.
@end table
@end deftp


@deftp {Struct Typedef} cce_condition_t
Type of structure representing an exceptional condition object.  It is meant to be used as base type
for new exceptional condition object types, as follows:

@example
typedef struct my_C_t @{
  cce_condition_t;
@} my_C_t;
@end example
@end deftp

@c page
@node conditions operations
@section Acting upon condition objects


Given a pointer to an instance of type @objtype{cce_condition_t} we can act upon it with the
following functions.  All the following definitions are accessible from the header file
@file{ccexceptions.h}.


@deftypefun void cce_condition_init (cce_condition_t * @var{condition}, const cce_condition_descriptor_t * @var{descriptor})
Initialise the core fields of an already allocated condition object.  The argument @var{descriptor}
must be a pointer to the condition descriptor: it is stored in @var{condition}.  This function is
usually called from a type--specific initialisation function.
@end deftypefun


@deftypefun bool cce_is_a_condition (const cce_condition_t * @var{condition}, const cce_condition_descriptor_t * @var{descriptor})
Establish if a condition object is of a selected type.  Return @true{} if @var{condition} is an
instance of type @var{descriptor}, or an instance of a type that is parent of @var{descriptor};
otherwise return @false{}.
@end deftypefun


@deftypefun bool cce_condition_descriptor_child_and_parent (const cce_condition_descriptor_t * @var{child}, const cce_condition_descriptor_t * @var{parent})
Establish if two condition descriptors are child and parent.  Return @true{} if @var{child} is equal
to @var{parent} or @var{parent} is in the hierarchy of @var{child}'s parents; otherwise return
@false{}.
@end deftypefun


@deftypefn {Inline Function} bool cce_condition_equal (const cce_condition_t * @var{A}, const cce_condition_t * @var{B})
Compare the pointer arguments: return @true{} if they are equal, otherwise return @false{}.  This
function exists to avoid pointer mismatch warnings when comparing pointers with the @code{==}
operator:

@example
cce_errno_C_t   * A = ...;
cce_condition_t * B = ...;

A == B;                         /* raises a warning */
cce_condition_equal(A, B);      /* no warning */
@end example
@end deftypefn


@deftypefn {Inline Function} {const cce_condition_descriptor_t *} cce_condition_descriptor (const cce_condition_t * @var{condition})
Retrieve the descriptor of a condition object.  Return the pointer to condition descriptor in the
@var{condition} object.
@end deftypefn


@deftypefun void cce_condition_free (cce_condition_t * @var{condition})
Apply to @var{condition} the @code{free} function referenced by its descriptor's functions table.
@end deftypefun


@deftypefun {const char *} cce_condition_static_message (const cce_condition_t * @var{condition})
Apply to @var{condition} the @code{static_message} function referenced by its descriptor's functions
table.
@end deftypefun


The basic usage pattern of condition objects is as follows:

@example
cce_location_t      L[1];

if (cce_location(L)) @{
  cce_condition_t * C = cce_condition(L);
  @{
    fprintf(stderr, "log: %s\n", cce_condition_static_message(C));
    cce_run_error_handlers(L);
  @}
  cce_condition_free(C);
@} else @{
  do_something();
  if (an_error_occurred()) @{
    cce_raise(L, select_condition_object());
  @}
  cce_run_cleanup_handlers(L);
@}
@end example

If we need to hand the condition object to an upper level location we can do it as follows:

@example
void
upper_function (void)
@{
  cce_location_t        L[1];

  if (cce_location(L)) @{
    cce_condition_t * C = cce_condition(L);
    @{
      do_something_with(cce_condition_static_message(C));
      cce_run_error_handlers(L);
    @}
    cce_condition_free(C);
  @} else @{
    lower_function(L);
    cce_run_cleanup_handlers(L);
  @}
@}

void
lower_function (cce_location_t * upper_L)
@{
  cce_location_t        L[1];

  if (cce_location(L)) @{
    cce_run_error_handlers(L);
    cce_raise(upper_L, cce_condition(L));
  @} else @{
    do_something();
    if (an_error_occurred()) @{
      cce_raise(L, select_condition_object());
    @}
   cce_run_cleanup_handlers(L);
  @}
@}
@end example

If we need to branch according to a condition object's type, we can do it as follows using wrappers
for @cfunc{cce_is_a_condition}:

@example
cce_location_t      L[1];

if (cce_location(L)) @{
  cce_condition_t * C = cce_condition(L);
  @{
    if (cce_is_a_unknown_C(C)) @{
      do_something();
    @} else if (cce_is_a_errno_C(C)) @{
      do_something();
    @} else @{
      do_something();
    @}
    cce_run_error_handlers(L);
  @}
  cce_condition_free(C);
@} else @{
  do_something();
  if (an_exception_occurred()) @{
    cce_raise(L, select_condition_object());
  @}
  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node conditions root
@section Predefined root condition descriptor


The @dfn{root exceptional condition descriptor} has the only purpose of being the root of the
condition descriptors tree; there should be no condition objects having this descriptor.  The root
descriptor has @code{parent} field set to @cnull{}; this should be the only descriptor with such a
property.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftypevr {Dynamic Constant} {const cce_condition_descriptor_t * const} cce_root_D
Pointer to a statically allocated structure representing the root condition descriptor for all the
condition descriptors.  When a condition descriptors hierarchy is correctly built: using this value
as second argument in calls to the functions:

@example
cce_is_a_condition()
cce_condition_descriptor_child_and_parent()
@end example

@noindent
will cause the return value to always be @true{}.
@end deftypevr


To use this value in a custom condition descriptor definition, we must write initialisation code;
example:

@example
static const char *
default_static_message (const cce_condition_t * C CCE_UNUSED)
@{
  return "default message";
@}

cce_condition_descriptor_t alpha_D = @{
  .parent               = NULL,
  .free                 = NULL,
  .static_message       = default_static_message
@};

void
condition_descriptors_initialisation (void)
@{
  alpha_D.parent = cce_root_D;
@}
@end example

@noindent
and the function @cfunc{condition_descriptors_initialisation} must be called prior to using the
conditions system.

@c page
@node conditions unknown
@section Predefined unknown condition object


The @dfn{unknown exceptional condition object} has the purpose of describing an exceptional
condition with unknown cause; it should be used only by:

@itemize
@item
The function @cfunc{cce_raise} when no condition object argument is used.

@item
The function @cfunc{cce_retry}.
@end itemize

There should be only one unknown condition object: the one predefined by @value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_unknown_D_t
Structure type representing the descriptor for unknown condition objects.
@end deftp


@deftp {Struct Typedef} cce_unknown_C_t
Structure type representing an unknown condition object.
@end deftp


@deftypevr {Dynamic Constant} {const cce_unknown_D_t * const} cce_unknown_D
Pointer to a statically allocated structure representing the unknown condition descriptor for the
single unknown condition object.  The parent of this descriptor is the root descriptor referenced by
@code{cce_root_D}.

By comparing this value to the @code{descriptor} field of a @objtype{cce_condition_t} structure we
can determine if the condition struct is an unknown condition object.
@end deftypevr


@deftypevr {Dynamic Constant} {const cce_unknown_C_t * const} cce_unknown_C
Pointer to a statically allocated structure representing the unknown condition object.  This should
be the single condition object having @code{cce_unknown_D} as descriptor.
@end deftypevr


@deftypefn {Inline Function} bool cce_is_a_unknown_C (const cce_condition_t * @var{C})
Return @true{} if @var{C} has @code{cce_unknown_D} as descriptor; otherwise return @false{}.
@end deftypefn


@deftypefn {Preprocessor Macro} {cce_unknown_C_t *} cce_cast_to_unknown_C (cce_condition_t * @var{C})
Cast a pointer to condition object type.  This macro provides type checking and documents that this
conversion is sometimes needed.
@end deftypefn

@c page
@node conditions errno
@section Predefined @code{errno} conditions


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_errno_D_t
Structure type representing the descriptor for @code{errno} condition objects.

In a correctly built condition objects hierarchy: there is only one instance of this type, the one
referenced by @code{cce_errno_D}; all the instances of
@code{cce_errno_C_t} reference the same descriptor.

As single public field it has an unnamed field of type @code{cce_condition_descriptor_t}; the
sub--fields of this unnamed field can be accessed transparently by code using a pointer to
@objtype{cce_errno_D_t}.  For an @code{errno} condition descriptor the @code{parent} sub--field is
the root descriptor referenced by @code{cce_root_D}.
@end deftp


@deftp {Struct Typedef} cce_errno_C_t
Structure type representing an @code{errno} exceptional condition object, signalled by a system
function by setting @code{errno} to a non--zero value.  It has the following public fields:

@table @code
@item cce_condition_t
An unnamed field holding everything required to make an instance of @code{cce_errno_C_t}
also an instance of @code{cce_condition_t}.  For all the @code{errno} condition objects: the
condition descriptor referenced by the @code{descriptor} sub--field is the structure referenced by
@code{cce_errno_D}.

@item int errnum
The value of @code{errno}.

@item const char * message
A statically allocated string describing the error.
@end table
@end deftp


@deftypevr {Dynamic Constant} {const cce_errno_D_t * const} cce_errno_D
Pointer to a statically allocated structure representing the condition descriptor of all the values
returned by @cfunc{cce_errno_C}.

By comparing this value to the @code{descriptor} field of a @objtype{cce_condition_t} structure, we
can determine if such structure is an @code{errno} condition object.
@end deftypevr


@deftypefun {const cce_errno_C_t *} cce_errno_C (int @var{errnum})
Given the @code{errno} code @var{errnum}, return the pointer to the condition object associated to
it.

If @var{errnum} is zero: return a pointer to condition object representing a successful operation.
If @var{errnum} is not a valid @code{errno} code for the underlying platform: return a pointer to
condition object representing an invalid code.
@end deftypefun


@deftypefun {const cce_errno_C_t *} cce_errno_C_clear (void)
Consume the current value of @code{errno} and return the return value of @cfunc{cce_errno_C} applied
to it.  Before returning: @code{errno} is reset to zero.
@end deftypefun


@deftypefn {Inline Function} bool cce_is_a_errno_C (const cce_condition_t * @var{C})
Return @true{} if @var{C} has @code{cce_errno_D} as descriptor; otherwise return @false{}.
@end deftypefn


@deftypefn {Preprocessor Macro} {cce_errno_C_t *} cce_cast_to_errno_C (cce_condition_t * @var{C})
Cast a pointer to condition object type.  This macro provides type checking and documents that this
conversion is sometimes needed.
@end deftypefn

@c page
@node conditions custom
@section Defining custom condition objects


Let's say we want to define the following condition descriptors hierarchy:

@example
 ------       ---       ---       ---
| root | <-- | A | <-- | B | <-- | C |
 ------       ---       ---       ---
@end example

@noindent
where the condition objects of type @samp{A}, @samp{B} and @samp{C} have custom data structures.  We
do it as follows:

@smallexample
/* demo.c --
 *
 * Compile this with:
 *
 *  $ gcc -std=c11 -Wall -fplan9-extensions -lccexceptions \
 *      -o demo demo.c
 */

#include <stdlib.h>
#include <assert.h>
#include <ccexceptions.h>

/*** Exceptional condition A. ***/

/* Exceptional condition  descriptor type.   The anonymous field  can be
   seen  as a  table of  virtual methods,  which are  overridden by  the
   subtypes. */
typedef struct alpha_D_t @{
  cce_condition_descriptor_t;
@} alpha_D_t;

/* Exceptional condition object type. */
typedef struct alpha_C_t @{
  cce_condition_t;
  int                   alpha;
@} alpha_C_t;

cce_condition_t *       alpha_C_init  (alpha_C_t * cnd, int alpha);
void                    alpha_C_final (alpha_C_t * cnd);
cce_condition_t *       alpha_C_constructor (int code);
static void             alpha_C_destructor  (cce_condition_t * cnd);
static const char *     alpha_C_static_message (const cce_condition_t * cnd);
bool			alpha_C_is_a (const cce_condition_t * condition);

/* Instance of condition descriptor.   The "parent" field is initialised
   to  NULL  here   and  reinitialised  to  "cce_root_D"   later  by  an
   initialisation function. */
static alpha_D_t alpha_D = @{
  .parent               = NULL,
  .free                 = alpha_C_destructor,
  .static_message       = alpha_C_static_message
@};

cce_condition_t *
alpha_C_init (alpha_C_t * cnd, int alpha)
/* Initialise an already allocated condition object. */
@{
  cce_condition_init(cnd, &alpha_D);
  cnd->alpha = alpha;
  return cnd;
@}

void
alpha_C_final (alpha_C_t * cnd CCE_UNUSED)
/* Finalise a condition object; do not release memory. */
@{
  return;
@}

cce_condition_t *
alpha_C_constructor (int alpha)
/* Allocate and initialise an instance of condition object. */
@{
  alpha_C_t *   cnd;
  cnd = malloc(sizeof(alpha_C_t));
  assert(cnd);
  return alpha_C_init(cnd, alpha);
@}

static void
alpha_C_destructor (cce_condition_t * cnd)
/* Finalise and release memory of an instance of condition object. */
@{
  alpha_C_final((alpha_C_t *)cnd);
  free(cnd);
@}

static const char *
alpha_C_static_message (const cce_condition_t * cnd CCE_UNUSED)
@{
  return "exceptional condition A";
@}

bool
alpha_C_is_a (const cce_condition_t * condition)
@{
  return cce_is_a_condition(condition, &alpha_D);
@}

/*** Exceptional condition B. ***/

/* Exceptional condition  descriptor type.   The anonymous field  can be
   seen  as a  table of  virtual methods,  which are  overridden by  the
   subtypes. */
typedef struct beta_D_t @{
  cce_condition_descriptor_t;
@} beta_D_t;

/* Exceptional condition object type. */
typedef struct beta_C_t @{
  alpha_C_t;
  int                   beta;
@} beta_C_t;

cce_condition_t *       beta_C_init  (beta_C_t * cnd, int alpha, int beta);
void                    beta_C_final (beta_C_t * cnd);
cce_condition_t *       beta_C_constructor (int alpha, int beta);
static void             beta_C_destructor  (cce_condition_t * cnd);
static const char *     beta_C_static_message (const cce_condition_t * cnd);
bool			beta_C_is_a (const cce_condition_t * condition);

/* Instance of condition descriptor. */
static beta_D_t beta_D = @{
  .parent               = &alpha_D,
  .free                 = beta_C_destructor,
  .static_message       = beta_C_static_message
@};

cce_condition_t *
beta_C_init (beta_C_t * cnd, int alpha, int beta)
/* Initialise an already allocated condition object. */
@{
  alpha_C_init(cnd, alpha);
  cce_condition_init(cnd, &beta_D);
  cnd->beta = beta;
  return cnd;
@}

void
beta_C_final (beta_C_t * cnd)
/* Finalise a condition object; do not release memory. */
@{
  alpha_C_final((alpha_C_t *)cnd);
@}

cce_condition_t *
beta_C_constructor (int alpha, int beta)
/* Allocate and initialise an instance of condition object. */
@{
  beta_C_t *    cnd;

  cnd = malloc(sizeof(beta_C_t));
  assert(cnd);
  return beta_C_init(cnd, alpha, beta);
@}

static void
beta_C_destructor (cce_condition_t * cnd)
/* Finalise and release memory of an instance of condition object. */
@{
  beta_C_final((beta_C_t *)cnd);
  free(cnd);
@}

static const char *
beta_C_static_message (const cce_condition_t * cnd CCE_UNUSED)
@{
  return "exceptional condition B";
@}

bool
beta_C_is_a (const cce_condition_t * condition)
@{
  return cce_is_a_condition(condition, &beta_D);
@}

/*** Exceptional condition C. ***/

/* Exceptional condition  descriptor type.   The anonymous field  can be
   seen  as a  table of  virtual methods,  which are  overridden by  the
   subtypes. */
typedef struct gamma_D_t @{
  cce_condition_descriptor_t;
@} gamma_D_t;

/* Exceptional condition object type. */
typedef struct gamma_C_t @{
  beta_C_t;
  int                   gamma;
@} gamma_C_t;

cce_condition_t *       gamma_C_init  (gamma_C_t * cnd, int alpha, int beta, int gamma);
void                    gamma_C_final (gamma_C_t * cnd);
cce_condition_t *       gamma_C_constructor (int alpha, int beta, int gamma);
static void             gamma_C_destructor  (cce_condition_t * cnd);
static const char *     gamma_C_static_message (const cce_condition_t * cnd);
bool			gamma_C_is_a (const cce_condition_t * condition);

/* Instance of condition descriptor. */
static gamma_D_t gamma_D = @{
  .parent               = &beta_D,
  .free                 = gamma_C_destructor,
  .static_message       = gamma_C_static_message
@};

cce_condition_t *
gamma_C_init (gamma_C_t * cnd, int alpha, int beta, int gamma)
/* Initialise an already allocated condition object. */
@{
  beta_C_init(cnd, alpha, beta);
  cce_condition_init(cnd, &gamma_D);
  cnd->gamma = gamma;
  return cnd;
@}

void
gamma_C_final (gamma_C_t * cnd)
/* Finalise a condition object; do not release memory. */
@{
  beta_C_final((beta_C_t *)cnd);
@}

cce_condition_t *
gamma_C_constructor (int alpha, int beta, int gamma)
/* Allocate and initialise an instance of condition object. */
@{
  gamma_C_t *   cnd;

  cnd = malloc(sizeof(gamma_C_t));
  assert(cnd);
  return gamma_C_init(cnd, alpha, beta, gamma);
@}

static void
gamma_C_destructor (cce_condition_t * cnd)
/* Finalise and release memory of an instance of condition object. */
@{
  gamma_C_final((gamma_C_t *)cnd);
  free(cnd);
@}

static const char *
gamma_C_static_message (const cce_condition_t * cnd CCE_UNUSED)
@{
  return "exceptional condition C";
@}

bool
gamma_C_is_a (const cce_condition_t * condition)
@{
  return cce_is_a_condition(condition, &gamma_D);
@}

int
main (int argc CCE_UNUSED, const char *const argv[] CCE_UNUSED)
@{
  /* Dynamic initialisation. */
  alpha_D.parent        = cce_root_D;

  /* Raising condition object of type C. */
  @{
    cce_location_t      L[1];
    int                 flag;

    if (cce_location(L)) @{
      cce_condition_t * C = cce_condition(L);

      if (gamma_C_is_a(C)) @{
        gamma_C_t *     K = (gamma_C_t *)C;
        flag = K->gamma;
      @} else if (beta_C_is_a(C)) @{
        beta_C_t *      K = (beta_C_t *)C;
        flag = K->beta;
      @} else if (alpha_C_is_a(C)) @{
        alpha_C_t *     K = (alpha_C_t *)C;
        flag = K->alpha;
      @} else @{
        flag = 0;
      @}
      cce_run_error_handlers(L);
      cce_condition_free(C);
    @} else @{
      cce_raise(L, gamma_C_constructor(1, 2, 3));
      cce_run_cleanup_handlers(L);
    @}
    assert(3 == flag);
  @}

  /* Raising condition object of type B. */
  @{
    cce_location_t      L[1];
    int                 flag;

    if (cce_location(L)) @{
      cce_condition_t * C = cce_condition(L);

      if (gamma_C_is_a(C)) @{
        gamma_C_t *     K = (gamma_C_t *)C;
        flag = K->gamma;
      @} else if (beta_C_is_a(C)) @{
        beta_C_t *      K = (beta_C_t *)C;
        flag = K->beta;
      @} else if (alpha_C_is_a(C)) @{
        alpha_C_t *     K = (alpha_C_t *)C;
        flag = K->alpha;
      @} else @{
        flag = 0;
      @}
      cce_run_error_handlers(L);
      cce_condition_free(C);
    @} else @{
      cce_raise(L, beta_C_constructor(1, 2));
      cce_run_cleanup_handlers(L);
    @}
    assert(2 == flag);
  @}

  /* Raising condition object of type A. */
  @{
    cce_location_t      L[1];
    int                 flag;

    if (cce_location(L)) @{
      cce_condition_t * C = cce_condition(L);

      if (gamma_C_is_a(C)) @{
        gamma_C_t *     K = (gamma_C_t *)C;
        flag = K->gamma;
      @} else if (beta_C_is_a(C)) @{
        beta_C_t *      K = (beta_C_t *)C;
        flag = K->beta;
      @} else if (alpha_C_is_a(C)) @{
        alpha_C_t *     K = (alpha_C_t *)C;
        flag = K->alpha;
      @} else @{
        flag = 0;
      @}
      cce_run_error_handlers(L);
      cce_condition_free(C);
    @} else @{
      cce_raise(L, alpha_C_constructor(1));
      cce_run_cleanup_handlers(L);
    @}
    assert(1 == flag);
  @}

  exit(EXIT_SUCCESS);
@}
@end smallexample

@c page
@node posix
@chapter @posix{} system calls


@value{PACKAGE} defines function wrappers for the most common @posix{} system calls.  Each wrapper
accepts a pointer to @objtype{cce_location_t} as argument and, in case of error, will perform a
non--local exit by jumping to the selected location.

The raised exceptional condition objects are of type @objtype{cce_errno_C_t}; all the system call
wrappers make use of @cfunc{cce_errno_C_clear}, so they clear @code{errno} to zero before returning.

The wrapper functions accept the same arguments of the system call and return the same return value
of the system call (if it completes successfully).  All the wrappers reset @code{errno} to zero
before performing the system call.

@menu
* posix memory::                Memory allocation.
* posix io::                    Input/output system calls.
* posix process::               Process system calls.
@end menu

@c page
@node posix memory
@section Memory allocation


@menu
* posix memory calls::          System call wrappers.
* posix memory handler::        Exception handler for pointers.
@end menu

@c page
@node posix memory calls
@subsection System call wrappers


@deftypefun {void *} cce_sys_malloc (cce_location_t * @var{L}, size_t @var{size})
Wrapper for @cfunc{malloc}.  This function never returns @cnull{}.
@end deftypefun


@deftypefun {void *} cce_sys_realloc (cce_location_t * @var{L}, void * @var{ptr}, size_t @var{newsize})
Wrapper for @cfunc{realloc}.  This function never returns @cnull{}.
@end deftypefun


@deftypefun {void *} cce_sys_calloc (cce_location_t * @var{L}, size_t @var{count}, size_t @var{eltsize})
Wrapper for @cfunc{calloc}.  This function never returns @cnull{}.
@end deftypefun

@c page
@node posix memory handler
@subsection Exception handler for pointers


We can handle memory that must be released with the standard function @cfunc{free} as follows:

@example
cce_location_t              L[1];
cce_handler_malloc_t        H[1];

if (cce_location(L)) @{
  cce_run_error_handlers(L);
  cce_condition_free(cce_condition(L));
@} else @{
  void *        P = cce_sys_malloc(L, 4096);
  cce_cleanup_handler_malloc_init(L, H, P);
  cce_run_cleanup_handlers(L);
@}
@end example


@deftp {Struct Typedef} cce_handler_malloc_t
Type of data structures representing exceptional condition handlers for memory that must be released
with @cfunc{free}.  It is ``derived'' from @objtype{cce_handler_t}, meaning that the first field is
anonymous of type @objtype{cce_handler_t}.
@end deftp


@deftypefun void cce_cleanup_handler_malloc_init (cce_location_t * @var{L}, cce_handler_malloc_t * @var{H}, void * @var{P})
@deftypefunx void cce_error_handler_malloc_init (cce_location_t * @var{L}, cce_handler_malloc_t * @var{H}, void * @var{P})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
release the memory block referenced by @var{P} using the standard function @cfunc{free}.
@end deftypefun


@deftypefn {Preprocessor Macro} {cce_handler_malloc_t *} cce_cast_to_handler_malloc (cce_handler_t * @var{H})
Cast the pointer @var{H} to a pointer to @objtype{cce_handler_malloc_t}.  This macro is built upon
the @code{_Generic} keyword, so it allows compile--time type checking.
@end deftypefn

@c page
@node posix io
@section Input/output system calls


@menu
* posix io calls::              System call wrappers.
* posix io handler filedes::    Handler for file descriptors.
* posix io handler pipedes::    Handler for pipe descriptors.
* posix io handler tmpfile::    Handler for temporary files.
@end menu

@c page
@node posix io calls
@subsection System call wrappers


@deftypefun int cce_sys_open (cce_location_t * @var{L}, const char * @var{filename}, int @var{flags}, mode_t @var{mode})
Wrapper for @cfunc{open}.
@end deftypefun


@deftypefun int cce_sys_close (cce_location_t * @var{L}, int @var{filedes})
Wrapper for @cfunc{close}.
@end deftypefun


@deftypefun size_t cce_sys_read (cce_location_t * @var{L}, int @var{filedes}, void * @var{buffer}, size_t @var{size})
Wrapper for @cfunc{read}.  Notice the return value of type @objtype{size_t}: the negative values
returned by @cfunc{read} are consumed by this function, so the return value is an unsigned integer.
@end deftypefun


@deftypefun size_t cce_sys_pread (cce_location_t * @var{L}, int @var{filedes}, void * @var{buffer}, size_t @var{size}, off_t @var{offset})
Wrapper for @cfunc{pread}.  Notice the return value of type @objtype{size_t}: the negative values
returned by @cfunc{pread} are consumed by this function, so the return value is an unsigned integer.
@end deftypefun


@deftypefun size_t cce_sys_write (cce_location_t * @var{L}, int @var{filedes}, const void * @var{buffer}, size_t @var{size})
Wrapper for @cfunc{write}.  Notice the return value of type @objtype{size_t}: the negative values
returned by @cfunc{write} are consumed by this function, so the return value is an unsigned integer.
@end deftypefun


@deftypefun size_t cce_sys_pwrite (cce_location_t * @var{L}, int @var{filedes}, const void * @var{buffer}, size_t @var{size}, off_t @var{offset})
Wrapper for @cfunc{pwrite}.  Notice the return value of type @objtype{size_t}: the negative values
returned by @cfunc{pwrite} are consumed by this function, so the return value is an unsigned
integer.
@end deftypefun


@deftypefun off_t cce_sys_lseek (cce_location_t * @var{L}, int @var{filedes}, off_t @var{offset}, int @var{whence})
Wrapper for @cfunc{lseek}.
@end deftypefun


@deftypefun size_t cce_sys_readv (cce_location_t * @var{L}, int @var{filedes}, const struct iovec * @var{vector}, int @var{count})
Wrapper for @cfunc{readv}.  Notice the return value of type @objtype{size_t}: the negative values
returned by @cfunc{readv} are consumed by this function, so the return value is an unsigned integer.
@end deftypefun


@deftypefun size_t cce_sys_writev (cce_location_t * @var{L}, int @var{filedes}, const struct iovec * @var{vector}, int @var{count})
Wrapper for @cfunc{writev}.  Notice the return value of type @objtype{size_t}: the negative values
returned by @cfunc{writev} are consumed by this function, so the return value is an unsigned
integer.
@end deftypefun


@deftypefun {void *} cce_sys_mmap (cce_location_t * @var{L}, void * @var{address}, size_t @var{length}, int @var{protect}, int @var{flags}, int @var{filedes}, off_t @var{offset})
Wrapper for @cfunc{mmap}.
@end deftypefun


@deftypefun int cce_sys_munmap (cce_location_t * @var{L}, void * @var{addr}, size_t @var{length})
Wrapper for @cfunc{munmap}.
@end deftypefun


@deftypefun int cce_sys_msync (cce_location_t * @var{L}, void * @var{address}, size_t @var{length}, int @var{flags})
Wrapper for @cfunc{msync}.
@end deftypefun


@deftypefun int cce_sys_mprotect (cce_location_t * @var{L}, void * @var{addr}, size_t @var{len}, int @var{prot})
Wrapper for @cfunc{mprotect}.
@end deftypefun


@deftypefun int cce_sys_select (cce_location_t * @var{L}, int @var{nfds}, fd_set * @var{read_fds}, fd_set * @var{write_fds}, fd_set * @var{except_fds}, struct timeval * @var{timeout})
Wrapper for @cfunc{select}.
@end deftypefun


@deftypefun int cce_sys_dup (cce_location_t * @var{L}, int @var{old})
Wrapper for @cfunc{dup}.
@end deftypefun


@deftypefun int cce_sys_dup2 (cce_location_t * @var{L}, int @var{old}, int @var{new})
Wrapper for @cfunc{dup2}.
@end deftypefun


@deftypefun void cce_sys_pipe (cce_location_t * @var{L}, int @var{pipefd}[2])
Wrapper for @cfunc{pipe}.
@end deftypefun


@deftypefun int cce_sys_mkstemp (cce_location_t * @var{L}, char * @var{template})
Wrapper for @cfunc{mkstemp}.  Remember that this call will mutate @var{template}.
@end deftypefun


@deftypefun {char *} cce_sys_mkdtemp (cce_location_t * @var{L}, char * @var{template})
Wrapper for @cfunc{mkdtemp}.  This function never returns @cnull{}.  Remember that this call will
mutate @var{template}.
@end deftypefun

@c page
@node posix io handler filedes
@subsection Handler for file descriptors


We can handle file descriptors that must be released with the standard function @cfunc{close} as
follows:

@example
cce_location_t              L[1];
cce_handler_filedes_t       H[1];

if (cce_location(L)) @{
  cce_run_error_handlers(L);
  cce_condition_free(cce_condition(L));
@} else @{
  int   fd = cce_sys_open("name.ext", O_CREAT, S_IRWXU);
  cce_cleanup_handler_filedes_init(L, H, fd);
  cce_run_cleanup_handlers(L);
@}
@end example


@deftp {Struct Typedef} cce_handler_filedes_t
Type of data structures representing exceptional condition handlers for file descriptors that must
be released with @cfunc{close}.  It is ``derived'' from @objtype{cce_handler_t}, meaning that the
first field is anonymous of type @objtype{cce_handler_t}.
@end deftp


@deftypefun void cce_cleanup_handler_filedes_init (cce_location_t * @var{L}, cce_handler_filedes_t * @var{H}, int @var{fd})
@deftypefunx void cce_error_handler_filedes_init (cce_location_t * @var{L}, cce_handler_filedes_t * @var{H}, int @var{fd})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
release the file descriptor @var{fd} using the standard function @cfunc{close}; errors in
@cfunc{close} are @strong{ignored}.
@end deftypefun


@deftypefn {Preprocessor Macro} {cce_handler_filedes_t *} cce_cast_to_handler_filedes (cce_handler_t * @var{H})
Cast the pointer @var{H} to a pointer to @objtype{cce_handler_filedes_t}.  This macro is built upon
the @code{_Generic} keyword, so it allows compile--time type checking.
@end deftypefn

@c page
@node posix io handler pipedes
@subsection Handler for file descriptors


We can handle file descriptors that must be released with the standard function @cfunc{close} as
follows:

@example
cce_location_t              L[1];
cce_handler_pipedes_t       H[1];

if (cce_location(L)) @{
  cce_run_error_handlers(L);
  cce_condition_free(cce_condition(L));
@} else @{
  int   pipedes[2]
  cce_sys_pipe(L, pipedes);
  cce_cleanup_handler_pipedes_init(L, H, pipedes);
  cce_run_cleanup_handlers(L);
@}
@end example


@deftp {Struct Typedef} cce_handler_pipedes_t
Type of data structures representing exceptional condition handlers for file descriptors created by
@cfunc{pipe} that must be released with @cfunc{close}.  It is ``derived'' from
@objtype{cce_handler_t}, meaning that the first field is anonymous of type @objtype{cce_handler_t}.
@end deftp


@deftypefun void cce_cleanup_handler_pipedes_init (cce_location_t * @var{L}, cce_handler_pipedes_t * @var{H}, int @var{pipedes}[2])
@deftypefunx void cce_error_handler_pipedes_init (cce_location_t * @var{L}, cce_handler_pipedes_t * @var{H}, int @var{pipedes}[2])
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
release the file descriptors in @var{pipedes} using the standard function @cfunc{close}; errors in
@cfunc{close} are @strong{ignored}.
@end deftypefun


@deftypefn {Preprocessor Macro} {cce_handler_pipedes_t *} cce_cast_to_handler_pipedes (cce_handler_t * @var{H})
Cast the pointer @var{H} to a pointer to @objtype{cce_handler_pipedes_t}.  This macro is built upon
the @code{_Generic} keyword, so it allows compile--time type checking.
@end deftypefn

@c page
@node posix io handler tmpfile
@subsection Handler for temporary files


We can remove temporary files with the standard function @cfunc{remove} as follows:

@example
cce_location_t              L[1];
cce_handler_tmpfile_t       H[1];

if (cce_location(L)) @{
  cce_run_error_handlers(L);
  cce_condition_free(cce_condition(L));
@} else @{
  int   fd = cce_sys_open(L, "name.ext", O_CREAT|O_EXCL,
                          S_IRUSR|S_IWUSR);
  cce_cleanup_handler_filedes_init(L, H, fd);
  cce_cleanup_handler_tmpfile_init(L, H, "name.ext");
  cce_run_cleanup_handlers(L);
@}
@end example

The handler documented here will ignore errors returned by @cfunc{remove}, which is generally bad;
we can use the source code of this handler as template to implement a more complete procedure.
Remember that a good way to create temporary files is to use the @posix{} standard function
@cfunc{mkstemp}.


@deftp {Struct Typedef} cce_handler_tmpfile_t
Type of data structures representing exceptional condition handlers for the removal of temporary
files.  It is ``derived'' from @objtype{cce_handler_t}, meaning that the first field is anonymous of
type @objtype{cce_handler_t}.
@end deftp


@deftypefun void cce_cleanup_handler_tmpfile_init (cce_location_t * @var{L}, cce_handler_tmpfile_t * @var{H}, const char * @var{pathname})
@deftypefunx void cce_error_handler_tmpfile_init (cce_location_t * @var{L}, cce_handler_tmpfile_t * @var{H}, const char * @var{pathname})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
remove the file whose pathname is @var{pathname} using the standard function @cfunc{remove}; errors
in @cfunc{remove} are @strong{ignored}.

The string referenced by @var{pathname} is duplicated and stored in the structure referenced by
@var{H}.

If an error occurs while configuring the handler: and exception is raised by performing a non--local
exit to @var{L}.
@end deftypefun


@deftypefn {Preprocessor Macro} {cce_handler_tmpfile_t *} cce_cast_to_handler_tmpfile (cce_handler_t * @var{H})
Cast the pointer @var{H} to a pointer to @objtype{cce_handler_tmpfile_t}.  This macro is built upon
the @code{_Generic} keyword, so it allows compile--time type checking.
@end deftypefn

@c page
@node posix process
@section Process system calls


@deftypefun int cce_sys_fork (cce_location_t * @var{L})
Wrapper for @cfunc{fork}.
@end deftypefun


@deftypefun void cce_sys_waitpid (cce_location_t * @var{L}, pid_t @var{pid}, int * @var{wstatus}, int @var{options})
Wrapper for @cfunc{waitpid}.
@end deftypefun

@c page
@node helpers
@chapter Helper functions and macros


@deffn {Preprocessor Macro} CCE_PC (@var{TYPE}, @var{X}, @var{Y})
Pointer--type cast helper.  It expands into:

@example
@var{TYPE} * @var{X} = (@var{TYPE} *) (@var{Y})
@end example

So, for example, instead of writing:

@example
cce_location_t    L[1];
cce_condition_t * C = cce_condition(L);
cce_errno_C_t   * K = (cce_errno_C_t *) C;
@end example

@noindent
we can write:

@example
cce_location_t    L[1];
cce_condition_t * C = cce_condition(L);
CCE_PC(cce_errno_C_t, K, C);
@end example
@end deffn

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DOCUMENTATION_URL}

@noindent
the latest release of this package can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

