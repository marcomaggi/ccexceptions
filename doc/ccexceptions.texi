\input texinfo.tex
@c %**start of header
@setfilename ccexceptions.info
@settitle CCExceptions
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCExceptions

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCExceptions

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccexceptions

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2016-2017

@c ------------------------------------------------------------

@set GITHUB_URL                 @url{http://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BITBUCKET_URL              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DOWNLOAD_URL               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DOCUMENTATION_URL          @url{http://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library requiring
@gcc{} extensions; it implements an interface to non--local exits, which is somewhat similar to
exceptions handling.

The package is distributed under the terms of the @gnu{} General Public License (@gpl{}).

The latest release can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front--Cover Texts, and no
Back--Cover Texts.  A copy of the license is included in the section
entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccexceptions: (ccexceptions).       CCExceptions a C language library
                                      implementing exceptions handling.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* setjmp::                      Brief introduction to non-local exits.
* extensions::                  Introductions to @code{plan9-extensions}.
* locations::                   The locations @api{}.
* handlers::                    The handlers @api{}.
* conditions::                  Exceptional condition descriptors.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library requiring
@gcc{} extensions; it implements an interface to non--local exits, which is somewhat similar to
exceptions handling.

This tiny library will not solve the problem of error handling in the C language, it just brings a
little order in the mess resulting from hand--coding the error handling logic.

@value{PACKAGE} installs the single header file @file{ccexceptions.h}.  All the function names in
the @api{} are prefixed with @code{cce_}; all the constant names are prefixed with @code{CCE_}; all
the type names are prefixed with @code{cce_} and suffixed with @code{_t}.

@value{PACKAGE}'s location mechanism has the following purposes:

@enumerate
@item
Implement non--local exits in a way that allows client code to be
shorter and simpler to understand.

@item
Implement non--local exit handlers to perform synchronous clean--up operations.

@item
Implement a simple exceptional condition descriptors interface.
@end enumerate

@noindent
these features come at the cost of slowing down execution in a possibly sensible way (with respect
to, for example, hand--coded @code{goto} instructions that jump to labels).

@menu
* overview linking::            Linking code with the library.
@end menu

@c page
@node overview linking
@section Linking code with the library


This package installs a data file for @command{pkg-config}, so when searching for the installed
library with the @gnu{} Autotools, we can:

@itemize
@item
Add the following macro use to @file{configure.ac}:

@example
PKG_CHECK_MODULES([CCEXCEPTIONS],[ccexceptions >= 0.1])
@end example

@noindent
which will set the variables @code{CCEXCEPTIONS_LIBS} and @code{CCEXCEPTIONS_CFLAGS}.
@end itemize

Alternatively we can use the raw @gnu{} Autoconf macros:

@example
AC_CHECK_LIB([ccexceptions],[cce_version_string],,
  [AC_MSG_FAILURE([test for CCExceptions library failed])])
AC_CHECK_HEADERS([ccexceptions.h],,
  [AC_MSG_FAILURE([test for CCExceptions header failed])])
@end example

We need to remember that client code using @value{PACKAGE}'s library must be written using the C11
language and the @gcc{} extensions enabled by @option{-fplan9-extensions}.

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the
@gnu{} Autotools.  For an explanation of interface numbers as managed by
@gnu{} Libtool @xref{Libtool versioning, interface, Libtool's versioning
system, libtool, Shared library support for @gnu{}}.


@deftypefun {const char *} cce_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing
the interface version number.
@end deftypefun


@deftypefun int cce_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int cce_version_interface_revision (void)
Return an integer representing the library interface current revision
number.
@end deftypefun


@deftypefun int cce_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node setjmp
@chapter Brief introduction to non--local exits


Let's recall briefly how the standard, C language, non--local exits mechanism works; for the full
documentation refer to the C Library.  @glibcref{Non-Local Exits, Non-Local Exits}.

To use @cfunc{setjmp} and @cfunc{longjmp} we write chunks of code like the following:

@example
#define JMP_ERROR_CODE          1

jmp_buf  here;

if (setjmp(here))
  @{
    handle_the_error();
  @}
else
  @{
    do_something();
    if (an_error_occurred()) @{
      longjmp(here, JMP_ERROR_CODE);
    @}
    do_something_else();
  @}
@end example

@noindent
this is what happens:

@itemize
@item
When @cfunc{setjmp} is invoked: it saves the current ``position'' in @var{here}, then it returns
zero.

@item
If @cfunc{longjmp} is not applied to @var{here}, nothing strange happens and the execution flow goes
on as usual.

@item
If @cfunc{longjmp} is applied to @var{here}: the execution jumps back to the call to @cfunc{setjmp}
with @code{JMP_ERROR_CODE} as return value.
@end itemize

This mechanism allows us to separate the exception handling code from the main code.  By using
@var{here} as argument to nested function calls: we can perform non--local exits across functions;
something that is not possible with @code{goto} statements.

As always, care must be taken when the body allocates asynchronous resources.  For each resource:
the exception handler must detect if the allocation took place and execute release code.  For
example:

@example
#define DO_NOT_SAVE_SIGS        0
#define JMP_ERROR_CODE          1

jmp_buf         here;
volatile void * P = NULL;

if (setjmp(here))
  @{
    if (P)
      free(P);
  @}
else
  @{
    ...
    P = malloc(4096);
    ...
  @}
@end example

Let's see some logic example; we will assume the following preamble:

@example
#include <assert.h>
#include <stdlib.h>
#include <setjmp.h>

#define DO_NOT_SAVE_SIGS        0
#define JUMP_TO_ERROR           2
#define JUMP_TO_RETRY           3
@end example

In the following code no jump is performed; we just call @cfunc{setjmp} once and never call
@cfunc{longjmp}:

@example
jmp_buf         L;
int             flag = 0, code;

code = setjmp(L);
if (code) @{
  flag = 2;
@} else @{
  flag = 1;
@}
assert(0 == code);
assert(1 == flag);
@end example

In the following code we perform a jump and handle the logic with an @code{if} statement:

@example
jmp_buf         L;
int             flag = 0, code;

code = setjmp(L);
if (JUMP_TO_ERROR == code) @{
  flag = 2;
@} else @{
  flag = 1;
  longjmp(L, JUMP_TO_ERROR);
@}
assert(JUMP_TO_ERROR == code);
assert(2 == flag);
@end example

In the following code we perform a jump and handle the logic with a @code{switch} statement:

@example
jmp_buf         L;
int             flag = 0, code;

code = setjmp(L);
switch (code) @{
case JUMP_TO_ERROR:
  flag = 2;
  break;
default:
  flag = 1;
  longjmp(L, JUMP_TO_ERROR);
@}
assert(JUMP_TO_ERROR == code);
assert(2 == flag);
@end example

In the following code we perform a jump and try an alternative body; we handle the logic with a
@code{switch} statement:

@example
jmp_buf         L;
int             flag = 0, code;

code = setjmp(L);
switch (code) @{
case JUMP_TO_ERROR:
  flag = 2;
  longjmp(L, JUMP_TO_RETRY);
  break;
case JUMP_TO_RETRY:
  // the alternative body
  flag = 3;
  break;
default:
  // the body
  flag = 1;
  longjmp(L, JUMP_TO_ERROR);
@}
assert(JUMP_TO_RETRY == code);
assert(3 == flag);
@end example

In the following code we perform a jump and retry the body several times:

@example
jmp_buf         L;
int             flag = 0, code;
volatile int    times = 0;

code = setjmp(L);
switch (code) @{
case JUMP_TO_ERROR:
  flag = 2;
  longjmp(L, JUMP_TO_RETRY);
  break;
default:
  if ((JUMP_TO_RETRY == code) && (times < 5)) @{
    // retrying
    ++times;
    longjmp(L, JUMP_TO_ERROR);
  @} else if (JUMP_TO_RETRY == code) @{
    flag = 3;
  @} else @{
    // the body
    flag = 1;
    longjmp(L, JUMP_TO_ERROR);
  @}
@}
assert(JUMP_TO_RETRY == code);
assert(3 == flag);
@end example

@c page
@node extensions
@chapter Introductions to @code{plan9-extensions}


The @url{http://www.gnu.org/software/gcc/, @gnu{} C language compiler} supports the
@url{https://en.wikipedia.org/wiki/C11_(C_standard_revision), C11} standard, with some extensions,
through the @option{-fplan9-extensions} option.  From a certain point of view, these extensions are
just the default offered by the C++ language; but under the C language they are very useful.
@value{PACKAGE} is meant to use such extensions.

Here is an example:

@example
/* demo.c --
 *
 * Compile this with:
 *
 *  $ gcc -std=c11 -Wall -fplan9-extensions -o demo demo.c
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct @{
  int   one;
@} alpha_t;

typedef struct @{
  alpha_t;
  int           two;
@} beta_t;

void
print_alpha (alpha_t * self)
@{
  fprintf(stderr, "alpha: %d\n", self->one);
@}
void
print_beta (beta_t * self)
@{
  fprintf(stderr, "beta: %d %d\n", self->one, self->two);
@}

int
main (int argc, const char *const argv[])
@{
  beta_t        B = @{ .one = 1, .two = 2 @};
  print_alpha(&B);
  print_beta (&B);
  exit(EXIT_SUCCESS);
@}

/* end of file */
@end example

@noindent
we see that the definition of @code{beta_t} contains an unnamed field of type
@code{alpha_t}:

@example
typedef struct @{
  alpha_t;
  int           two;
@} beta_t;
@end example

@noindent
and we can access its fields, nested in an instance of @code{beta_t}, transparently
both in the initialiser:

@example
beta_t B = @{ .one = 1, .two = 2 @};
@end example

@noindent
and from a pointer to @code{beta_t} in the function @cfunc{print_beta}:

@example
fprintf(stderr, "beta: %d %d\n", self->one, self->two);
@end example

Also, when a pointer to @code{beta_t} is used as operand for a function expecting a
pointer to @code{alpha_t} as argument: the pointer conversion is performed
automatically by the compiler, without the need to cast it explicitly.  So we can
simply write:

@example
print_alpha(&B);
@end example

@noindent
rather than:

@example
print_alpha((alpha_t *)&B);
@end example



@c page
@node locations
@chapter The locations @api{}


Non--local exits are a way to transfer execution from one point to another in a program; they are
implemented by the standard C library through the @cfunc{setjmp} and @cfunc{longjmp} functions.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_location_tag_t
Struct type representing the location context.  It contains an instance of @code{setjmp_buf} which
is the target of the @cfunc{longjmp} calls.  It has the following public fields:

@table @code
@item const cce_condition_t * condition
Pointer to an exceptional condition descriptor.  It is set by @cfunc{cce_raise} and
@cfunc{cce_retry}.  The client code is responsible of releasing resources associated to this value.
@end table
@end deftp


@deftp {One-Element Array Typedef} cce_location_t
It is defined as follows:

@example
typedef cce_location_tag_t      cce_location_t[1];
@end example

This type is convenient to define an instance of location.
@end deftp


@deftypefun void cce_location_init (cce_location_tag_t * @var{L})
Initialise the location @var{L}, but do @strong{not} call @cfunc{setjmp}.  We are not meant to call
this function directly; rather we should use the macro @cfunc{cce_location}.
@end deftypefun


@deftypefn {Preprocessor Macro} int cce_location (cce_location_tag_t * @var{L})
Initialise the location @var{L}; call @cfunc{setjmp} and return its return value.
@end deftypefn


@deftypevr Constant int CCE_SUCCESS
Constant used by the library as non--local exit code.  It is defined as @code{0} and it represents
the return value of @cfunc{cce_location} at the first evaluation.
@end deftypevr


@deftypevr Constant int CCE_ERROR
Constant used by the library as non--local exit code.  It is the return value of
@cfunc{cce_location} when a non--local exit is performed by @cfunc{cce_raise}.
@end deftypevr


@deftypevr Constant int CCE_RETRY
Constant used by the library as non--local exit code.  It is the return value of
@cfunc{cce_location} when a non--local exit is performed by @cfunc{cce_retry}.
@end deftypevr


@deftypefun void cce_raise (cce_location_tag_t * @var{L}, const cce_condition_t * @var{C})
Raise an exception associated to the destination @var{L} and with exceptional condition descriptor
@var{C}.  This function performs the call to @cfunc{longjmp} with code @code{CCE_ERROR}.

If @var{C} is @cnull{}: an internal, statically allocated, exceptional condition descriptor is
selected to represent an ``unknown exceptional condition''.
@end deftypefun


@deftypefun void cce_retry (cce_location_tag_t * @var{L})
Raise an exception associated to the destination @var{L} with the purpose or retrying the body
evaluation.  This function performs the call to @cfunc{longjmp} with code @code{CCE_RETRY}.

This function selects an internal, statically allocated, exceptional condition descriptor to
represent an ``unknown exceptional condition''.
@end deftypefun


@deftypefun {cce_condition_t *} cce_location_condition (cce_location_tag_t * @var{L})
Return the current value of the field @code{condition} in the location @var{L}.  This value is
@strong{never} @cnull{} if an exceptional condition is raised with @cfunc{cce_raise} or
@cfunc{cce_retry}.
@end deftypefun


It is suggested to use @code{switch} statements to organise the logic of location mechanisms.  The
basic scheme is as follows:

@example
cce_location_t  L;

switch (cce_location (L)) @{
case CCE_ERROR:
  handle_the_exception();
  break;

default:
  do_something();
  if (some_error()) @{
    cce_raise(L, NULL);
  @}
@}
@end example

If we want to distinguish between the main body and the retry body, we do:

@example
cce_location_t  L;

switch (cce_location (L)) @{
case CCE_ERROR:
  handle_the_exception();
  break;

case CCE_RETRY:
  retry_doing_something();
  break;

default:
  do_something();
  if (some_recoverable_error()) @{
    cce_retry(L);
  @} else if (some_error()) @{
    cce_raise(L, NULL);
  @}
@}
@end example

@noindent
and we can fall through:

@example
cce_location_t  L;

switch (cce_location (L)) @{
case CCE_ERROR:
  handle_the_exception();
  break;

case CCE_RETRY:
  prepare_to_retry();
  // fall through

default:
  do_something();
  if (some_recoverable_error()) @{
    cce_retry(L);
  @} else if (some_error()) @{
    cce_raise(L, NULL);
  @}
@}
@end example

@c page
@node handlers
@chapter The handlers @api{}


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_handler_tag_t
Struct type representing a cleanup or error handler.  Instances of this type are associated to a
location by calling one of the functions @cfunc{cce_register_*_handler}.  Handlers are invoked by
calling one of the functions @cfunc{cce_run_*_handlers}.

We are meant to wrap instances of this type into an enclosing struct definition as follows:

@example
struct resource_handler_t @{
  cce_handler_tag_t	handler;
  void *		resourcep;
@};
@end example

@noindent
in which the instance of @code{cce_handler_tag_t} is the first field.

The structure has the following public fields:

@table @code
@item cce_handler_fun_t * handler_function
Pointer to the function implementing the handler.
@end table
@end deftp


@deftypefn {Function Typedef} void cce_handler_fun_t (cce_location_tag_t * @var{L}, void * @var{H})
Type of handler functions.  The argument @var{L} references the location.  The argument @var{H}
references the handler context.
@end deftypefn


@deftp {One-Element Array Typedef} cce_handler_t
It is defined as follows:

@example
typedef cce_handler_tag_t      cce_handler_t[1];
@end example

In some cases, this type is convenient to define an instance of handler structure.
@end deftp


@deftypefun void cce_register_cleanup_handler (cce_location_tag_t * @var{L}, void * @var{H})
Register the cleanup handler referenced by @var{H} in the list of handlers associated to the
location @var{L}.  The pointer @var{H} must reference an instance of structure whose first field is
a structure of type @code{cce_handler_tag_t}; such structure is meant to be allocated on the stack
frame of the function also defining the location @var{L}.

A cleanup handler is meant to be called whenever the execution flow leaves the dynamic extent of a
location, whether with an exception or as part of the successful execution path.
@end deftypefun


@deftypefun void cce_register_error_handler (cce_location_tag_t * @var{L}, void * @var{H})
Register the error handler referenced by @var{H} in the list of handlers associated to the location
@var{L}.  The pointer @var{H} must reference an instance of structure whose first field is a
structure of type @code{cce_handler_tag_t}; such structure is meant to be allocated on the stack
frame of the function also defining the location @var{L}.

An error handler is meant to be called whenever the execution flow leaves the dynamic extent of a
location in case of an exception; it must not be called as part of the successful execution path.
@end deftypefun


@deftypefun void cce_run_cleanup_handlers (cce_location_tag_t * @var{L})
Run all the cleanup handlers associated to the location @var{L}.  Each handler must return to its
caller, taking care of itself regarding internal error handling and asynchronous resources
allocation.  Handlers are called starting from the last registered one.
@end deftypefun


@deftypefun void cce_run_error_handlers (cce_location_tag_t * @var{L})
Run all the error handlers associated to the location @var{L}.  Each handler must return to its
caller, taking care of itself regarding internal error handling and asynchronous resources
allocation.  Handlers are called starting from the last registered one.

@strong{NOTE} It is always better to assume that an error handler might access the exceptional
condition object associated to @var{L}, so this function should always be called @strong{before}
applying @cfunc{cce_condition_free} to the return value of @cfunc{cce_location_condition}.
@end deftypefun


For convenience, in the following examples: we will use nested C function definitions, which are a
@gnu{} C Compiler's extension.  We could define and call a list of cleanup handlers as follows:

@example
void handler1 (cce_location_tag_t * L, void * H) @{
  do_some_cleanup();
@}
void handler2 (cce_location_tag_t * L, void * H) @{
  do_some_cleanup();
@}
void handler3 (cce_location_tag_t * L, void * H) @{
  do_some_cleanup();
@}

cce_location_t     L;
cce_handler_tag_t  H1 = @{ .handler_function = handler1 @};
cce_handler_tag_t  H2 = @{ .handler_function = handler2 @};
cce_handler_tag_t  H3 = @{ .handler_function = handler3 @};

cce_location_init(L);
cce_register_cleanup_handler(L, &H1);
cce_register_cleanup_handler(L, &H2);
cce_register_cleanup_handler(L, &H3);
cce_run_cleanup_handlers(L);
@end example

@noindent
and we could define and call a list of error handlers as follows:

@example
void handler1 (cce_location_tag_t * L, void * H) @{
  do_some_error_handling();
@}
void handler2 (cce_location_tag_t * L, void * H) @{
  do_some_error_handling();
@}
void handler3 (cce_location_tag_t * L, void * H) @{
  do_some_error_handling();
@}

cce_location_t     L;
cce_handler_tag_t  H1 = @{ .handler_function = handler1 @};
cce_handler_tag_t  H2 = @{ .handler_function = handler2 @};
cce_handler_tag_t  H3 = @{ .handler_function = handler3 @};

cce_location_init(L);
cce_register_error_handler(L, &H1);
cce_register_error_handler(L, &H2);
cce_register_error_handler(L, &H3);
cce_run_error_handlers(L);
@end example

Let's say we need to allocate memory, and to release it whenever the dynamic extent of the local
function terminates; we can organise the code as follows, using a cleanup handler:

@example
cce_location_t      L;
cce_handler_t       HP;
void *              P;

void P_handler (cce_location_tag_t * L, void * H) @{
  free(P);
@}
HP->handler_function = P_handler;

if (CCE_ERROR == cce_location(L)) @{
  cce_run_error_handlers(L);
@} else @{
  P = malloc(4096);
  if (P) @{
    cce_register_cleanup_handler(L, HP);
  @} else @{
    cce_raise(L, NULL);
  @}
  do_something(L, P);
  cce_run_cleanup_handlers(L);
@}
@end example

@noindent
whether @cfunc{do_something} raises an exception or not: the cleanup handler is invoked and the
memory is released.

Let's say we are writing a constructor and we need to allocate memory, do something and, if
successful, return the memory to the caller; we can organise the code as follows, using an error
handler in the constructor and a cleanup handler in the caller:

@example
void *
constructor (cce_location_tag_t * upper_L)
@{
  cce_location_t    L;
  cce_handler_t     HP;
  void *            P;

  void P_handler (cce_location_tag_t * L, void * H) @{
    free(P);
  @}
  HP->handler_function = P_handler;

  if (CCE_ERROR == cce_location(L)) @{
    cce_run_error_handlers(L);
    cce_raise(upper_L, NULL);
  @} else @{
    P = malloc(4096);
    if (P) @{
      cce_register_error_handler(L, HP);
    @} else @{
      cce_raise(L, NULL);
    @}
    do_some_initialisation_in(P);
    cce_run_cleanup_handlers(L);
  @}
  return P;
@}

void caller (void)
@{
  cce_location_t    L;
  cce_handler_t     HP;
  void *            P;

  void P_handler (cce_location_tag_t * L, void * H) @{
    free(P);
  @}
  HP->handler_function = P_handler;

  if (CCE_ERROR == cce_location(L)) @{
    cce_run_error_handlers(L);
  @} else @{
    P = constructor(L);
    cce_register_cleanup_handler(L, HP);
    do_something_with(P);
    cce_run_cleanup_handlers(L);
  @}
@}
@end example

@c page
@node conditions
@chapter Exceptional condition descriptors


To represent exceptional conditions @value{PACKAGE} allows us to define a tree hierarchy of
exceptional condition objects.  With such a tree it is possible to react to a raised exception by
branching according to the type of raised condition object.

Every condition object is a structure of type @objtype{cce_condition_t}, which references a
condition descriptor of type @objtype{cce_condition_descriptor_t}.  The instances of
@objtype{cce_condition_descriptor_t} hold the pointers that define the tree hierarchy.

In the following picture: the condition descriptor @samp{A} is a child of the root descriptor; the
condition descriptor @samp{B} is a child of the condition descriptor @samp{A}.  We can say that: a
condition object of type @samp{A} is also of type root; a condition object of type @samp{B} is also
of type @samp{A} and of type root.

@example
                           ---------------------------
                          | root condition descriptor |
                           ---------------------------
                                        ^
                                        |
 --------------------        ------------------------
| condition object A |----> | condition descriptor A |
 --------------------        ------------------------
                                        ^
                                        |
 --------------------        ------------------------
| condition object B |----> | condition descriptor B |
 --------------------        ------------------------
@end example

@menu
* conditions types::            Core condition object types.
* conditions root::             Predefined root condition descriptor.
* conditions unknown::          Predefined unknown condition.
* conditions errno::            Predefined @code{errno} conditions.
* conditions operations::       Acting upon condition objects.
* conditions custom::           Defining custom condition objects.
@end menu

@c page
@node conditions types
@section Core condition object types


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftypefn {Function Prototype} void cce_condition_free_fun_t (cce_condition_t * @var{C})
Applied to a pointer to condition object: release all the dynamic resources associated to @var{C}.
@end deftypefn


@deftypefn {Function Prototype} void cce_condition_static_message_fun_t (const cce_condition_t * @var{C})
Applied to a pointer to condition object: return a statically allocated @asciiz{} string describing
the exceptional condition @var{C}.
@end deftypefn


@deftp {Struct Typedef} cce_condition_descriptor_t
Type of structures holding a table of function pointers to handle exceptional condition objects.  It
has the following fields:

@table @code
@item const cce_condition_descriptor_t * parent
Pointer to the condition descriptor that is parent of this one.  This pointer is set to @cnull{}
only for the root condition descriptor (@pxref{conditions root, Predefined root condition
descriptor}).

@item cce_condition_free_fun_t * free
Pointer to function which releases all the dynamic resources associated to the object.  This pointer
can be @cnull{}, meaning that there are no dynamic resources in the condition object.

@item cce_condition_static_message_fun_t * static_message
Pointer to function which returns a statically allocated @asciiz{} string describing the exceptional
condition.
@end table
@end deftp


@deftp {Struct Typedef} cce_condition_t
Type of structure representing an exceptional condition object.  It has the following fields:

@table @code
@item cce_condition_descriptor_t * descriptor
Pointer to the exceptional condition descriptor.
@end table
@end deftp

@c page
@node conditions root
@section Predefined root condition descriptor


The @dfn{root exceptional condition descriptor} has the only purpose of being the root of the
condition descriptors tree; there should be no condition objects having this descriptor.  The root
descriptor has @code{parent} field set to @cnull{}; this should be the only descriptor with such a
property.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftypevr {Dynamic Constant} {const cce_condition_descriptor_t *} cce_root_condition_descriptor
Pointer to a statically allocated structure representing the root condition descriptor for all the
condition descriptors.  When a condition descriptors hierarchy is correctly built: using this value
as second argument in calls to the functions:

@example
cce_condition_is_a()
cce_condition_descriptor_child_and_parent()
@end example

@noindent
will cause the return value to always be @ctrue{}.
@end deftypevr


To use this value in a custom condition descriptor definition, we must write initialisation code;
example:

@example
static const char *
default_static_message (const cce_condition_t * C CCE_UNUSED)
@{
  return "default message";
@}

cce_condition_descriptor_t A_condition_descriptor = @{
  .parent               = NULL,
  .free                 = NULL,
  .static_message       = default_static_message
@};

void
condition_descriptors_initialisation (void)
@{
  A_condition_descriptor.parent = cce_root_condition_descriptor;
@}
@end example

@noindent
and the function @cfunc{condition_descriptors_initialisation} must be called prior to using the
conditions system.

@c page
@node conditions unknown
@section Predefined unknown condition


The @dfn{unknown exceptional condition object} has the purpose of describing an exceptional
condition with unknown cause; it should be used only by:

@itemize
@item
The function @cfunc{cce_raise} when no condition object argument is used.

@item
The function @cfunc{cce_retry}.
@end itemize

There should be only one unknown condition object: the one predefined by @value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftypevr {Dynamic Constant} {const cce_condition_descriptor_t *} cce_unknown_condition_descriptor
Pointer to a statically allocated structure representing the unknown condition descriptor for the
single unknown condition object.  The parent of this descriptor is the root descriptor referenced by
@code{cce_root_condition_descriptor}.

By comparing this value to the @code{descriptor} field of a @objtype{cce_condition_t} structure we
can determine if the condition struct is an unknown condition object.
@end deftypevr


@deftypevr {Dynamic Constant} {const cce_condition_t *} cce_unknown_condition
Pointer to a statically allocated structure representing the unknown condition object.  This should
be the single condition object having @code{cce_unknown_condition_descriptor} as descriptor.
@end deftypevr

@c page
@node conditions errno
@section Predefined @code{errno} conditions


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_errno_condition_descriptor_t
Structure type representing the condition descriptor for @code{errno} condition objects.

In a correctly built condition objects hierarchy: there is only one instance of this type, the one
referenced by @code{cce_errno_condition_descriptor}; all the instances of
@code{cce_errno_condition_t} reference the same descriptor.

As single public field it has an unnamed field of type @code{cce_condition_descriptor_t}; the
sub--fields of this unnamed field can be accessed transparently by code using a pointer to
@objtype{cce_errno_condition_descriptor_t}.  For an @code{errno} condition descriptor the
@code{parent} sub--field is the root descriptor referenced by @code{cce_root_condition_descriptor}.
@end deftp


@deftp {Struct Typedef} cce_errno_condition_t
Structure type representing an @code{errno} exceptional condition object, signalled by a system
function by setting @code{errno} to a non--zero value.  It has the following public fields:

@table @code
@item cce_condition_t
An unnamed field holding everything required to make an instance of @code{cce_errno_condition_t}
also an instance of @code{cce_condition_t}.  For all the @code{errno} condition objects: the
condition descriptor referenced by the @code{descriptor} sub--field is the structure referenced by
@code{cce_errno_condition_descriptor}.

@item int errnum
The value of @code{errno}.

@item const char * message
A statically allocated string describing the error.
@end table
@end deftp


@deftypevr {Dynamic Constant} {const cce_condition_descriptor_t *} cce_errno_condition_descriptor
Pointer to a statically allocated structure representing the condition descriptor of all the values
returned by @cfunc{cce_errno_condition}.

By comparing this value to the @code{descriptor} field of a @objtype{cce_condition_t} structure, we
can determine if such structure is an @code{errno} condition object.
@end deftypevr


@deftypefun {cce_condition_t *} cce_errno_condition (int @var{errnum})
Given the @code{errno} code @var{errnum}, return the pointer to condition object associated to it.
The returned pointer it typed @objtype{cce_condition_t} but it references a structure of type
@objtype{cce_errno_condition_t}.

If @var{errnum} is zero: return a pointer to condition object representing a successful operation.
If @var{errnum} is not a valid @code{errno} code for the underlying platform: return a pointer to
condition object representing an invalid code.
@end deftypefun

@c page
@node conditions operations
@section Acting upon condition objects


Given a pointer to @code{cce_condition_t} we can act upon it with the following functions.  All the
following definitions are accessible from the header file @file{ccexceptions.h}.


@deftypefun void cce_condition_init (cce_condition_t * @var{condition}, const cce_condition_descriptor_t * @var{descriptor})
Initialise the core fields of an already allocated condition object.  The argument @var{condition}
must be a pointer to condition object, a structure of type @objtype{cce_condition_t}. The argument
@var{descriptor} must be a pointer to condition descriptor, a structure of type
@objtype{cce_condition_descriptor_t}.

The pointer @var{descriptor} is stored in @var{condition} to represent the condition descriptor.
@end deftypefun


@deftypefun bool cce_condition_is_a (const cce_condition_t * @var{condition}, const cce_condition_descriptor_t * @var{descriptor})
Establish if a condition object is of a selected type.  The argument @var{condition} must be a
pointer to condition object, a structure of type @objtype{cce_condition_t}. The argument
@var{descriptor} must be a pointer to condition descriptor, a structure of type
@objtype{cce_condition_descriptor_t}.  Return @ctrue{} if @var{condition} is an instance of type
@var{descriptor}, or an instance of a type that is parent of @var{descriptor}; otherwise return
@cfalse{}.
@end deftypefun


@deftypefun bool cce_condition_descriptor_child_and_parent (const cce_condition_descriptor_t * @var{child}, const cce_condition_descriptor_t * @var{parent})
Establish if two condition descriptors are child and parent.  Both the arguments @var{child} and
@var{parent} must be pointers to condition descriptors, structures of type
@objtype{cce_condition_descriptor_t}.  Return @ctrue{} if @var{child} is equal to @var{parent} or
@var{parent} is in the hierarchy of @var{child}'s parents; otherwise return @cfalse{}.
@end deftypefun


@deftypefun {const cce_condition_descriptor_t *} cce_condition_descriptor (const cce_condition_t * @var{condition})
Retrieve the descriptor of a condition object.  The argument @var{condition} must be a pointer to
condition object, a structure of type @objtype{cce_condition_t}.  Return the pointer to condition
descriptor in the @var{condition} object.  Using this function is the same as accessing the
@code{descriptor} field of a @objtype{cce_condition_t} structure.
@end deftypefun


@deftypefun void cce_condition_free (cce_condition_t * @var{C})
Applied to a pointer to condition descriptor: invoke the @code{free} function referenced by the
functions table.
@end deftypefun


@deftypefun {const char *} cce_condition_static_message (const cce_condition_t * @var{C})
Applied to a pointer to condition descriptor: invoke the @code{static_message} function referenced
by the functions table.
@end deftypefun


The basic usage pattern of condition descriptors is as follows:

@example
cce_location_t      L;

if (cce_location(L))
  @{
    cce_condition_t * C = cce_location_condition(L);
    @{
      fprintf(stderr, "log: %s\n", cce_condition_static_message(C));
      cce_run_error_handlers(L);
    @}
    cce_condition_free(C);
  @} else @{
    do_something();
    if (an_error_occurred()) @{
      cce_raise(L, select_condition_descriptor());
    @}
    cce_run_cleanup_handlers(L);
  @}
@end example

If we need to hand the condition descriptor to an upper level location we can do it as follows:

@example
void
upper_function (void)
@{
  cce_location_t        L;

  if (cce_location(L))
    @{
      cce_condition_t * C = cce_location_condition(L);
      @{
        do_something_with(cce_condition_static_message(C));
        cce_run_error_handlers(L);
      @}
      cce_condition_free(C);
    @}
  else
    @{
      lower_function(L);
      cce_run_cleanup_handlers(L);
    @}
@}

void
lower_function (cce_location_tag_t * upper_L)
@{
  cce_location_t        L;

  if (cce_location(L))
    @{
      cce_run_error_handlers(L);
      cce_raise(upper_L, cce_location_condition(L));
    @}
  else
    @{
      do_something();
      if (an_error_occurred()) @{
        cce_raise(L, select_condition_descriptor());
      @}
      cce_run_cleanup_handlers(L);
    @}
@}
@end example

If we need to branch according to a condition object's type, we can do it as follows using
@cfunc{cce_condition_is_a}:

@example
cce_location_t      L;

if (cce_location(L)) @{
  cce_condition_t * C = cce_location_condition(L);
  @{
    if (cce_condition_is_a(C, cce_unknown_condition_descriptor))
      @{
        do_something();
      @}
    else if (cce_condition_is_a(C, cce_errno_condition_descriptor))
      @{
        do_something();
      @}
    else
      @{
        do_something();
      @}
    cce_run_error_handlers(L);
  @}
  cce_condition_free(C);
@} else @{
  do_something();
  if (an_exception_occurred()) @{
    cce_raise(L, select_an_exception_object());
  @}
  cce_run_cleanup_handlers(L);
@}
@end example

@noindent
or as follows using @cfunc{cce_condition_descriptor_child_and_parent}:

@example
cce_location_t      L;

if (cce_location(L)) @{
  cce_condition_t *                 C  = cce_location_condition(L);
  const cce_condition_descriptor_t *CD = cce_condition_descriptor(C);
  @{
    if (cce_condition_descriptor_child_and_parent(CD,
           cce_unknown_condition_descriptor))
      @{
        do_something();
      @}
    else if (cce_condition_descriptor_child_and_parent(CD,
                cce_errno_condition_descriptor))
      @{
        do_something();
      @}
    else
      @{
        do_something();
      @}
    cce_run_error_handlers(L);
  @}
  cce_condition_free(C);
@} else @{
  do_something();
  if (an_exception_occurred()) @{
    cce_raise(L, select_an_exception_object());
  @}
  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node conditions custom
@section Defining custom condition objects


Let's say we want to define the following condition descriptors hierarchy:

@example
 ------       ---       ---       ---
| root | <-- | A | <-- | B | <-- | C |
 ------       ---       ---       ---
@end example

@noindent
where the condition objects of type @samp{A}, @samp{B} and @samp{C} have custom data structures.  We
do it as follows:

@smallexample
/* demo.c --
 *
 * Compile this with:
 *
 *  $ gcc -std=c11 -Wall -fplan9-extensions -lccexceptions \
 *      -o demo demo.c
 */

#include <stdlib.h>
#include <assert.h>
#include <ccexceptions.h>

/*** Exceptional condition A. ***/

/* Exceptional condition descriptor type.  The  field "core" can be seen
   as  a  table  of  virtual   methods,  which  are  overridden  by  the
   subtypes. */
typedef struct A_condition_descriptor_t @{
  cce_condition_descriptor_t;
@} A_condition_descriptor_t;

/* Exceptional condition object type. */
typedef struct A_condition_object_t @{
  cce_condition_t;
  int                   alpha;
@} A_condition_object_t;

cce_condition_t *       A_condition_init  (A_condition_object_t * cnd, int alpha);
void                    A_condition_final (A_condition_object_t * cnd);
cce_condition_t *       A_condition_constructor (int code);
static void             A_condition_destructor  (cce_condition_t * cnd);
static const char *     A_condition_static_message (const cce_condition_t * cnd);

/* Instance of condition descriptor.   The "parent" field is initialised
   to  NULL here  and  reinitialised to  "cce_root_condition_descriptor"
   later by an initialisation function. */
static A_condition_descriptor_t A_condition_descriptor = @{
  .parent               = NULL,
  .free                 = A_condition_destructor,
  .static_message       = A_condition_static_message
@};

cce_condition_t *
A_condition_init (A_condition_object_t * cnd, int alpha)
/* Initialise an already allocated condition object. */
@{
  cce_condition_init(cnd, &A_condition_descriptor);
  cnd->alpha = alpha;
  return cnd;
@}

void
A_condition_final (A_condition_object_t * cnd CCE_UNUSED)
/* Finalise a condition object; do not release memory. */
@{
  return;
@}

cce_condition_t *
A_condition_constructor (int alpha)
/* Allocate and initialise an instance of condition object. */
@{
  A_condition_object_t *        cnd;
  cnd = malloc(sizeof(A_condition_object_t));
  assert(cnd);
  return A_condition_init(cnd, alpha);
@}

static void
A_condition_destructor (cce_condition_t * cnd)
/* Finalise and release memory of an instance of condition object. */
@{
  A_condition_final((A_condition_object_t *)cnd);
  free(cnd);
@}

static const char *
A_condition_static_message (const cce_condition_t * cnd CCE_UNUSED)
@{
  return "exceptional condition A";
@}

bool
A_condition_is (void * condition)
@{
  return cce_condition_is_a(condition, (const cce_condition_descriptor_t *)&A_condition_descriptor);
@}

/*** Exceptional condition B. ***/

/* Exceptional condition descriptor type.  The  field "core" can be seen
   as  a  table  of  virtual   methods,  which  are  overridden  by  the
   subtypes. */
typedef struct B_condition_descriptor_t @{
  cce_condition_descriptor_t;
@} B_condition_descriptor_t;

/* Exceptional condition object type. */
typedef struct B_condition_object_t @{
  A_condition_object_t;
  int                   beta;
@} B_condition_object_t;

cce_condition_t *       B_condition_init  (B_condition_object_t * cnd, int alpha, int beta);
void                    B_condition_final (B_condition_object_t * cnd);
cce_condition_t *       B_condition_constructor (int alpha, int beta);
static void             B_condition_destructor  (cce_condition_t * cnd);
static const char *     B_condition_static_message (const cce_condition_t * cnd);

/* Instance of condition descriptor. */
static B_condition_descriptor_t B_condition_descriptor = @{
  .parent               = (const cce_condition_descriptor_t *)&A_condition_descriptor,
  .free                 = B_condition_destructor,
  .static_message       = B_condition_static_message
@};

cce_condition_t *
B_condition_init (B_condition_object_t * cnd, int alpha, int beta)
/* Initialise an already allocated condition object. */
@{
  A_condition_init(cnd, alpha);
  cce_condition_init(cnd, &B_condition_descriptor);
  cnd->beta = beta;
  return cnd;
@}

void
B_condition_final (B_condition_object_t * cnd)
/* Finalise a condition object; do not release memory. */
@{
  A_condition_final((A_condition_object_t *)cnd);
@}

cce_condition_t *
B_condition_constructor (int alpha, int beta)
/* Allocate and initialise an instance of condition object. */
@{
  B_condition_object_t *        cnd;

  cnd = malloc(sizeof(B_condition_object_t));
  assert(cnd);
  return B_condition_init(cnd, alpha, beta);
@}

static void
B_condition_destructor (cce_condition_t * cnd)
/* Finalise and release memory of an instance of condition object. */
@{
  B_condition_final((B_condition_object_t *)cnd);
  free(cnd);
@}

static const char *
B_condition_static_message (const cce_condition_t * cnd CCE_UNUSED)
@{
  return "exceptional condition B";
@}

bool
B_condition_is (void * condition)
@{
  return cce_condition_is_a(condition, (const cce_condition_descriptor_t *)&B_condition_descriptor);
@}

/*** Exceptional condition C. ***/

/* Exceptional condition descriptor type.  The  field "core" can be seen
   as  a  table  of  virtual   methods,  which  are  overridden  by  the
   subtypes. */
typedef struct C_condition_descriptor_t @{
  cce_condition_descriptor_t;
@} C_condition_descriptor_t;

/* Exceptional condition object type. */
typedef struct C_condition_object_t @{
  B_condition_object_t;
  int                   gamma;
@} C_condition_object_t;

cce_condition_t *       C_condition_init  (C_condition_object_t * cnd, int alpha, int beta, int gamma);
void                    C_condition_final (C_condition_object_t * cnd);
cce_condition_t *       C_condition_constructor (int alpha, int beta, int gamma);
static void             C_condition_destructor  (cce_condition_t * cnd);
static const char *     C_condition_static_message (const cce_condition_t * cnd);

/* Instance of condition descriptor. */
static C_condition_descriptor_t C_condition_descriptor = @{
  .parent               = (cce_condition_descriptor_t *)&B_condition_descriptor,
  .free                 = C_condition_destructor,
  .static_message       = C_condition_static_message
@};

cce_condition_t *
C_condition_init (C_condition_object_t * cnd, int alpha, int beta, int gamma)
/* Initialise an already allocated condition object. */
@{
  B_condition_init(cnd, alpha, beta);
  cce_condition_init(cnd, &C_condition_descriptor);
  cnd->gamma = gamma;
  return cnd;
@}

void
C_condition_final (C_condition_object_t * cnd)
/* Finalise a condition object; do not release memory. */
@{
  B_condition_final((B_condition_object_t *)cnd);
@}

cce_condition_t *
C_condition_constructor (int alpha, int beta, int gamma)
/* Allocate and initialise an instance of condition object. */
@{
  C_condition_object_t *        cnd;

  cnd = malloc(sizeof(C_condition_object_t));
  assert(cnd);
  return C_condition_init(cnd, alpha, beta, gamma);
@}

static void
C_condition_destructor (cce_condition_t * cnd)
/* Finalise and release memory of an instance of condition object. */
@{
  C_condition_final((C_condition_object_t *)cnd);
  free(cnd);
@}

static const char *
C_condition_static_message (const cce_condition_t * cnd CCE_UNUSED)
@{
  return "exceptional condition C";
@}

bool
C_condition_is (void * condition)
@{
  return cce_condition_is_a(condition, (const cce_condition_descriptor_t *)&C_condition_descriptor);
@}

int
main (int argc CCE_UNUSED, const char *const argv[])
@{
  /* Dynamic initialisation. */
  A_condition_descriptor.parent = cce_root_condition_descriptor;

  /* Raising condition object of type C. */
  @{
    cce_location_t      L;
    int                 flag;

    if (cce_location(L)) @{
      void *    cnd = cce_location_condition(L);

      if        (C_condition_is(cnd)) @{
        C_condition_object_t *  C = cnd;
        flag = C->gamma;
      @} else if (B_condition_is(cnd)) @{
        B_condition_object_t *  B = cnd;
        flag = B->beta;
      @} else if (A_condition_is(cnd)) @{
        A_condition_object_t *  A = cnd;
        flag = A->alpha;
      @} else @{
        flag = 0;
      @}
      cce_run_error_handlers(L);
      cce_condition_free(cnd);
    @} else @{
      cce_raise(L, C_condition_constructor(1, 2, 3));
      cce_run_cleanup_handlers(L);
    @}
    assert(3 == flag);
  @}

  /* Raising condition object of type B. */
  @{
    cce_location_t      L;
    int                 flag;

    if (cce_location(L)) @{
      void *    cnd = cce_location_condition(L);

      if        (C_condition_is(cnd)) @{
        C_condition_object_t *  C = cnd;
        flag = C->gamma;
      @} else if (B_condition_is(cnd)) @{
        B_condition_object_t *  B = cnd;
        flag = B->beta;
      @} else if (A_condition_is(cnd)) @{
        A_condition_object_t *  A = cnd;
        flag = A->alpha;
      @} else @{
        flag = 0;
      @}
      cce_run_error_handlers(L);
      cce_condition_free(cnd);
    @} else @{
      cce_raise(L, B_condition_constructor(1, 2));
      cce_run_cleanup_handlers(L);
    @}
    assert(2 == flag);
  @}

  /* Raising condition object of type A. */
  @{
    cce_location_t      L;
    int                 flag;

    if (cce_location(L)) @{
      void *    cnd = cce_location_condition(L);

      if        (B_condition_is(cnd)) @{
        C_condition_object_t *  C = cnd;
        flag = C->gamma;
      @} else if (B_condition_is(cnd)) @{
        B_condition_object_t *  B = cnd;
        flag = B->beta;
      @} else if (A_condition_is(cnd)) @{
        A_condition_object_t *  A = cnd;
        flag = A->alpha;
      @} else @{
        flag = 0;
      @}
      cce_run_error_handlers(L);
      cce_condition_free(cnd);
    @} else @{
      cce_raise(L, A_condition_constructor(1));
      cce_run_cleanup_handlers(L);
    @}
    assert(1 == flag);
  @}

  exit(EXIT_SUCCESS);
@}
@end smallexample

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DOCUMENTATION_URL}

@noindent
the latest release of this package can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

