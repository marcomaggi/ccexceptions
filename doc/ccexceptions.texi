\input texinfo.tex
@c %**start of header
@setfilename ccexceptions.info
@settitle CCExceptions
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Document specific.
@c ------------------------------------------------------------

@macro ConditionSubtypingExample{FILE_STEM, TYPE_STEM}
@subsubheading Sub--typing example


To define a sub--type of @objtype{cce_condition_\TYPE_STEM\_t} we can copy the code in the files:

@example
condition-subtyping-\FILE_STEM\.c
condition-subtyping-\FILE_STEM\-header.h
condition-subtyping-\FILE_STEM\-body.c
@end example

@noindent
under the @file{tests} directory of the source distribution; the code defines a new
exceptional--condition object--type @objtype{my_condition_\TYPE_STEM\_subtype_t}.
@end macro

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCExceptions

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCExceptions

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccexceptions

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2016-2018

@c ------------------------------------------------------------

@set GITHUB_URL                 @url{http://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BITBUCKET_URL              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DOWNLOAD_URL               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DOCUMENTATION_URL          @url{http://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C11 Standard language library;
it implements an interface to non--local exits, which is somewhat similar to exceptions handling.
The library targets @posix{} systems.

The package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

The latest release can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} General
Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccexceptions: (ccexceptions).       CCExceptions a C language library
                                      implementing exceptions handling.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* setjmp::                      Brief introduction to non-local exits.
* locations::                   The locations @api{}.
* handlers::                    The handlers @api{}.
* conditions::                  Exceptional condition descriptors.
* system::                      System call adapters.
* tracing::                     Printing execution traces.
* helpers::                     Helpers.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library; it
implements an interface to non--local exits, which is somewhat similar to exceptions handling.  The
library targets @posix{} systems.

This tiny library will not solve the problem of error handling in the C language, it just brings a
little order in the complexity resulting from hand--coding the error handling logic.
@value{PACKAGE}'s location mechanism has the following purposes:

@enumerate
@item
Implement non--local exits in a way that allows client source code to be shorter and simpler to
understand.

@item
Implement non--local exit handlers to perform synchronous clean--up operations.

@item
Implement a simple architecture for exceptional--condition descriptors.
@end enumerate

@noindent
these features come at the cost of slowing down execution in a possibly sensible way (with respect
to, for example, hand--coded @code{goto} instructions that jump to labels).

@value{PACKAGE} installs the single header file @file{ccexceptions.h}.  All the function names in
the @api{} are prefixed with @code{cce_}; all the preprocessor symbol names are prefixed with
@code{CCE_}; all the type names are prefixed with @code{cce_} and suffixed with @code{_t}.

@strong{IMPORTANT} To use the library we must enable the @posix{} features when including the
standard header files; so either we include @file{ccexceptions.h} as first header, or we include the
following definitions before including @strong{all} the header files:

@example
#define _POSIX_C_SOURCE         200809L
@end example

@menu
* overview linking::            Linking code with the library.
@end menu

@c page
@node overview linking
@section Linking code with the library


@subsubheading Using the @gnu{} Autotools

This package installs a data file for @command{pkg-config}; when searching for the installed library
with the @gnu{} Autotools, we can add the following macro use to @file{configure.ac}:

@example
PKG_CHECK_MODULES([CCEXCEPTIONS],[ccexceptions >= 0.6])
@end example

@noindent
which will set the variables @code{CCEXCEPTIONS_LIBS} and @code{CCEXCEPTIONS_CFLAGS}.

Alternatively we can use the raw @gnu{} Autoconf macros:

@example
AC_CHECK_LIB([ccexceptions],[cce_version_string],,
  [AC_MSG_FAILURE([test for CCExceptions library failed])])
AC_CHECK_HEADERS([ccexceptions.h],,
  [AC_MSG_FAILURE([test for CCExceptions header failed])])
@end example

We need to remember that client code using @value{PACKAGE}'s library must be written using the C11
language.

@c ------------------------------------------------------------------------

@subsubheading One--shot compilation, Unix command line

For the one--shot compilation of a file named @file{demo.c}, we can do:

@example
gcc -std=c11 -Wall \
   `pkg-config ccexceptions --cflags` \
   `pkg-config ccexceptions --libs` \
   -o demo demo.c
@end example

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the
@gnu{} Autotools.  For an explanation of interface numbers as managed by
@gnu{} Libtool @xref{Libtool versioning, interface, Libtool's versioning
system, libtool, Shared library support for @gnu{}}.


@deftypefun {char const *} cce_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing
the interface version number.
@end deftypefun


@deftypefun int cce_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int cce_version_interface_revision (void)
Return an integer representing the library interface current revision
number.
@end deftypefun


@deftypefun int cce_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node setjmp
@chapter Brief introduction to non--local exits


Let's recall briefly how the standard, C language, non--local exits mechanism works; for the full
documentation refer to the C Library.  @glibcref{Non-Local Exits, Non-Local Exits}.

To use @cfunc{setjmp} and @cfunc{longjmp} we write chunks of code like the following:

@example
#define JMP_ERROR_CODE          1

jmp_buf  here;

if (setjmp(here))
  @{
    handle_the_error();
  @}
else
  @{
    do_something();
    if (an_error_occurred()) @{
      longjmp(here, JMP_ERROR_CODE);
    @}
    do_something_else();
  @}
@end example

@noindent
this is what happens:

@itemize
@item
When @cfunc{setjmp} is invoked: it saves the current ``location'' in @var{here}, then it returns
zero.

@item
If @cfunc{longjmp} is not applied to @var{here}, nothing strange happens and the execution flow goes
on as usual.

@item
If @cfunc{longjmp} is applied to @var{here}: the execution jumps back to the call to @cfunc{setjmp}
with @code{JMP_ERROR_CODE} as return value.
@end itemize

This mechanism allows us to separate the exception handling code from the main code.  By using
@var{here} as argument to nested function calls: we can perform non--local exits across functions;
something that is not possible with @code{goto} statements.

As always, care must be taken when the body allocates asynchronous resources.  For each resource:
the exception handler must detect if the allocation took place and execute release code.  For
example:

@example
jmp_buf         here;
volatile void * P = NULL;

if (setjmp(here))
  @{
    if (P)
      free(P);
  @}
else
  @{
    ...
    P = malloc(4096);
    ...
  @}
@end example

Let's see some logic example; we will assume the following preamble:

@example
#include <assert.h>
#include <stdlib.h>
#include <setjmp.h>

#define JUMP_TO_ERROR           2
@end example

In the following code no jump is performed; we just call @cfunc{setjmp} once and never call
@cfunc{longjmp}:

@example
jmp_buf         L;
int             flag = 0, code;

code = setjmp(L);
if (code) @{
  flag = 2;
@} else @{
  flag = 1;
@}
assert(0 == code);
assert(1 == flag);
@end example

In the following code we perform a jump and handle the logic with an @code{if} statement:

@example
jmp_buf         L;
int             flag = 0, code;

code = setjmp(L);
if (JUMP_TO_ERROR == code) @{
  flag = 2;
@} else @{
  flag = 1;
  longjmp(L, JUMP_TO_ERROR);
@}
assert(JUMP_TO_ERROR == code);
assert(2 == flag);
@end example

In the following code we perform a jump and handle the logic with a @code{switch} statement:

@example
jmp_buf         L;
int             flag = 0, code;

code = setjmp(L);
switch (code) @{
case JUMP_TO_ERROR:
  flag = 2;
  break;
default:
  flag = 1;
  longjmp(L, JUMP_TO_ERROR);
@}
assert(JUMP_TO_ERROR == code);
assert(2 == flag);
@end example

@c page
@node locations
@chapter The locations @api{}


Non--local exits are a way to transfer execution from one point to another in a program; they are
implemented by the standard C library through the @cfunc{setjmp} and @cfunc{longjmp} functions.
@value{PACKAGE} uses the @posix{} variants @cfunc{sigsetjmp} and @cfunc{siglongjmp}: it does
@strong{not} save the signals mask.

The main usage pattern for this module is the following:

@example
cce_location_t  L[1];

if (CCE_ENTER == cce_location(L)) @{
  /* do something useful here */
  cce_run_clean_handlers(L);
@} else @{
  /* handle the exception here */
  cce_run_error_handlers(L);
  cce_condition_delete(cce_condition(L));
@}
@end example

@noindent
or alternatively the following:

@example
cce_location_t  L[1];

if (cce_location(L)) @{
  /* handle the exception here */
  cce_run_error_handlers(L);
  cce_condition_delete(cce_condition(L));
@} else @{
  /* do something useful here */
  cce_run_clean_handlers(L);
@}
@end example

We can use the slightly shorter versions:

@example
cce_location_t  L[1];

if (CCE_ENTER == cce_location(L)) @{
  /* do something useful here */
  cce_run_clean_handlers(L);
@} else @{
  /* handle the exception here */
  cce_run_error_handlers_final(L);
@}
@end example

@noindent
and:

@example
cce_location_t  L[1];

if (cce_location(L)) @{
  /* handle the exception here */
  cce_run_error_handlers_final(L);
@} else @{
  /* do something useful here */
  cce_run_clean_handlers(L);
@}
@end example


@noindent
it is usually useful to define variables of type @objtype{cce_location_t} as one--element arrays.
When using @value{PACKAGE} we should consider configuring our code editor to automatically insert
this code template.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_location_t
Struct type representing the location context.  This type is ``derived'' from @objtype{sigjmp_buf}
in the sense that a pointer to @objtype{cce_location_t} is also a pointer to @objtype{sigjmp_buf}.

Instances of this structure reference an instance of type @objtype{cce_condition_t}; it is set by
@cfunc{cce_raise}.  The client code is responsible for releasing resources associated to this value
by retrieving a pointer to it with @cfunc{cce_condition} and releasing it with
@cfunc{cce_condition_delete}.

Before terminating the use of instances of this type we must always call
@cfunc{cce_run_error_handlers} or @cfunc{cce_run_clean_handlers}.  We must assume that the handlers
might access the @objtype{cce_condition_t} object, so: first we call the handlers, then we release
the exceptional--condition object.
@end deftp


@deftp {Pointer Typedef} cce_destination_t
Pointer to @objtype{cce_location_t}.
@end deftp


@deftypefun void cce_location_init (cce_destination_t @var{L})
Initialise the location @var{L}, but do @strong{not} call @cfunc{sigsetjmp}.  We are not meant to
call this function directly; rather we should use the macro @cfunc{cce_location}.
@end deftypefun


@deftypefn {Preprocessor Macro} int cce_location (cce_destination_t @var{L})
Initialise the location @var{L}; call @cfunc{sigsetjmp} and return its return value.
@end deftypefn


@deftypevr Constant int CCE_ENTER
@deftypevrx Constant int CCE_SUCCESS
Constants used by the library as non--local exit codes.  They are defined as @code{0} and represent
the return value of @cfunc{cce_location} at the first evaluation.
@end deftypevr


@deftypevr Constant int CCE_RETRY
This code represents the return value of the @cfunc{setjmp} evaluation after a @cfunc{cce_retry}
call.
@end deftypevr


@deftypevr Constant int CCE_EXCEPT
@deftypevrx Constant int CCE_ERROR
Constants used by the library as non--local exit codes.  They are defined as @code{1} and are the
return value of @cfunc{cce_location} when a non--local exit is performed by @cfunc{cce_raise}.
@end deftypevr


@deftypefun void cce_raise (cce_destination_t @var{L}, cce_condition_t const * @var{C})
Raise an exception associated to the location @var{L}, with exceptional--condition object referenced
by @var{C}.  This function performs the call to @cfunc{siglongjmp} with code @code{CCE_EXCEPT}.

With a call to this function: the client code is put in charge of releasing resources associated to
@var{C}.  If @var{C} is @cnull{}: an internal, statically allocated, exceptional--condition object
is selected to represent an ``unknown exceptional condition''; we can transparently apply the
function @cfunc{cce_condition_delete} to this object.
@end deftypefun


@deftypefun void cce_retry (cce_destinataion_t @var{L})
Jump back to the location @var{L}, reentering the body of the construct.
@end deftypefun


@deftypefn {Generic Macro} {cce_condition_t *} cce_condition (cce_destination_t @var{L})
Return the exceptional--condition object associated to the location @var{L}; this value is
@strong{never} @cnull{}.

If we apply this function to a location without calling @cfunc{cce_raise}: the returned pointer
references an internal, statically allocated, exceptional--condition object representing an
``unknown exceptional condition''; we can transparently apply the function
@cfunc{cce_condition_delete} to this object.
@end deftypefn


As examples of logic, consider the following:

@itemize
@item
If we want to evaluate a body of code and catch its raised exceptions locally, we can use the
following template code:

@example
cce_location_t  L[1];

if (cce_location(L)) @{
  /* handle the exception here */
  cce_run_error_handlers_final(L);
@} else @{
  /* do something useful here */
  cce_run_clean_handlers(L);
@}
@end example

@item
If we want to evaluate a body of code, catch its raised exceptions locally and then re--raise them
to another location, we can use the following template code:

@example
void
outer (void)
@{
  cce_location_t  L[1];

  if (cce_location(L)) @{
    /* handle the exception here */
    cce_run_error_handlers_final(L);
  @} else @{
    inner(L);
    cce_run_clean_handlers(L);
  @}
@}

void
inner (cce_location_t * there)
@{
  cce_location_t  L[1];

  if (cce_location(L)) @{
    cce_run_error_handlers(L);
    cce_raise(there, cce_condition(L));
  @} else @{
    /* do something useful here */
    cce_run_clean_handlers(L);
  @}
@}
@end example
@end itemize

@c page
@node handlers
@chapter The handlers @api{}


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_handler_t
Structure type representing a clean or error handler.  Instances of this type are associated to a
location by calling one of the functions @cfunc{cce_register_*_handler}.  Handlers are invoked by
calling one of the functions @cfunc{cce_run_*_handlers}; before terminating the use of a
@objtype{cce_location_t} instance we must always call the handlers.

We are meant to wrap instances of this type into an enclosing struct definition as follows:

@example
struct resource_handler_t @{
  cce_handler_t 	handler;
  void *		resourcep;
@};
@end example

@noindent
in which the instance of @code{cce_handler_t} is the first field.

The structure has the following public fields:

@table @code
@item cce_handler_fun_t * function
Pointer to the function implementing the handler.
@end table

@noindent
the following fields are members of an anonymous union:

@table @code
@item void * pointer
Pointer available to the client code.

@item char * pathname
Pointer available to the client code.

@item int filedes
An integer meant to be used for file descriptors.

@item int pipedes[2]
Integers meant to be used for pipe descriptors.
@end table
@end deftp


@deftp {Struct Typedef} cce_clean_handler_t
@deftpx {Struct Typedef} cce_cleanup_handler_t
Structure representing a clean handler.  It has the following public fields:

@table @code
@item cce_handler_t handler
The handler structure.
@end table
@end deftp


@deftp {Struct Typedef} cce_error_handler_t
Structure representing a error handler.  It has the following public fields:

@table @code
@item cce_handler_t handler
The handler structure.
@end table
@end deftp


@deftypefn {Function Typedef} void cce_handler_fun_t (cce_condition_t const * @var{C}, cce_handler_t * @var{H})
Type of handler functions meant to release some asynchronous resource.  The argument @var{C}
references the object representing the exceptional condition; the handler must leave it untouched,
it must @strong{not} mutate or release it.  The argument @var{H} references the handler context.

If an error occurs: the handler function must take care of itself and return to the caller, it must
@strong{not} raise an exceptional condition and jump to a remote location.

If the structure referenced by @var{H} is dynamically allocated: the handler function is responsible
to release its memory.
@end deftypefn


@deftypefun void cce_register_clean_handler (cce_destination_t @var{L}, cce_handler_t * @var{H})
@deftypefunx void cce_register_cleanup_handler (cce_destination_t @var{L}, cce_handler_t * @var{H})
Register the clean handler referenced by @var{H} in the list of handlers associated to the location
@var{L}.  The pointer @var{H} must reference an instance of structure whose first field is a
structure of type @code{cce_handler_t}; such structure can either be allocated on the same stack
frame of the function also defining the location object @var{L}, or be dynamically allocated on the
heap.

A clean handler is meant to be called whenever the execution flow leaves the dynamic extent of a
location, whether with an exception or as part of the successful execution path.
@end deftypefun


@deftypefun void cce_register_error_handler (cce_destination_t @var{L}, cce_handler_t * @var{H})
Register the error handler referenced by @var{H} in the list of handlers associated to the location
@var{L}.  The pointer @var{H} must reference an instance of structure whose first field is a
structure of type @code{cce_handler_t}; such structure can either be allocated on the same stack
frame of the function also defining the location object @var{L}, or be dynamically allocated on the
heap.

An error handler is meant to be called whenever the execution flow leaves the dynamic extent of a
location in case of an exceptional condition; it must @strong{not} be called as part of the
successful execution path.
@end deftypefun


@deftypefun void cce_forget_handler (cce_destination_t @var{L}, cce_handler_t * @var{H})
Remove the handler @var{H} from the context of the location @var{L}.  If @var{H} is not registered
in @var{L}: nothing happens.
@end deftypefun


@deftypefun void cce_run_clean_handlers (cce_destination_t @var{L})
@deftypefunx void cce_run_cleanup_handlers (cce_destination_t @var{L})
Run all the clean handlers associated to the location @var{L}.  Each handler must return to its
caller, taking care of itself regarding internal error handling and asynchronous resources
allocation.  Handlers are called starting from the last registered one.

This is a destructive function: once the list has been traversed, it is not valid anymore.  When the
handler function is applied to the handler structure: the handler structure is completely detached
from the context of @var{L}, so it can be finalised and its memory released.
@end deftypefun


@deftypefun void cce_run_error_handlers (cce_destination_t @var{L})
Run all the clean and error handlers associated to the location @var{L}.  Each handler must return
to its caller, taking care of itself regarding internal error handling and asynchronous resources
allocation.  Handlers are called starting from the last registered one.

This is a destructive function: once the list has been traversed, it is not valid anymore.  When the
handler function is applied to the handler structure: the handler structure is completely detached
from the context of @var{L}, so it can be finalised and its memory released.

@strong{NOTE} It must assume that an error handler might access the exceptional--condition object
associated to @var{L}, so this function should always be called @strong{before} applying
@cfunc{cce_condition_delete} to the return value of @cfunc{cce_condition}.
@end deftypefun


@deftypefun void cce_run_error_handlers_final (cce_destination_t @var{L})
Equivalent to calling:

@example
cce_run_error_handlers(L);
cce_condition_delete(cce_condition(L));
@end example
@end deftypefun


@deftypefun void cce_run_clean_handlers_final (cce_destination_t @var{L})
@deftypefunx void cce_run_cleanup_handlers_final (cce_destination_t @var{L})
Equivalent to calling:

@example
cce_run_clean_handlers(L);
cce_condition_delete(cce_condition(L));
@end example
@end deftypefun


@deftypefun void cce_run_error_handlers_raise (cce_destination_t @var{L}, cce_location_t * @var{upper_L})
Equivalent to calling:

@example
cce_run_error_handlers(L);
cce_raise(upper_L, cce_condition(L));
@end example
@end deftypefun


@deftypefun void cce_run_clean_handlers_raise (cce_destination_t @var{L}, cce_location_t * @var{upper_L})
@deftypefunx void cce_run_cleanup_handlers_raise (cce_destination_t @var{L}, cce_location_t * @var{upper_L})
Equivalent to calling:

@example
cce_run_clean_handlers(L);
cce_raise(upper_L, cce_condition(L));
@end example
@end deftypefun


We could define and call a list of clean handlers as follows:

@example
void handler1 (cce_condition_t const * C, cce_handler_t * H) @{
  do_some_cleanup();
@}
void handler2 (cce_condition_t const * C, cce_handler_t * H) @{
  do_some_cleanup();
@}
void handler3 (cce_condition_t const * C, cce_handler_t * H) @{
  do_some_cleanup();
@}

@{
  cce_location_t L[1];
  cce_handler_t  H1 = @{ .function = handler1 @};
  cce_handler_t  H2 = @{ .function = handler2 @};
  cce_handler_t  H3 = @{ .function = handler3 @};

  cce_location_init(L);
  cce_register_clean_handler(L, &H1);
  cce_register_clean_handler(L, &H2);
  cce_register_clean_handler(L, &H3);
  cce_run_clean_handlers(L);
@}
@end example

@noindent
and we could define and call a list of error handlers as follows:

@example
void handler1 (cce_condition_t const * C, cce_handler_t * H) @{
  do_some_error_handling();
@}
void handler2 (cce_condition_t const * C, cce_handler_t * H) @{
  do_some_error_handling();
@}
void handler3 (cce_condition_t const * C, cce_handler_t * H) @{
  do_some_error_handling();
@}

@{
  cce_location_t L[1];
  cce_handler_t  H1 = @{ .function = handler1 @};
  cce_handler_t  H2 = @{ .function = handler2 @};
  cce_handler_t  H3 = @{ .function = handler3 @};

  cce_location_init(L);
  cce_register_error_handler(L, &H1);
  cce_register_error_handler(L, &H2);
  cce_register_error_handler(L, &H3);
  cce_run_error_handlers(L);
@}
@end example

Let's say we need to allocate memory with @cfunc{malloc}, and to release it with @cfunc{free}
whenever the dynamic extent of the local function terminates; we can use built--in functions for
this, @ref{system memory}.  To show the mechanism, in the following example: we implement a handler
explicitly.

@example
typedef struct handler_t @{
  cce_handler_t handler;
  void *        pointer;
@} handler_t;

static void
P_handler (cce_condition_t const * C, cce_handler_t * _H)
@{
  handler_t * H = (handler_t *)_H;
  free(H->pointer);
@}

@{
  cce_location_t        L[1];
  handler_t             H;
  void *                P;

  H.handler.function = P_handler;

  if (cce_location(L)) @{
    cce_run_error_handlers_final(L);
  @} else @{
    errno = 0;
    P = malloc(4096);
    if (P) @{
      cce_register_clean_handler(L, &H.handler);
    @} else @{
      cce_raise(L, cce_condition_new_errno(errno));
    @}
    do_something(L, P);
    cce_run_clean_handlers(L);
  @}
@}
@end example

@noindent
whether @cfunc{do_something} raises an exception or not: the clean handler is invoked and the memory
is released.

Let's say we are writing a constructor and we need to allocate memory, do something and, if
successful, return the memory to the caller; to better show the mechanism: we do not use the field
@code{pointer} of @objtype{cce_handler_t}; we can organise the code as follows, using an error
handler in the constructor and a clean handler in the caller:

@example
typedef struct handler_t @{
  cce_handler_t handler;
  void *        pointer;
@} handler_t;

static void
P_handler (cce_condition_t const * C, cce_handler_t * _H)
@{
  handler_t * H = (handler_t *)_H;
  free(H->pointer);
@}

void *
constructor (cce_location_t * there)
@{
  cce_location_t    L;
  handler_t         H;
  void *            P;

  H.handler.function = P_handler;

  if (cce_location(L)) @{
    cce_run_error_handlers_raise(L, there);
  @} else @{
    errno = 0;
    P = malloc(4096);
    if (P) @{
      H.pointer = P;
      cce_register_error_handler(L, &H.handler);
    @} else @{
      cce_raise(L, cce_condition_new_errno(errno));
    @}
    do_some_initialisation_in(P);
    cce_run_clean_handlers(L);
  @}
  return P;
@}

void caller (void)
@{
  cce_location_t    L[1];
  handler_t         H;
  void *            P;

  H.handler.function = P_handler;

  if (cce_location(L)) @{
    cce_run_error_handlers_final(L);
  @} else @{
    P = constructor(L);
    H.pointer = P;
    cce_register_clean_handler(L, &H.handler);
    do_something_with(P);
    cce_run_clean_handlers(L);
  @}
@}
@end example

@c page
@node conditions
@chapter Exceptional condition descriptors


In the context of the @value{PACKAGE} framework, we represent exceptional conditions with a tree
hierarchy of data structures; this way it is possible to react to a raised exception by branching at
run--time according to the type of raised structure.

@menu
* conditions intro::            Introduction to exceptional-condition objects.
* conditions descriptors::      Exceptional-condition object-type descriptors.
* conditions objects::          Exceptional-condition objects.
* conditions root::             The @emph{root} exceptional-condition object.
* conditions unknown::          The @emph{unknown} exceptional-condition object.
* conditions break::            The @emph{break} exceptional-condition object.
* conditions error::            The @emph{error} exceptional-condition object.
* conditions run-time error::   The @emph{run-time error} exceptional-condition
                                object.
* conditions logic error::      The @emph{logic error} exceptional-condition
                                object.
* conditions unimplemented::    The @emph{unimplemented} exceptional-condition
                                object.
* conditions invalid arg::      The @emph{invalid argument} exceptional-condition
                                object.
* conditions unreachable::      The @emph{unreachable code} exceptional-condition
                                object.
* conditions errno::            The @code{errno} exceptional-condition object.
* conditions math::             The mathematical exceptional-condition objects.
* conditions custom::           Defining custom exceptional-condition
                                object-types.
@end menu

@c page
@node conditions intro
@section Introduction to exceptional--condition objects


The purpose of @value{PACKAGE}'s exceptional--condition objects module is to allow us to write code
like this:

@example
cce_location_t  L[1];

if (cce_location(L)) @{
  // handle the exceptional condition
  if (my_condition_is_alpha(cce_condition(L)))
    @{
      // react to exception "alpha"
    @}
  else if (my_condition_is_beta(cce_condition(L)))
    @{
      // react to exception "beta"
    @}
  else
    @{
      // default reaction to any exception
    @}
  cce_run_error_handlers_final(L);
@} else @{
  // do something useful
  cce_run_clean_handlers(L);
@}
@end example

@noindent
in which we use some, previously defined, exceptional--condition object--types @samp{alpha} and
@samp{beta}.

If we need to hand the exceptional--condition object to an upper level location we can do it as
follows:

@example
void
upper_function (void)
@{
  cce_location_t        L[1];

  if (cce_location(L)) @{
    fprintf(stderr, "log: %s\n", \
        cce_condition_static_message(cce_condition(L)));
    cce_run_error_handlers_final(L);
  @} else @{
    lower_function(L);
    cce_run_clean_handlers(L);
  @}
@}

void
lower_function (cce_location_t * upper_L)
@{
  cce_location_t        L[1];

  if (cce_location(L)) @{
    cce_run_error_handlers_raise(L, upper_L);
  @} else @{
    do_something();
    if (an_error_occurred()) @{
      cce_raise(L, select_condition_object());
    @}
   cce_run_clean_handlers(L);
  @}
@}
@end example

From the point of view of our ability to react to an exception at run--time: a flexible situation is
the one in which the exceptional--condition object--types are organised in a tree hierarchy.  It
allows us to select the level of granularity we desire in the branching logic.  The tree hierarchy
implemented by @value{PACKAGE} uses single inheritance; multiple inheritance would be more general,
but also more complex.

@c ------------------------------------------------------------------------

@subsubheading How the hierarchy is implemented

Exceptional--condition objects are C language structures referencing a type descriptor, which is
also a C language structure.  Type descriptors are usually statically allocated and mostly have a
hard--coded initialisation.  Exceptional--condition objects are either dynamically allocated and
initialised or statically allocated with hard--coded initialisation.

Every type descriptor data structure encloses a data structure of type @objtype{cce_descriptor_t},
which must be its first field.  The instances of @objtype{cce_descriptor_t} hold the pointers that
define the tree hierarchy; every type descriptor can be referenced by multiple
exceptional--condition objects: it can represent the type of multiple objects; every type descriptor
has a single parent and can have zero, one or more children.  Each pointer to
@objtype{cce_descriptor_t} is a unique run--time value identifying the type of
exceptional--condition objects.

Every exceptional--condition object's data structure encloses a data structure of type
@objtype{cce_condition_t}, which must be its first field.  The exceptional--condition object holds a
pointer to the associated type descriptor.

The root of the tree is represented by the object--type descriptor @objtype{cce_descriptor_root_t}
and objects of such type are @code{struct} of type @objtype{cce_condition_root_t}.  We can think of
the root structure types as follows:

@smallexample
typedef struct cce_condition_root_t     cce_descriptor_root_t;
typedef struct cce_condition_root_t     cce_condition_root_t;

struct cce_descriptor_root_t @{
  cce_descriptor_t	descriptor;
@};

struct cce_condition_root_t @{
  cce_condition_t	condition;
@};

extern cce_descriptor_root_t const * const cce_descriptor_root_ptr;
@end smallexample

We declare the @code{struct} types needed to define a new exceptional--condition object--type, child
of the @emph{root} type, as follows:

@smallexample
typedef struct my_descriptor_error_t  my_descriptor_error_t;
typedef struct my_condition_error_t   my_condition_error_t;

struct my_descriptor_error_t @{
  cce_descriptor_t  descriptor;
  /* Put some custom fields here. */
@};

struct my_condition_error_t @{
  cce_condition_root_t  root;
  /* Put some custom fields here. */
@};

extern my_descriptor_error_t const * const my_descriptor_error_ptr;
@end smallexample

@noindent
the field of type @objtype{cce_descriptor_t} is the first in its data structure type; the field of
type @objtype{cce_condition_root_t} is the first in its data structure type.

In the following picture: the @emph{alpha} descriptor is a child of the @emph{root} descriptor; the
@emph{beta} descriptor is a child of the type @samp{alpha} descriptor.  We can say that:

@itemize
@item
An exceptional--condition object of type @emph{alpha} is also of type @emph{root}.

@item
An exceptional--condition object of type @emph{beta} is also of type @emph{alpha} and of type
@emph{root}.
@end itemize

@example
 -----------------
| descriptor root |
 -----------------
         ^
         |
 ------------------       --------------
| descriptor alpha | <-- | object alpha |
 ------------------       --------------
         ^
         |
 -----------------        -------------
| descriptor beta | <--- | object beta |
 -----------------        -------------
@end example

The data types that represent such hierarchy look as follows:

@smallexample
typedef struct my_descriptor_alpha_t my_descriptor_alpha_t;
typedef struct my_descriptor_beta_t  my_descriptor_beta_t;
typedef struct my_condition_alpha_t  my_condition_alpha_t;
typedef struct my_condition_beta_t   my_condition_beta_t;

/*** Descriptors types. ***/

struct my_descriptor_alpha_t @{
  cce_descriptor_t  descriptor;
@};

struct my_descriptor_beta_t @{
  cce_descriptor_t  descriptor;
@};

/*** Object types. ***/

struct my_condition_alpha_t @{
  cce_condition_root_t  root;
@};

struct my_condition_beta_t @{
  my_condition_alpha_t  alpha;
@};
@end smallexample

@noindent
we can statically allocate and initialise the type descriptors as follows:

@smallexample
my_descriptor_alpha_t my_descriptor_alpha = @{
  .descriptor.parent = NULL
@};

my_descriptor_beta_t  my_descriptor_beta  = @{
  .descriptor.parent = &my_descriptor_alpha.descriptor
@};

void
initialisation_function (void)
@{
  cce_descriptor_set_root_parent(&my_descriptor_alpha.descriptor));
@}
@end smallexample

@c page
@node conditions descriptors
@section Exceptional--condition object--type descriptors


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_descriptor_t
Type of @code{struct} representing exceptional--condition object--type descriptors; it holds a table
of function pointers to handle exceptional--condition objects.  It has the following fields:

@table @code
@item cce_descriptor_t const * parent
Pointer to the descriptor that is parent of this one in the tree hierarchy.  This pointer is set to
@cnull{} only for the root condition descriptor, @xref{conditions root, Predefined root condition
descriptor}.

@item cce_condition_final_fun_t * delete
Pointer to function releasing the exceptional--condition object's memory block itself.  This pointer
can be @cnull{}, meaning that: the object is statically allocated.

@item cce_condition_final_fun_t * final
Pointer to function releasing all the dynamic resources associated to the exceptional--condition
object.  This pointer can be @cnull{}, meaning that: there are no dynamic resources.

@item cce_condition_static_message_fun_t * static_message
Pointer to function returning a statically allocated @asciiz{} string describing the
exceptional--condition.
@end table
@end deftp


@deftypefn {Function Prototype} void cce_condition_final_fun_t (cce_condition_t * @var{C})
Release all the dynamic resources associated to @var{C}; leave untouched the memory block holding
the @objtype{cce_condition_t} instance itself.
@end deftypefn


@deftypefn {Function Prototype} void cce_condition_delete_fun_t (cce_condition_t * @var{C})
Release the memory block referenced by @var{C}, if appropriate.  If the structure is allocated with
@cfunc{malloc}, the @code{delete} function can just be:

@example
void
my_condition_delete_stuff (my_condition_stuff_t * C)
@{
  free(C);
@}
@end example
@end deftypefn


@deftypefn {Function Prototype} {char const *} cce_condition_static_message_fun_t (cce_condition_t const * @var{C})
Return a statically allocated @asciiz{} string describing the exceptional--condition.  A static
message must always be defined; another client--defined function can build a dynamic and more
descriptive message.

For example, an instance of this function can be:

@example
char const *
my_condition_static_message_stuff (my_condition_stuff_t const * C)
@{
  return "error doing stuff";
@}
@end example
@end deftypefn


@deftypefun bool cce_descriptor_child_and_ancestor (cce_descriptor_t const * @var{child}, cce_descriptor_t const * @var{ancestor})
Establish if two condition descriptors are child and ancestor.  Return @ctrue{} if @var{child} is
equal to @var{ancestor} or @var{ancestor} is in the hierarchy of @var{child}'s ancestors; otherwise
return @cfalse{}.
@end deftypefun


@deftypefn {Generic Macro} {cce_descriptor_t *} cce_descriptor (@var{X})
This generic macro dispatches its expansion according to its argument's type:

@itemize
@item
Given a pointer to condition object: retrieve the pointer to its descriptor and cast it to a pointer
to @objtype{cce_descriptor_t}.

@item
Given a pointer to condition descriptor: cast it to a pointer to @objtype{cce_descriptor_t}.
@end itemize

This generic macro performs compile--time type--checking so that the cast operation is applied only
on values of suitable types; we can apply this macro to pointers to all the types defined by
@value{PACKAGE} for which it makes sense.
@end deftypefn

@c page
@node conditions objects
@section Exceptional-condition objects


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_condition_t
Type of structure representing an exceptional--condition object.  It has the following public
fields:

@table @code
@item cce_descriptor_t const * descriptor
Pointer to the descriptor of the exceptional--condition object--type.
@end table
@end deftp


@deftypefun void cce_condition_init (cce_condition_t * @var{C}, cce_descriptor_t const * @var{D})
Initialise the core fields of an already allocated condition object.  The argument @var{D} must be a
pointer to the descriptor: it is stored in the object referenced by @var{C}.  This function is
usually called from a type--specific constructor function.
@end deftypefun


@deftypefun void cce_condition_final (cce_condition_t * @var{C})
@strong{Usually we do not need to call this function directly; rather, we should use
@cfunc{cce_condition_delete}.}

Traverse, from leaf to root, the hierarchy of descriptors for the type of the exceptional--condition
object referenced by @var{C}: apply to @var{C} the @code{final} functions referenced by the
descriptors' functions tables.  The finalisation functions are applied from leaf to root.
@end deftypefun


@deftypefun void cce_condition_delete (cce_condition_t * @var{C})
Apply @cfunc{cce_condition_final} to @var{C}; then apply to @var{C} the @code{delete} function
referenced by the descriptor's functions table.
@end deftypefun


@deftypefun {char const *} cce_condition_static_message (cce_condition_t const * @var{C})
Apply to @var{C} the @code{static_message} function referenced by its descriptor's functions
table.
@end deftypefun


@deftypefun bool cce_is_condition (cce_condition_t const * @var{C}, cce_descriptor_t const * @var{D})
Determine if an object is of a selected object--type.  Return @ctrue{} if the object referenced by
@var{C} is an instance of the type whose descriptor is referenced by @var{D}, or an instance of a
type that is an ancestor of such descriptor; otherwise return @cfalse{}.
@end deftypefun


@deftypefn {Generic Macro} {cce_condition_t *} cce_condition (@var{X})
This generic macro dispatches its expansion according to its argument's type:

@itemize
@item
Given a pointer to @objtype{cce_location_t}: retrieve a pointer to the associated condition object
and cast it to a pointer to @objtype{cce_condition_t}.

@item
Given a pointer to condition object: cast it to a pointer to @objtype{cce_condition_t}.
@end itemize

This generic macro performs compile--time type--checking so that the cast operation is applied only
on values of suitable types; we can apply this macro to pointers to all the types defined by
@value{PACKAGE} for which it makes sense.

This macro allows us to compare pointers without raising a warning:

@example
cce_condition_errno_t * A = ...;
cce_condition_t *       B = ...;

/* This raises a warning: */
A == B;

/* This does not raise a warning: */
cce_condition(A) == cce_condition(B);
@end example
@end deftypefn

@c page
@node conditions root
@section Predefined root condition descriptor


The @dfn{root} exceptional--condition object--type descriptor has the only purpose of being the root
of the descriptors tree; there should be no exceptional--condition objects having this as
descriptor.  The @emph{root} descriptor has @code{parent} field set to @cnull{}; this must be the
only descriptor with such a property.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_descriptor_root_t
Type of @code{struct} representing the @emph{root} exceptional--condition object--type descriptor,
the root of the descriptors hierarchy tree.  This descriptor has a single instance built into the
library.  It has the following public fields:

@table @code
@item cce_descriptor_t descriptor
Core values of the exceptional--condition object--type descriptor.
@end table
@end deftp


@deftp {Struct Typedef} cce_condition_root_t
Type of @code{struct} representing the @emph{root} exceptional--condition object; this @code{struct}
type must never be instantiated.  It has the following public fields:

@table @code
@item cce_condition_t condition
Core values of the exceptional--condition object.
@end table
@end deftp


@deftypefun void cce_descriptor_set_root_parent (cce_descriptor_t * @var{D})
Configure the descriptor @var{D} so that its parent is the unique @emph{root} descriptor.
@end deftypefun


@deftypefun void cce_condition_init_root (cce_condition_root_t * @var{C})
Initialisation function for the object referenced by @var{C}.  This function must be called by all
the initialisation functions of exceptional--condition object--types derived from
@objtype{cce_condition_root_t}.
@end deftypefun


@deftypefun bool cce_condition_is_root (cce_condition_t const * @var{C})
Return @ctrue{} if the object referenced by @var{C} is derived from the @emph{root} type; otherwise
return @cfalse{}.  With a correctly built conditions hierarchy: this function always returns
@ctrue{}.
@end deftypefun


@deftypevr {Dynamic Constant} {cce_descriptor_root_t const * const} cce_descriptor_root_ptr
Pointer to the statically allocated structure representing the @emph{root} descriptor.
@end deftypevr

@c ------------------------------------------------------------------------

@ConditionSubtypingExample{root, root}

@c page
@node conditions unknown
@section Predefined unknown condition object


The @dfn{unknown} exceptional--condition object--type has the purpose of describing an
exceptional--condition with unknown cause; it should be used only by the function @cfunc{cce_raise}
when the condition object argument is set to @cnull{}.

There should be only one @emph{unknown} object: the one predefined by @value{PACKAGE} and built into
the library as statically allocated structure.  Subtyping from the @emph{unknown} type is
discouraged.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_descriptor_unknown_t
Type of @code{struct} representing the @emph{unknown} exceptional--condition object--type
descriptor.  This descriptor has the @emph{root} descriptor as parent.  It has the following public
fields:

@table @code
@item cce_descriptor_t descriptor
Core values of the exceptional--condition object--type descriptor.
@end table
@end deftp


@deftp {Struct Typedef} cce_condition_unknown_t
Type of @code{struct} representing the @emph{unknown} exceptional--condition object.  It has the
following public fields:

@table @code
@item cce_condition_root_t root
Core values of the exceptional--condition object.
@end table
@end deftp


@deftypefun {cce_condition_t const *} cce_condition_new_unknown (void)
Return a pointer to the statically allocated structure representing the single @emph{unknown}
exceptional--condition object.
@end deftypefun


@deftypefn {Inline Function} bool cce_condition_is_unknown (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{unknown} exceptional--condition object; otherwise return
@cfalse{}.
@end deftypefn


@deftypefn {Generic Macro} {cce_condition_unknown_t const *} cce_condition_unknown (cce_destination_t @var{L})
@deftypefnx {Generic Macro} {cce_condition_unknown_t const *} cce_condition_unknown (cce_condition_t * @var{C})
@deftypefnx {Generic Macro} {cce_condition_unknown_t const *} cce_condition_unknown (cce_condition_unknown_t * @var{C})
@deftypefnx {Generic Macro} {cce_condition_unknown_t const *} cce_condition_unknown (cce_condition_t const * @var{C})
@deftypefnx {Generic Macro} {cce_condition_unknown_t const *} cce_condition_unknown (cce_condition_unknown_t const * @var{C})
This generic macro dispatches its expansion according to its argument's type.  Cast a pointer to a
pointer to @objtype{cce_condition_unknown_t}.

This macro performs compile--time type--checking so that the cast operation is applied only to
values of suitable types; we can apply this macro to pointers of all the types defined by
@value{PACKAGE} for which it makes sense.
@end deftypefn


@deftypevr {Dynamic Constant} {cce_descriptor_unknown_t const * const} cce_descriptor_unknown_ptr
Pointer to a statically allocated @code{struct} representing the @emph{unknown}
exceptional--condition object--type descriptor.
@end deftypevr


@deftypevr {Dynamic Constant} {cce_condition_unknown_t const * const} cce_condition_unknown_ptr
Pointer to a statically allocated @code{struct} representing the @emph{unknown}
exceptional--condition object.
@end deftypevr

@c page
@node conditions break
@section Predefined break condition object


The @dfn{break exceptional--condition object} has the purpose of describing an exceptional condition
used to break out of a loop or a function call; this condition object type does @strong{not}
represent an error of any kind.

There should be only one @emph{break} condition object: the one predefined by @value{PACKAGE} and
built into the library as statically allocated structure.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_descriptor_break_t
Structure type representing the descriptor for @emph{break} condition objects.  This descriptor has
the @emph{root} descriptor as parent.  It has the following public fields:

@table @code
@item cce_descriptor_t descriptor
Core values of the exceptional--condition object--type descriptor.
@end table
@end deftp


@deftp {Struct Typedef} cce_condition_break_t
Structure type representing an @emph{break} condition object.  It has the following public fields:

@table @code
@item cce_condition_t condition
Core values of the exceptional--condition object.
@end table
@end deftp


@deftypefun void cce_condition_init_break (cce_condition_break_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{cce_condition_break_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cce_condition_new_break (void)
Return a pointer to the statically allocated structure representing the single @emph{break}
condition object.
@end deftypefun


@deftypefn {Inline Function} bool cce_condition_is_break (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{break} condition object; otherwise return @cfalse{}.
@end deftypefn


@deftypefn {Generic Macro}  {cce_condition_break_t const *} cce_condition_break (cce_destination_t @var{L})
@deftypefnx {Generic Macro} {cce_condition_break_t const *} cce_condition_break (cce_condition_t * @var{C})
@deftypefnx {Generic Macro} {cce_condition_break_t const *} cce_condition_break (cce_condition_break_t * @var{C})
@deftypefnx {Generic Macro} {cce_condition_break_t const *} cce_condition_break (cce_condition_t const * @var{C})
@deftypefnx {Generic Macro} {cce_condition_break_t const *} cce_condition_break (cce_condition_break_t const * @var{C})
This generic macro dispatches its expansion according to its argument's type.  Cast a pointer to a
pointer to @objtype{cce_condition_break_t}.

This macro performs compile--time type--checking so that the cast operation is applied only to
values of suitable types; we can apply this macro to pointers of all the types defined by
@value{PACKAGE} for which it makes sense.
@end deftypefn


@deftypevr {Dynamic Constant} {cce_descriptor_break_t const * const} cce_descriptor_break_ptr
Pointer to a statically allocated structure representing the @emph{break} condition descriptor for
the single @emph{break} condition object.  The parent of this descriptor is the root descriptor,
@ref{conditions root}.
@end deftypevr


@deftypevr {Dynamic Constant} {cce_condition_break_t const * const} cce_condition_break_ptr
Pointer to a statically allocated structure representing the @emph{break} condition object.
@end deftypevr

@c ------------------------------------------------------------------------

@ConditionSubtypingExample{break, break}

@c page
@node conditions error
@section Predefined error condition object


The @dfn{error exceptional--condition object} has the purpose of describing an exceptional condition
caused by an unspecified error; this condition type is meant to be the base of more specialised
condition types.

There should be only one @emph{error} condition object: the one predefined by @value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_descriptor_error_t
Structure type representing the descriptor for @emph{error} condition objects.  This descriptor has
the @emph{root} descriptor as parent.  It has the following public fields:

@table @code
@item cce_descriptor_t descriptor
Core values of the exceptional--condition object--type descriptor.
@end table
@end deftp


@deftp {Struct Typedef} cce_condition_error_t
Structure type representing a @emph{error} condition object.  It has the following public fields:

@table @code
@item cce_condition_t condition
Core values of the exceptional--condition object.
@end table
@end deftp


@deftypefun void cce_condition_init_error (cce_condition_error_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{cce_condition_error_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cce_condition_new_error (void)
Return a pointer to the statically allocated structure representing the single @emph{error}
condition object.
@end deftypefun


@deftypefun bool cce_is_condition_error (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is a @emph{error} condition object; otherwise return @cfalse{}.
@end deftypefun


@deftypefn {Generic Macro} {cce_condition_error_t const *} cce_condition_error (cce_destination_t @var{L})
@deftypefnx {Generic Macro} {cce_condition_error_t const *} cce_condition_error (cce_condition_t * @var{C})
@deftypefnx {Generic Macro} {cce_condition_error_t const *} cce_condition_error (cce_condition_t const * @var{C})
This generic macro dispatches its expansion according to its argument's type.  Cast a pointer to
@objtype{cce_condition_error_t}.

This macro performs compile--time type--checking so that the cast operation is applied only to
values of suitable types; we can apply this macro to pointers of all the types defined by
@value{PACKAGE} for which it makes sense.
@end deftypefn


@deftypevr {Dynamic Constant} {cce_descriptor_error_t const * const} cce_descriptor_error_ptr
Pointer to a statically allocated structure representing the @emph{error} condition
descriptor for the single @emph{error} condition object.
@end deftypevr


@deftypevr {Dynamic Constant} {cce_condition_error_t const * const} cce_condition_error_ptr
Pointer to a statically allocated structure representing the @emph{error} condition object.
@end deftypevr

@c ------------------------------------------------------------------------

@ConditionSubtypingExample{error, error}

@c page
@node conditions run-time error
@section Predefined run--time error condition object


The @dfn{run--time exceptional--condition object} has the purpose of describing an exceptional
condition caused by a run--time error; these are mostly synchronisation errors like failures to open
a file or allocate memory.

There should be only one @emph{run--time} condition object: the one predefined by @value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_descriptor_runtime_error_t
Structure type representing the descriptor for @emph{run--time} condition objects.  This descriptor
has the @emph{error} descriptor as parent.  It has the following public fields:

@table @code
@item cce_descriptor_t descriptor
Core values of the exceptional--condition object--type descriptor.
@end table
@end deftp


@deftp {Struct Typedef} cce_condition_runtime_error_t
Structure type representing a @emph{run--time} condition object.
@end deftp


@deftypefun void cce_condition_init_runtime_error (cce_condition_runtime_error_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{cce_condition_runtime_error_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cce_condition_new_runtime_error (void)
Return a pointer to the statically allocated structure representing the single @emph{run--time}
condition object.
@end deftypefun


@deftypefun bool cce_is_condition_runtime_error (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is a @emph{run--time} condition object; otherwise return @cfalse{}.
@end deftypefun


@deftypefn {Generic Macro} {cce_condition_runtime_error_t const *} cce_condition_runtime_error (cce_destination_t @var{L})
@deftypefnx {Generic Macro} {cce_condition_runtime_error_t const *} cce_condition_runtime_error (cce_condition_t * @var{C})
@deftypefnx {Generic Macro} {cce_condition_runtime_error_t const *} cce_condition_runtime_error (cce_condition_t const * @var{C})
This generic macro dispatches its expansion according to its argument's type.  Cast a pointer to
@objtype{cce_condition_runtime_error_t}.

This macro performs compile--time type--checking so that the cast operation is applied only to
values of suitable types; we can apply this macro to pointers of all the types defined by
@value{PACKAGE} for which it makes sense.
@end deftypefn


@deftypevr {Dynamic Constant} {cce_descriptor_runtime_error_t const * const} cce_descriptor_runtime_error_ptr
Pointer to a statically allocated structure representing the @emph{run--time} condition
descriptor for the single @emph{run--time} condition object.
@end deftypevr


@deftypevr {Dynamic Constant} {cce_condition_runtime_error_t const * const} cce_condition_runtime_error_ptr
Pointer to a statically allocated structure representing the @emph{run--time} condition object.
@end deftypevr

@c ------------------------------------------------------------------------

@ConditionSubtypingExample{runtime-error, runtime_error}

@c page
@node conditions logic error
@section Predefined logic error condition object


The @dfn{logic exceptional--condition object} has the purpose of describing an exceptional condition
caused by an implementation logic error; these are programming errors that should not be present in
a correct program.  Examples of logic errors are: applying a function to an invalid operand; using
the @syntax{switch} syntax on an @syntax{enum} value without handling all the possible cases.

There should be only one @emph{logic} condition object: the one predefined by @value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_descriptor_logic_error_t
Structure type representing the descriptor for @emph{logic} condition objects.  This descriptor has
the @emph{error} descriptor as parent.  It has the following public fields:

@table @code
@item cce_descriptor_t descriptor
Core values of the exceptional--condition object--type descriptor.
@end table
@end deftp


@deftp {Struct Typedef} cce_condition_logic_error_t
Structure type representing a @emph{logic} condition object.
@end deftp


@deftypefun void cce_condition_init_logic_error (cce_condition_logic_error_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{cce_condition_logic_error_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cce_condition_new_logic_error (void)
Return a pointer to the statically allocated structure representing the single @emph{logic}
condition object.
@end deftypefun


@deftypefun bool cce_is_condition_logic_error (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is a @emph{logic} condition object; otherwise return @cfalse{}.
@end deftypefun


@deftypefn {Generic Macro} {cce_condition_logic_error_t const *} cce_condition_logic_error (cce_destination_t @var{L})
@deftypefnx {Generic Macro} {cce_condition_logic_error_t const *} cce_condition_logic_error (cce_condition_t * @var{C})
@deftypefnx {Generic Macro} {cce_condition_logic_error_t const *} cce_condition_logic_error (cce_condition_t const * @var{C})
This generic macro dispatches its expansion according to its argument's type.  Cast a pointer to
@objtype{cce_condition_logic_error_t}.

This macro performs compile--time type--checking so that the cast operation is applied only to
values of suitable types; we can apply this macro to pointers of all the types defined by
@value{PACKAGE} for which it makes sense.
@end deftypefn


@deftypevr {Dynamic Constant} {cce_descriptor_logic_error_t const * const} cce_descriptor_logic_error_ptr
Pointer to a statically allocated structure representing the @emph{logic} condition
descriptor for the single @emph{logic} condition object.
@end deftypevr


@deftypevr {Dynamic Constant} {cce_condition_logic_error_t const * const} cce_condition_logic_error_ptr
Pointer to a statically allocated structure representing the @emph{logic} condition object.
@end deftypevr

@c ------------------------------------------------------------------------

@ConditionSubtypingExample{logic-error, logic_error}

@c page
@node conditions unimplemented
@section Predefined unimplemented condition object


The @dfn{unimplemented exceptional--condition object} has the purpose of describing an exceptional
condition caused by attempting to use an unimplemented feature.  For example: attempting to call a
system function adapter for which the underlying function is not available on the current platform
(@pxref{system}).

There should be only one @emph{unimplemented} condition object: the one predefined by
@value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_descriptor_unimplemented_t
Structure type representing the descriptor for @emph{unimplemented} condition objects.  This
descriptor has the @emph{logic error} descriptor as parent.  It has the following public fields:

@table @code
@item cce_descriptor_t descriptor
Core values of the exceptional--condition object--type descriptor.
@end table
@end deftp


@deftp {Struct Typedef} cce_condition_unimplemented_t
Structure type representing an @emph{unimplemented} condition object.
@end deftp


@deftypefun void cce_condition_init_unimplemented (cce_condition_unimplemented_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{cce_condition_unimplemented_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cce_condition_new_unimplemented (void)
Return a pointer to the statically allocated structure representing the single @emph{unimplemented}
condition object.
@end deftypefun


@deftypefun bool cce_is_condition_unimplemented (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{unimplemented} condition object; otherwise return @cfalse{}.
@end deftypefun


@deftypefn {Generic Macro} {cce_condition_unimplemented_t const *} cce_condition_unimplemented (cce_destination_t @var{L})
@deftypefnx {Generic Macro} {cce_condition_unimplemented_t const *} cce_condition_unimplemented (cce_condition_t * @var{C})
@deftypefnx {Generic Macro} {cce_condition_unimplemented_t const *} cce_condition_unimplemented (cce_condition_t const * @var{C})
This generic macro dispatches its expansion according to its argument's type.  Cast a pointer to
@objtype{cce_condition_unimplemented_t}.

This macro performs compile--time type--checking so that the cast operation is applied only to
values of suitable types; we can apply this macro to pointers of all the types defined by
@value{PACKAGE} for which it makes sense.
@end deftypefn


@deftypevr {Dynamic Constant} {cce_descriptor_unimplemented_t const * const} cce_descriptor_unimplemented_ptr
Pointer to a statically allocated structure representing the @emph{unimplemented} condition
descriptor for the single @emph{unimplemented} condition object.
@end deftypevr


@deftypevr {Dynamic Constant} {cce_condition_unimplemented_t const * const} cce_condition_unimplemented_ptr
Pointer to a statically allocated structure representing the @emph{unimplemented} condition object.
@end deftypevr

@c ------------------------------------------------------------------------

@ConditionSubtypingExample{unimplemented, unimplemented}

@c page
@node conditions invalid arg
@section Predefined invalid argument conditions


The @dfn{invalid argument exceptional--condition object} has the purpose of describing an
exceptional condition caused by a wrong function argument.  This condition object is meant to be
used to describe unexpected exceptions: we do not really expect the argument to be invalid, but we
want a fall--back just in case.

The function is meant to be used as follows:

@example
void
do_something (unsigned N)
@{
  cce_location_t        L[1];

  if (cce_location(L)) @{
    cce_run_error_handlers_final(L);
  @} else @{
    if (0 == N) @{
      cce_raise(L,
          cce_condition_new_invalid_argument(L, __func__, 1));
    @}
    cce_run_clean_handlers(L);
  @}
@}
@end example

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_descriptor_invalid_argument_t
Structure type representing the descriptor of the condition objects.  This descriptor has the
@emph{logic error} descriptor as parent.  It has the following public fields:

@table @code
@item cce_descriptor_t descriptor
Core values of the exceptional--condition object--type descriptor.
@end table
@end deftp


@deftp {Struct Typedef} cce_condition_invalid_argument_t
Structure type representing the condition object.  It has the following public fields:

@table @code
@item char const * funcname
Pointer to a statically allocated @asciiz{} string representing the name of the function that raised
the exception.  It is usually generated with @code{__func__}.

@item unsigned index
One--based index of the offending argument.
@end table
@end deftp


@deftypefun void cce_condition_init_invalid_argument (cce_condition_invalid_argument_t * @var{C}, char const * @var{func}, unsigned @var{index})
Initialisation function for the condition object.
@end deftypefun


@deftypefun {cce_condition_t const *} cce_condition_new_invalid_argument (cce_destination_t @var{L}, char const * @var{func}, unsigned @var{index})
Build and return a new condition object.  If building the object fails: raise an exception to the
location @var{L}.
@end deftypefun


@deftypefn {Inline Function} bool cce_condition_is_invalid_argument (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is a condition object of the specified type; otherwise return @cfalse{}.
@end deftypefn


@deftypefn {Generic Macro} {cce_condition_invalid_argument_t const *} cce_condition_invalid_argument (cce_destination_t @var{L})
@deftypefnx {Generic Macro} {cce_condition_invalid_argument_t const *} cce_condition_invalid_argument (cce_condition_t * @var{C})
@deftypefnx {Generic Macro} {cce_condition_invalid_argument_t const *} cce_condition_invalid_argument (cce_condition_invalid_argument_t * @var{C})
@deftypefnx {Generic Macro} {cce_condition_invalid_argument_t const *} cce_condition_invalid_argument (cce_condition_t const * @var{C})
@deftypefnx {Generic Macro} {cce_condition_invalid_argument_t const *} cce_condition_invalid_argument (cce_condition_invalid_argument_t const * @var{C})
This generic macro dispatches its expansion according to its argument's type.  Cast a pointer to a
pointer to @objtype{cce_condition_invalid_argument_t}.

This macro performs compile--time type--checking so that the cast operation is applied only to
values of suitable types; we can apply this macro to pointers of all the types defined by
@value{PACKAGE} for which it makes sense.
@end deftypefn


@deftypevr {Dynamic Constant} {cce_descriptor_invalid_argument_t const * const} cce_descriptor_invalid_argument
Pointer to a statically allocated structure representing the condition descriptor.
@end deftypevr

@c ------------------------------------------------------------------------

@ConditionSubtypingExample{invalid-arg, invalid_argument}

@c page
@node conditions unreachable
@section Predefined unreachable code conditions


@cindex Unreachable code, exceptional condition
@cindex Exceptional conditions, Unreachable code


We can use the @dfn{unreachable code exceptional--condition object--type} to signal the execution of
unreachable code.  We can instantiate this type and also derive new types from it.  To catch this
exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cce_condition_is_unreachable(cce_condition(L))) @{
    CCE_PC(cce_condition_unreachable_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_error_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_clean_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cce_descriptor_unreachable_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
Core values of the exceptional--condition object--type descriptor.
@end table

The parent of this type descriptor is the one referenced by @code{cce_descriptor_logic_error_ptr},
@ref{conditions logic error, Predefined logic error condition object}.
@end deftp


@deftp {Struct Typedef} cce_condition_unreachable_t
Type of data structure representing the exceptional--condition object.  It has the following public
fields:

@table @code
@item cce_condition_logic_error_t logic_error
The condition object's base values.

@item char const * filename
Pointer to a statically allocated @asciiz{} string representing the pathname of the source file in
which the unreachable code is located.  This value is meant to be generated with the preprocessor
macro @code{__FILE__}.

@item char const * funcname
Pointer to a statically allocated @asciiz{} string representing the name of the function in which
the unreachable code is located.  This value is meant to be generated with the preprocessor macro
@code{__func__}.

@item int linenum
The line number in the source file in which the unreachable code is located.  This value is meant to
be generated with the preprocessor macro @code{__LINE__}.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cce_descriptor_unreachable_t const * const} cce_descriptor_unreachable_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cce_condition_init_unreachable (cce_condition_unreachable_t * @var{C}, char const * @var{filename}, char const * @var{funcname}, int @var{linenum})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cce_condition_unreachable_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cce_condition_new_unreachable (cce_destination_t @var{L}, char const * @var{filename}, char const * @var{funcname}, int @var{linenum})
Return a pointer to exceptional condition object.  If an error occurs building the instance: raise
an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun bool cce_condition_is_unreachable (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cce_condition_unreachable_t}; otherwise return
@cfalse{}.
@end deftypefun


@deftypefn {Preprocessor Macro} void cce_raise_unreachable (cce_destination_t @var{L})
@cindex @code{CCEXCEPTIONS_EXCLUDE_UNREACHABLE}, preprocessor symbol
@cindex Preprocessor symbol @code{CCEXCEPTIONS_EXCLUDE_UNREACHABLE}
If the preprocessor symbol @code{CCEXCEPTIONS_EXCLUDE_UNREACHABLE} @strong{is not} defined: raise an
exceptional condition of type @objtype{cce_condition_unreachable_t} by expanding into:

@example
cce_raise((L), cce_condition_new_unreachable((L),
                 __FILE__, __func__, __LINE__))
@end example

If the preprocessor symbol @code{CCEXCEPTIONS_EXCLUDE_UNREACHABLE} @strong{is} defined: expand to
nothing.  By default @code{CCEXCEPTIONS_EXCLUDE_UNREACHABLE} is not defined.
@end deftypefn

@c ------------------------------------------------------------------------

@ConditionSubtypingExample{unreachable, unreachable}

@c page
@node conditions errno
@section Predefined @code{errno} conditions


The @dfn{errno exceptional--condition object} has the purpose of describing an exceptional condition
caused by a system function setting @code{errno}.  Condition objects of this type are @strong{not}
meant to be sub--typed.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_descriptor_errno_t
Structure type representing the descriptor for @emph{errno} condition objects.  This descriptor has
the @emph{run--time error} descriptor as parent.  It has the following public fields:

@table @code
@item cce_descriptor_t descriptor
Core values of the exceptional--condition object--type descriptor.
@end table
@end deftp


@deftp {Struct Typedef} cce_condition_errno_t
Structure type representing an @emph{errno} exceptional condition object, signalled by a system
function by setting @code{errno} to a non--zero value.  It has the following public fields:

@table @code
@item int errnum
The value of @code{errno}.

@item char const * message
A statically allocated string describing the error.
@end table
@end deftp


@deftypefun {cce_condition_t const *} cce_condition_new_errno (int @var{errnum})
Given the @code{errno} code @var{errnum}, return the pointer to the condition object associated to
it.

If @var{errnum} is zero: return a pointer to condition object representing a successful operation.
If @var{errnum} is not a valid @code{errno} code for the underlying platform: return a pointer to
condition object representing an invalid code.
@end deftypefun


@deftypefun {cce_condition_t const *} cce_condition_new_errno_clear (void)
Consume the current value of @code{errno} and return the return value of
@cfunc{cce_condition_new_errno} applied to it.  Before returning: @code{errno} is reset to zero.
@end deftypefun


@deftypefn {Inline Function} bool cce_condition_is_errno (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is a condition object of type @emph{errno}; otherwise return @cfalse{}.
@end deftypefn


@deftypefn {Generic Macro} {cce_condition_errno_t const *} cce_condition_errno (cce_destination_t @var{L})
@deftypefnx {Generic Macro} {cce_condition_errno_t const *} cce_condition_errno (cce_condition_t * @var{C})
@deftypefnx {Generic Macro} {cce_condition_errno_t const *} cce_condition_errno (cce_condition_errno_t * @var{C})
@deftypefnx {Generic Macro} {cce_condition_errno_t const *} cce_condition_errno (cce_condition_t const * @var{C})
@deftypefnx {Generic Macro} {cce_condition_errno_t const *} cce_condition_errno (cce_condition_errno_t const * @var{C})
This generic macro dispatches its expansion according to its argument's type.  Cast a pointer to a
pointer to @objtype{cce_condition_errno_t}.

This macro performs compile--time type--checking so that the cast operation is applied only to
values of suitable types; we can apply this macro to pointers of all the types defined by
@value{PACKAGE} for which it makes sense.
@end deftypefn


@deftypevr {Dynamic Constant} {cce_descriptor_errno_t const * const} cce_descriptor_errno_ptr
Pointer to a statically allocated structure representing the condition descriptor of all the
@emph{errno} condition objects.
@end deftypevr


@deftypefun int cce_ref_condition_errno_errnum (cce_condition_t const * @var{C})
Return the value of the field @code{errnum} in the condition object @var{C} of type
@objtype{cce_condition_errno_t}
@end deftypefun


@deftypefun {char const *} cce_ref_condition_errno_message (cce_condition_t const * @var{C})
Return the value of the field @code{message} in the condition object @var{C} of type
@objtype{cce_condition_errno_t}
@end deftypefun

@c page
@node conditions math
@section Predefined mathematical conditions


@menu
* conditions math error::       Error computing a mathematical expression.
* conditions math nan::         Mathematical not-a-number error.
* conditions math infinity::    Mathematical infinity error.
* conditions math overflow::    Mathematical overflow error.
* conditions math underflow::   Mathematical underflow error.
@end menu

@c page
@node conditions math error
@subsection Error computing a mathematical expression


The @dfn{mathematical error exceptional--condition object} has the purpose of describing an
exceptional condition caused by attempting to compute an invalid mathematical expression.

There should be only one @emph{mathematical error} condition object: the one predefined by
@value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_descriptor_math_error_t
Structure type representing the descriptor for @emph{mathematical error} condition objects.  This
descriptor has the @emph{runtime error} descriptor as parent.  It has the following public fields:

@table @code
@item cce_descriptor_t descriptor
Core values of the exceptional--condition object--type descriptor.
@end table
@end deftp


@deftp {Struct Typedef} cce_condition_math_error_t
Structure type representing an @emph{mathematical error} condition object.
@end deftp


@deftypefun void cce_condition_init_math_error (cce_condition_math_error_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{cce_condition_math_error_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cce_condition_new_math_error (void)
Return a pointer to the statically allocated structure representing the single @emph{mathematical
error} condition object.
@end deftypefun


@deftypefun bool cce_is_condition_math_error (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{mathematical error} condition object; otherwise return
@cfalse{}.
@end deftypefun


@deftypefn {Generic Macro} {cce_condition_math_error_t const *} cce_condition_math_error (cce_destination_t @var{L})
@deftypefnx {Generic Macro} {cce_condition_math_error_t const *} cce_condition_math_error (cce_condition_t * @var{C})
@deftypefnx {Generic Macro} {cce_condition_math_error_t const *} cce_condition_math_error (cce_condition_t const * @var{C})
This generic macro dispatches its expansion according to its argument's type.  Cast a pointer to
@objtype{cce_condition_math_error_t}.

This macro performs compile--time type--checking so that the cast operation is applied only to
values of suitable types; we can apply this macro to pointers of all the types defined by
@value{PACKAGE} for which it makes sense.
@end deftypefn


@deftypevr {Dynamic Constant} {cce_descriptor_math_error_t const * const} cce_descriptor_math_error_ptr
Pointer to a statically allocated structure representing the @emph{mathematical error} condition
descriptor for the single @emph{mathematical error} condition object.
@end deftypevr


@deftypevr {Dynamic Constant} {cce_condition_math_error_t const * const} cce_condition_math_error_ptr
Pointer to a statically allocated structure representing the @emph{mathematical error} condition object.
@end deftypevr

@c page
@node conditions math nan
@subsection Mathematical not-a-number error


The @dfn{mathematical not--a--number exceptional--condition object} has the purpose of describing an
exceptional condition caused by not--a--number result while computing a mathematical expression.

There should be only one @emph{mathematical not--a--number} condition object: the one predefined by
@value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_descriptor_math_nan_t
Structure type representing the descriptor for @emph{mathematical not--a--number} condition objects.
This descriptor has the @emph{mathematical error} descriptor as parent.  It has the following public fields:

@table @code
@item cce_descriptor_t descriptor
Core values of the exceptional--condition object--type descriptor.
@end table
@end deftp


@deftp {Struct Typedef} cce_condition_math_nan_t
Structure type representing an @emph{mathematical not--a--number} condition object.
@end deftp


@deftypefun void cce_condition_init_math_nan (cce_condition_math_nan_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{cce_condition_math_nan_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cce_condition_new_math_nan (void)
Return a pointer to the statically allocated structure representing the single @emph{mathematical
not--a--number} condition object.
@end deftypefun


@deftypefun bool cce_is_condition_math_nan (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{mathematical not--a--number} condition object; otherwise
return @cfalse{}.
@end deftypefun


@deftypefn {Generic Macro} {cce_condition_math_nan_t const *} cce_condition_math_nan (cce_destination_t @var{L})
@deftypefnx {Generic Macro} {cce_condition_math_nan_t const *} cce_condition_math_nan (cce_condition_t * @var{C})
@deftypefnx {Generic Macro} {cce_condition_math_nan_t const *} cce_condition_math_nan (cce_condition_t const * @var{C})
This generic macro dispatches its expansion according to its argument's type.  Cast a pointer to
@objtype{cce_condition_math_nan_t}.

This macro performs compile--time type--checking so that the cast operation is applied only to
values of suitable types; we can apply this macro to pointers of all the types defined by
@value{PACKAGE} for which it makes sense.
@end deftypefn


@deftypevr {Dynamic Constant} {cce_descriptor_math_nan_t const * const} cce_descriptor_math_nan_ptr
Pointer to a statically allocated structure representing the @emph{mathematical not--a--number} condition
descriptor for the single @emph{mathematical not--a--number} condition object.
@end deftypevr


@deftypevr {Dynamic Constant} {cce_condition_math_nan_t const * const} cce_condition_math_nan_ptr
Pointer to a statically allocated structure representing the @emph{mathematical not--a--number} condition object.
@end deftypevr

@c page
@node conditions math infinity
@subsection Mathematical infinity error


The @dfn{mathematical infinity exceptional--condition object} has the purpose of describing an
exceptional condition caused by an infinite result while computing a mathematical expression.

There should be only one @emph{mathematical infinity} condition object: the one predefined by
@value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_descriptor_math_infinity_t
Structure type representing the descriptor for @emph{mathematical infinity} condition objects.  This
descriptor has the @emph{mathematical error} descriptor as parent.  It has the following public fields:

@table @code
@item cce_descriptor_t descriptor
Core values of the exceptional--condition object--type descriptor.
@end table
@end deftp


@deftp {Struct Typedef} cce_condition_math_infinity_t
Structure type representing an @emph{mathematical infinity} condition object.
@end deftp


@deftypefun void cce_condition_init_math_infinity (cce_condition_math_infinity_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{cce_condition_math_infinity_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cce_condition_new_math_infinity (void)
Return a pointer to the statically allocated structure representing the single @emph{mathematical
infinity} condition object.
@end deftypefun


@deftypefun bool cce_is_condition_math_infinity (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{mathematical infinity} condition object; otherwise return
@cfalse{}.
@end deftypefun


@deftypefn {Generic Macro} {cce_condition_math_infinity_t const *} cce_condition_math_infinity (cce_destination_t @var{L})
@deftypefnx {Generic Macro} {cce_condition_math_infinity_t const *} cce_condition_math_infinity (cce_condition_t * @var{C})
@deftypefnx {Generic Macro} {cce_condition_math_infinity_t const *} cce_condition_math_infinity (cce_condition_t const * @var{C})
This generic macro dispatches its expansion according to its argument's type.  Cast a pointer to
@objtype{cce_condition_math_infinity_t}.

This macro performs compile--time type--checking so that the cast operation is applied only to
values of suitable types; we can apply this macro to pointers of all the types defined by
@value{PACKAGE} for which it makes sense.
@end deftypefn


@deftypevr {Dynamic Constant} {cce_descriptor_math_infinity_t const * const} cce_descriptor_math_infinity_ptr
Pointer to a statically allocated structure representing the @emph{mathematical infinity} condition
descriptor for the single @emph{mathematical infinity} condition object.
@end deftypevr


@deftypevr {Dynamic Constant} {cce_condition_math_infinity_t const * const} cce_condition_math_infinity_ptr
Pointer to a statically allocated structure representing the @emph{mathematical infinity} condition
object.
@end deftypevr

@c page
@node conditions math overflow
@subsection Mathematical overflow error


The @dfn{mathematical overflow exceptional--condition object} has the purpose of describing an
exceptional condition caused by an overflow while computing a mathematical expression.

There should be only one @emph{mathematical overflow} condition object: the one predefined by
@value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_descriptor_math_overflow_t
Structure type representing the descriptor for @emph{mathematical overflow} condition objects.  This
descriptor has the @emph{mathematical error} descriptor as parent.  It has the following public fields:

@table @code
@item cce_descriptor_t descriptor
Core values of the exceptional--condition object--type descriptor.
@end table
@end deftp


@deftp {Struct Typedef} cce_condition_math_overflow_t
Structure type representing an @emph{mathematical overflow} condition object.
@end deftp


@deftypefun void cce_condition_init_math_overflow (cce_condition_math_overflow_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{cce_condition_math_overflow_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cce_condition_new_math_overflow (void)
Return a pointer to the statically allocated structure representing the single @emph{mathematical
overflow} condition object.
@end deftypefun


@deftypefun bool cce_is_condition_math_overflow (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{mathematical overflow} condition object; otherwise return
@cfalse{}.
@end deftypefun


@deftypefn {Generic Macro} {cce_condition_math_overflow_t const *} cce_condition_math_overflow (cce_destination_t @var{L})
@deftypefnx {Generic Macro} {cce_condition_math_overflow_t const *} cce_condition_math_overflow (cce_condition_t * @var{C})
@deftypefnx {Generic Macro} {cce_condition_math_overflow_t const *} cce_condition_math_overflow (cce_condition_t const * @var{C})
This generic macro dispatches its expansion according to its argument's type.  Cast a pointer to
@objtype{cce_condition_math_overflow_t}.

This macro performs compile--time type--checking so that the cast operation is applied only to
values of suitable types; we can apply this macro to pointers of all the types defined by
@value{PACKAGE} for which it makes sense.
@end deftypefn


@deftypevr {Dynamic Constant} {cce_descriptor_math_overflow_t const * const} cce_descriptor_math_overflow_ptr
Pointer to a statically allocated structure representing the @emph{mathematical overflow} condition
descriptor for the single @emph{mathematical overflow} condition object.
@end deftypevr


@deftypevr {Dynamic Constant} {cce_condition_math_overflow_t const * const} cce_condition_math_overflow_ptr
Pointer to a statically allocated structure representing the @emph{mathematical overflow} condition object.
@end deftypevr

@c page
@node conditions math underflow
@subsection Mathematical underflow error


The @dfn{mathematical underflow exceptional--condition object} has the purpose of describing an
exceptional condition caused by an underflow while computing a mathematical expression.

There should be only one @emph{mathematical underflow} condition object: the one predefined by
@value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_descriptor_math_underflow_t
Structure type representing the descriptor for @emph{mathematical underflow} condition objects.
This descriptor has the @emph{mathematical error} descriptor as parent.  It has the following public
fields:

@table @code
@item cce_descriptor_t descriptor
Core values of the exceptional--condition object--type descriptor.
@end table
@end deftp


@deftp {Struct Typedef} cce_condition_math_underflow_t
Structure type representing an @emph{mathematical underflow} condition object.
@end deftp


@deftypefun void cce_condition_init_math_underflow (cce_condition_math_underflow_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{cce_condition_math_underflow_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cce_condition_new_math_underflow (void)
Return a pointer to the statically allocated structure representing the single @emph{mathematical
underflow} condition object.
@end deftypefun


@deftypefun bool cce_is_condition_math_underflow (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{mathematical underflow} condition object; otherwise return
@cfalse{}.
@end deftypefun


@deftypefn {Generic Macro} {cce_condition_math_underflow_t const *} cce_condition_math_underflow (cce_destination_t @var{L})
@deftypefnx {Generic Macro} {cce_condition_math_underflow_t const *} cce_condition_math_underflow (cce_condition_t * @var{C})
@deftypefnx {Generic Macro} {cce_condition_math_underflow_t const *} cce_condition_math_underflow (cce_condition_t const * @var{C})
This generic macro dispatches its expansion according to its argument's type.  Cast a pointer to
@objtype{cce_condition_math_underflow_t}.

This macro performs compile--time type--checking so that the cast operation is applied only to
values of suitable types; we can apply this macro to pointers of all the types defined by
@value{PACKAGE} for which it makes sense.
@end deftypefn


@deftypevr {Dynamic Constant} {cce_descriptor_math_underflow_t const * const} cce_descriptor_math_underflow_ptr
Pointer to a statically allocated structure representing the @emph{mathematical underflow} condition
descriptor for the single @emph{mathematical underflow} condition object.
@end deftypevr


@deftypevr {Dynamic Constant} {cce_condition_math_underflow_t const * const} cce_condition_math_underflow_ptr
Pointer to a statically allocated structure representing the @emph{mathematical underflow} condition
object.
@end deftypevr

@c page
@node conditions custom
@section Defining custom condition objects


The source distribution of @value{PACKAGE} comes with coding examples under the @file{examples}
directory of the source tree; we can take that code and use it as a starting point.

@c page
@node system
@chapter System call adapters


@value{PACKAGE} defines function wrappers for some basic @posix{} system calls.  Each wrapper
accepts a pointer to @objtype{cce_location_t} as argument and, in case of error, it will perform a
non--local exit by jumping to the selected location.

The wrapper functions accept the same arguments of the system calls and return the same return value
of the system calls (if they complete successfully).

All the wrappers reset @code{errno} to zero before performing the system call and reset it to zero
before returning.  In case of error: the raised exceptional condition objects are of type
@objtype{cce_condition_errno_t}.

@menu
* system memory::               Memory allocation.
@end menu

@c page
@node system memory
@section Memory allocation


@menu
* system memory core::          Core memory allocation functions.
* system memory handlers::      Handlers for allocated memory.
* system memory gmalloc::       Guarded allocation: @cfunc{malloc}.
* system memory gcalloc::       Guarded allocation: @cfunc{calloc}.
* system memory grealloc::      Guarded allocation: @cfunc{realloc}.
@end menu

@c page
@node system memory core
@subsection Core memory allocation functions


The following symbols are defined in the header file @file{ccexceptions.h}.


@deftypefun {void *} cce_sys_malloc (cce_destination_t @var{L}, size_t @var{size})
Wrapper for @cfunc{malloc}.  This function never returns @cnull{}.
@end deftypefun


@deftypefun {void *} cce_sys_realloc (cce_destination_t @var{L}, void * @var{old_P}, size_t @var{newsize})
Wrapper for @cfunc{realloc}.  This function never returns @cnull{}.
@end deftypefun


@deftypefun {void *} cce_sys_calloc (cce_destination_t @var{L}, size_t @var{count}, size_t @var{eltsize})
Wrapper for @cfunc{calloc}.  This function never returns @cnull{}.
@end deftypefun

@c page
@node system memory handlers
@subsection Handlers for allocated memory


We can handle memory that must be released with the standard function @cfunc{free} as follows:

@example
cce_location_t  L[1];
cce_handler_t   P_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  void *        P = cce_sys_malloc(L, 4096);
  cce_clean_handler_malloc_init(L, P_H, P);
  cce_run_clean_handlers(L);
@}
@end example


@deftypefun void cce_clean_handler_malloc_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, void * @var{P})
@deftypefunx void cce_cleanup_handler_malloc_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, void * @var{P})
@deftypefunx void cce_error_handler_malloc_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, void * @var{P})
Register @var{H} as clean or error handler in the context of @var{L}.  The handler function will
release the memory block referenced by @var{P} using the standard function @cfunc{free}.
@end deftypefun


@deftypefn {Preprocessor Macro} void cce_handler_malloc_init (cce_destination_t @var{L}, cce_clean_handler_t * @var{P_H}, void * @var{P})
@deftypefnx {Preprocessor Macro} void cce_handler_malloc_init (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, void * @var{P})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{P_H}; if the type is:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{cce_clean_handler_malloc_init}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{cce_error_handler_malloc_init}.
@end table
@end deftypefn

@c page
@node system memory gmalloc
@subsection Guarded allocation: @cfunc{malloc}


To allocate memory using a clean handler with a guarded function, we can do:

@example
cce_location_t          L[1];
cce_clean_handler_t     P_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  void *  P = cce_sys_malloc_guarded(L, P_H, 1024);

  /* Do something with P. */
  cce_run_clean_handlers(L);
@}
@end example

@noindent
while to use an error handler we can do:

@example
cce_location_t          L[1];
cce_error_handler_t     P_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  void *  P = cce_sys_malloc_guarded(L, P_H, 1024);

  /* Do something with P. */
  cce_run_clean_handlers(L);
@}
@end example


@deftypefun {void *} cce_sys_malloc_guarded_clean (cce_destination_t @var{L}, cce_clean_handler_t * @var{P_H}, size_t @var{size})
@deftypefunx {void *} cce_sys_malloc_guarded_cleanup (cce_destination_t @var{L}, cce_clean_handler_t * @var{P_H}, size_t @var{size})
Like @cfunc{cce_sys_malloc}, but register the resulting pointer in the handler referenced by
@var{P_H}.
@end deftypefun


@deftypefun {void *} cce_sys_malloc_guarded_error (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, size_t @var{size})
Like @cfunc{cce_sys_malloc}, but register the resulting pointer in the handler referenced by
@var{P_H}.
@end deftypefun


@deftypefn {Preprocessor Macro} {void *} cce_sys_malloc_guarded (cce_destination_t @var{L}, cce_clean_handler_t * @var{P_H}, size_t @var{size})
@deftypefnx {Preprocessor Macro} {void *} cce_sys_malloc_guarded (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, size_t @var{size})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{P_H}; if the type is:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{cce_sys_malloc_guarded_clean}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{cce_sys_malloc_guarded_error}.
@end table
@end deftypefn

@c page
@node system memory gcalloc
@subsection Guarded allocation: @cfunc{calloc}


@deftypefun {void *} cce_sys_calloc_guarded_clean (cce_destination_t @var{L}, cce_clean_handler_t * @var{P_H}, size_t @var{count}, size_t @var{eltsize})
@deftypefunx {void *} cce_sys_calloc_guarded_cleanup (cce_destination_t @var{L}, cce_clean_handler_t * @var{P_H}, size_t @var{count}, size_t @var{eltsize})
Like @cfunc{cce_sys_calloc}, but register the resulting pointer in the handler referenced by
@var{P_H}.
@end deftypefun


@deftypefun {void *} cce_sys_calloc_guarded_error (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, size_t @var{count}, size_t @var{eltsize})
Like @cfunc{cce_sys_calloc}, but register the resulting pointer in the handler referenced by
@var{P_H}.
@end deftypefun


@deftypefn {Preprocessor Macro} {void *} cce_sys_calloc_guarded (cce_destination_t @var{L}, cce_clean_handler_t * @var{P_H}, size_t @var{count}, size_t @var{eltsize})
@deftypefnx {Preprocessor Macro} {void *} cce_sys_calloc_guarded (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, size_t @var{count}, size_t @var{eltsize})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{P_H}; if the type is:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{cce_sys_calloc_guarded_clean}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{cce_sys_calloc_guarded_error}.
@end table
@end deftypefn

@c page
@node system memory grealloc
@subsection Guarded allocation: @cfunc{realloc}


@deftypefun {void *} cce_sys_realloc_guarded_clean (cce_destination_t @var{L}, cce_clean_handler_t * @var{P_H}, void * @var{old_P}, size_t @var{newsize})
@deftypefunx {void *} cce_sys_realloc_guarded_cleanup (cce_destination_t @var{L}, cce_clean_handler_t * @var{P_H}, void * @var{old_P}, size_t @var{newsize})
Like @cfunc{cce_sys_realloc}, but register the resulting pointer in the handler referenced by
@var{P_H}.  The handler is updated to reference the new memory pointer.  If, upon entering this
function, the handler @var{P_H} does not reference the pointer @var{old_P}: raise an exception by
performing a non--local exit to @var{L}, with condition object of type
@objtype{cce_condition_invalid_argument_t}.
@end deftypefun


@deftypefun {void *} cce_sys_realloc_guarded_error (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, void * @var{old_P}, size_t @var{newsize})
Like @cfunc{cce_sys_realloc}, but register the resulting pointer in the handler referenced by
@var{P_H}.  The handler is updated to reference the new memory pointer.  If, upon entering this
function, the handler @var{P_H} does not reference the pointer @var{old_P}: raise an exception by
performing a non--local exit to @var{L}, with condition object of type
@objtype{cce_condition_invalid_argument_t}.
@end deftypefun


@deftypefn {Preprocessor Macro} {void *} cce_sys_realloc_guarded (cce_destination_t @var{L}, cce_clean_handler_t * @var{P_H}, void * @var{old_P}, size_t @var{newsize})
@deftypefnx {Preprocessor Macro} {void *} cce_sys_realloc_guarded (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, void * @var{old_P}, size_t @var{newsize})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{P_H}; if the type is:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{cce_sys_realloc_guarded_clean}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{cce_sys_realloc_guarded_error}.
@end table
@end deftypefn

@c page
@node tracing
@chapter Printing execution traces


When code using @value{PACKAGE} is compiled with the preprocessor macro @code{CCEXCEPTIONS_TRACE}
defined before including @file{ccexceptions.h}: some tracing features are enabled.  It means debug
messages are printed on @code{stderr} following the execution path of raised exceptions representing
errors.  The affected functions and macros are:

@example
cce_location
cce_raise
cce_run_error_handlers_raise
cce_run_error_handlers_final
cce_run_clean_handlers_raise
cce_run_clean_handlers_final
@end example

Tracing features are completely transparent to the client code: we must do nothing different when
tracing is enabled.

As example, when the following code is run:

@example
#define CCEXCEPTIONS_TRACE      1
#include <ccexceptions.h>
#include <stdio.h>
#include <stdlib.h>

void
test_tracing_sub_sub_sub (cce_destination_t upper_L)
@{
  cce_location_t        L[1];

  if (cce_location(L)) @{
    cce_run_error_handlers_raise(L, upper_L);
  @} else @{
    cce_raise(L, cce_condition_new_unknown());
    cce_run_clean_handlers(L);
  @}
@}

void
test_tracing_sub_sub (cce_destination_t upper_L)
@{
  cce_location_t        L[1];

  if (cce_location(L)) @{
    cce_run_error_handlers_raise(L, upper_L);
  @} else @{
    test_tracing_sub_sub_sub(L);
    cce_run_clean_handlers(L);
  @}
@}

void
test_tracing_sub (cce_destination_t upper_L)
@{
  cce_location_t        L[1];

  if (cce_location(L)) @{
    cce_run_error_handlers_raise(L, upper_L);
  @} else @{
    test_tracing_sub_sub(L);
    cce_run_clean_handlers(L);
  @}
@}

void
test_tracing (void)
@{
  cce_location_t        L[1];

  if (cce_location(L)) @{
    cce_run_error_handlers_final(L);
  @} else @{
    test_tracing_sub(L);
    cce_run_clean_handlers(L);
  @}
@}

int
main (void)
@{
  test_tracing();
@}
@end example

@noindent
it prints:

@smallexample
raising:    ../tests/tracing.c:48, test_tracing_sub_sub_sub(): Unknown exceptional condition
catching:   ../tests/tracing.c:45, test_tracing_sub_sub_sub(): Unknown exceptional condition
re-raising: ../tests/tracing.c:46, test_tracing_sub_sub_sub(): Unknown exceptional condition
catching:   ../tests/tracing.c:58, test_tracing_sub_sub(): Unknown exceptional condition
re-raising: ../tests/tracing.c:59, test_tracing_sub_sub(): Unknown exceptional condition
catching:   ../tests/tracing.c:71, test_tracing_sub(): Unknown exceptional condition
re-raising: ../tests/tracing.c:72, test_tracing_sub(): Unknown exceptional condition
catching:   ../tests/tracing.c:84, test_tracing(): Unknown exceptional condition
finalising: ../tests/tracing.c:85, test_tracing(): Unknown exceptional condition
@end smallexample

@c page
@node helpers
@chapter Helpers


@deffn {Preprocessor Macro} CCE_PC (@var{TYPE}, @var{X}, @var{Y})
Pointer--type cast helper.  It expands into:

@example
@var{TYPE} * @var{X} = (@var{TYPE} *) (@var{Y})
@end example

So, for example, instead of writing:

@example
cce_location_t    L[1];
cce_condition_t * C = cce_condition(L);
ccevents_timeval_invalid_t * K = (ccevents_timeval_invalid_t *) C;
@end example

@noindent
we can write:

@example
cce_location_t    L[1];
cce_condition_t * C = cce_condition(L);
CCE_PC(ccevents_timeval_invalid_t, K, C);
@end example

@noindent
or:

@example
cce_location_t    L[1];
CCE_PC(ccevents_timeval_invalid_t, C, cce_condition(L));
@end example
@end deffn


@defmac CCE_UNUSED
Preprocessor macro that is meant to expand into an attribute declaration.  If the symbol
@code{__GNUC__} is defined, the expansion is:

@example
__attribute__((__unused__))
@end example

@noindent
otherwise the expansion is the empty string.
@end defmac

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DOCUMENTATION_URL}

@noindent
the latest release of this package can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

