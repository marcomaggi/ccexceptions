\input texinfo.tex
@c %**start of header
@setfilename ccexceptions.info
@settitle CCExceptions
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCExceptions

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCExceptions

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccexceptions

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2016

@c ------------------------------------------------------------

@set GITHUB_URL                 @url{http://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BITBUCKET_URL              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DOWNLOAD_URL               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DOCUMENTATION_URL          @url{http://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C99 language library
implementing an interface to non--local exits, which is somewhat similar to exceptions handling.

The package is distributed under the terms of the @gnu{} General Public License (@gpl{}).

The latest release can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front--Cover Texts, and no
Back--Cover Texts.  A copy of the license is included in the section
entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccexceptions: (ccexceptions).       CCExceptions a C language library
                                      implementing exceptions handling.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* setjmp::                      Brief introduction to non-local exits.
* locations::                   The locations @api{}.
* handlers::                    The handlers @api{}.
* conditions::                  Exceptional condition descriptors.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C99 language library
implementing an interface to non--local exits, which is somewhat similar to exceptions handling.

This tiny library will not solve the problem of error handling in the C language, it just brings a
little order in the mess resulting from hand--coding the error handling logic.

@value{PACKAGE} installs the single header file @file{ccexceptions.h}.  All the function names in
the @api{} are prefixed with @code{cce_}; all the constant names are prefixed with @code{CCE_}; all
the type names are prefixed with @code{cce_} and suffixed with @code{_t}.

@value{PACKAGE}'s location mechanism has the following purposes:

@enumerate
@item
Implement non--local exits in a way that allows client code to be
shorter and simpler to understand.

@item
Implement non--local exit handlers to perform synchronous clean--up operations.

@item
Implement a simple exceptional condition descriptors interface.
@end enumerate

@noindent
these features come at the cost of slowing down execution in a possibly sensible way (with respect
to, for example, hand--coded @code{goto} instructions that jump to labels).

@menu
* overview linking::            Linking code with the library.
@end menu

@c page
@node overview linking
@section Linking code with the library


This package installs a data file for @command{pkg-config}, so when searching for the installed
library with the @gnu{} Autotools, we can:

@itemize
@item
Add the following macro use to @file{configure.ac}:

@example
PKG_CHECK_MODULES([CCEXCEPTIONS],[ccexceptions >= 0.1])
@end example

@noindent
which will set the variables @code{CCEXCEPTIONS_LIBS} and @code{CCEXCEPTIONS_CFLAGS}.
@end itemize

Alternatively we can use the raw @gnu{} Autoconf macros:

@example
AC_CHECK_LIB([ccexceptions],[cce_version_string],,
  [AC_MSG_FAILURE([test for CCExceptions library failed])])
AC_CHECK_HEADERS([ccexceptions.h],,
  [AC_MSG_FAILURE([test for CCExceptions header failed])])
@end example

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the
@gnu{} Autotools.  For an explanation of interface numbers as managed by
@gnu{} Libtool @xref{Libtool versioning, interface, Libtool's versioning
system, libtool, Shared library support for @gnu{}}.


@deftypefun {const char *} cce_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing
the interface version number.
@end deftypefun


@deftypefun int cce_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int cce_version_interface_revision (void)
Return an integer representing the library interface current revision
number.
@end deftypefun


@deftypefun int cce_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node setjmp
@chapter Brief introduction to non--local exits


Let's recall briefly how the standard, C language, non--local exits mechanism works; for the full
documentation refer to the C Library.  @glibcref{Non-Local Exits, Non-Local Exits}.

To use @cfunc{sigsetjmp} and @cfunc{siglongjmp} we write chunks of code like the following:

@example
#define DO_NOT_SAVE_SIGS        0
#define JMP_ERROR_CODE          1

sigjmp_buf  here;

if (sigsetjmp(here, DO_NOT_SAVE_SIGS))
  @{
    handle_the_error();
  @}
else
  @{
    do_something();
    if (an_error_occurred()) @{
      siglongjmp(here, JMP_ERROR_CODE);
    @}
    do_something_else();
  @}
@end example

@noindent
this is what happens:

@itemize
@item
When @cfunc{sigsetjmp} is invoked: it saves the current ``position'' in @var{here}, then it returns
zero.

@item
If @cfunc{siglongjmp} is not applied to @var{here}, nothing strange happens and the execution flow
goes on as usual.

@item
If @cfunc{siglongjmp} is applied to @var{here}: the execution jumps back to the call to
@cfunc{sigsetjmp} with @code{JMP_ERROR_CODE} as return value.
@end itemize

This mechanism allows us to separate the exception handling code from the main code.  By using
@var{here} as argument to nested function calls: we can perform non--local exits across functions;
something that is not possible with @code{goto} statements.

As always, care must be taken when the body allocates asynchronous resources.  For each resource:
the exception handler must detect if the allocation took place and execute release code.  For
example:

@example
#define DO_NOT_SAVE_SIGS        0
#define JMP_ERROR_CODE          1

sigjmp_buf      here;
volatile void * P = NULL;

if (sigsetjmp(here, DO_NOT_SAVE_SIGS))
  @{
    if (P)
      free(P);
  @}
else
  @{
    ...
    P = malloc(4096);
    ...
  @}
@end example

Let's see some logic example; we will assume the following preamble:

@example
#include <assert.h>
#include <stdlib.h>
#include <setjmp.h>

#define DO_NOT_SAVE_SIGS        0
#define JUMP_TO_ERROR           2
#define JUMP_TO_RETRY           3
@end example

In the following code no jump is performed; we just call @cfunc{sigsetjmp} once and never call
@cfunc{siglongjmp}:

@example
sigjmp_buf      L;
int             flag = 0, code;

code = sigsetjmp(L, DO_NOT_SAVE_SIGS);
if (code) @{
  flag = 2;
@} else @{
  flag = 1;
@}
assert(0 == code);
assert(1 == flag);
@end example

In the following code we perform a jump and handle the logic with an @code{if} statement:

@example
sigjmp_buf      L;
int             flag = 0, code;

code = sigsetjmp(L, DO_NOT_SAVE_SIGS);
if (JUMP_TO_ERROR == code) @{
  flag = 2;
@} else @{
  flag = 1;
  siglongjmp(L, JUMP_TO_ERROR);
@}
assert(JUMP_TO_ERROR == code);
assert(2 == flag);
@end example

In the following code we perform a jump and handle the logic with a @code{switch} statement:

@example
sigjmp_buf      L;
int             flag = 0, code;

code = sigsetjmp(L, DO_NOT_SAVE_SIGS);
switch (code) @{
case JUMP_TO_ERROR:
  flag = 2;
  break;
default:
  flag = 1;
  siglongjmp(L, JUMP_TO_ERROR);
@}
assert(JUMP_TO_ERROR == code);
assert(2 == flag);
@end example

In the following code we perform a jump and try an alternative body; we handle the logic with a
@code{switch} statement:

@example
sigjmp_buf      L;
int             flag = 0, code;

code = sigsetjmp(L, DO_NOT_SAVE_SIGS);
switch (code) @{
case JUMP_TO_ERROR:
  flag = 2;
  siglongjmp(L, JUMP_TO_RETRY);
  break;
case JUMP_TO_RETRY:
  // the alternative body
  flag = 3;
  break;
default:
  // the body
  flag = 1;
  siglongjmp(L, JUMP_TO_ERROR);
@}
assert(JUMP_TO_RETRY == code);
assert(3 == flag);
@end example

In the following code we perform a jump and retry the body several times:

@example
sigjmp_buf      L;
int             flag = 0, code;
volatile int    times = 0;

code = sigsetjmp(L, DO_NOT_SAVE_SIGS);
switch (code) @{
case JUMP_TO_ERROR:
  flag = 2;
  siglongjmp(L, JUMP_TO_RETRY);
  break;
default:
  if ((JUMP_TO_RETRY == code) && (times < 5)) @{
    // retrying
    ++times;
    siglongjmp(L, JUMP_TO_ERROR);
  @} else if (JUMP_TO_RETRY == code) @{
    flag = 3;
  @} else @{
    // the body
    flag = 1;
    siglongjmp(L, JUMP_TO_ERROR);
  @}
@}
assert(JUMP_TO_RETRY == code);
assert(3 == flag);
@end example

@c page
@node locations
@chapter The locations @api{}


Non--local exits are a way to transfer execution from one point to another in a program; they are
implemented by the standard C library through the @cfunc{sigsetjmp} and @cfunc{siglongjmp}
functions.  @value{PACKAGE} calls @cfunc{sigsetjmp} and @cfunc{siglongjmp} to make sure that the
signal context is not saved (consuming time) at each invocation; see the @code{setjmp(3)} manual
page for details.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_location_tag_t
Struct type representing the location context.  It contains an instance of @code{setjmp_buf} which
is the target of the @cfunc{siglongjmp} calls.  It has the following public fields:

@table @code
@item cce_condition_t * condition
Pointer to an exceptional condition descriptor.  It is set by @cfunc{cce_raise} and
@cfunc{cce_retry}.  The client code is responsible of releasing resources associated to this value.
@end table
@end deftp


@deftp {One-Element Array Typedef} cce_location_t
It is defined as follows:

@example
typedef cce_location_tag_t      cce_location_t[1];
@end example

This type is convenient to define an instance of location.
@end deftp


@deftypefun void cce_location_init (cce_location_tag_t * @var{L})
Initialise the location @var{L}, but do @strong{not} call @cfunc{sigsetjmp}.  We are not meant to
call this function directly; rather we should use the macro @cfunc{cce_location}.
@end deftypefun


@deftypefn {Preprocessor Macro} int cce_location (cce_location_tag_t * @var{L})
Initialise the location @var{L}; call @cfunc{sigsetjmp} and return its return value.
@end deftypefn


@deftypevr Constant int CCE_SUCCESS
Constant used by the library as non--local exit code.  It is defined as @code{0} and it represents
the return value of @cfunc{cce_location} at the first evaluation.
@end deftypevr


@deftypevr Constant int CCE_ERROR
Constant used by the library as non--local exit code.  It is the return value of
@cfunc{cce_location} when a non--local exit is performed by @cfunc{cce_raise}.
@end deftypevr


@deftypevr Constant int CCE_RETRY
Constant used by the library as non--local exit code.  It is the return value of
@cfunc{cce_location} when a non--local exit is performed by @cfunc{cce_retry}.
@end deftypevr


@deftypefun void cce_raise (cce_location_tag_t * @var{L}, void * @var{C})
Raise an exception associated to the destination @var{L} and with exceptional condition descriptor
@var{C}.  This function performs the call to @cfunc{siglongjmp} with code @code{CCE_ERROR}.

If @var{C} is @cnull{}: an internal, statically allocated, exceptional condition descriptor is
selected to represent an ``unknown exceptional condition''.
@end deftypefun


@deftypefun void cce_retry (cce_location_tag_t * @var{L})
Raise an exception associated to the destination @var{L} with the purpose or retrying the body
evaluation.  This function performs the call to @cfunc{siglongjmp} with code @code{CCE_RETRY}.

This function selects an internal, statically allocated, exceptional condition descriptor to
represent an ``unknown exceptional condition''.
@end deftypefun


@deftypefun {cce_condition_t *} cce_location_condition (cce_location_tag_t * @var{L})
Return the current value of the field @code{condition} in the location @var{L}.  This value is
@strong{never} @cnull{} if an exceptional condition is raised with @cfunc{cce_raise} or
@cfunc{cce_retry}.
@end deftypefun


It is suggested to use @code{switch} statements to organise the logic of location mechanisms.  The
basic scheme is as follows:

@example
cce_location_t  L;

switch (cce_location (L)) @{
case CCE_ERROR:
  handle_the_exception();
  break;

default:
  do_something();
  if (some_error()) @{
    cce_raise(L, NULL);
  @}
@}
@end example

If we want to distinguish between the main body and the retry body, we do:

@example
cce_location_t  L;

switch (cce_location (L)) @{
case CCE_ERROR:
  handle_the_exception();
  break;

case CCE_RETRY:
  retry_doing_something();
  break;

default:
  do_something();
  if (some_recoverable_error()) @{
    cce_retry(L);
  @} else if (some_error()) @{
    cce_raise(L, NULL);
  @}
@}
@end example

@noindent
and we can fall through:

@example
cce_location_t  L;

switch (cce_location (L)) @{
case CCE_ERROR:
  handle_the_exception();
  break;

case CCE_RETRY:
  prepare_to_retry();
  // fall through

default:
  do_something();
  if (some_recoverable_error()) @{
    cce_retry(L);
  @} else if (some_error()) @{
    cce_raise(L, NULL);
  @}
@}
@end example

@c page
@node handlers
@chapter The handlers @api{}


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} cce_handler_tag_t
Struct type representing a cleanup or error handler.  Instances of this type are associated to a
location by calling one of the functions @cfunc{cce_register_*_handler}.  Handlers are invoked by
calling one of the functions @cfunc{cce_run_*_handlers}.

We are meant to wrap instances of this type into an enclosing struct definition as follows:

@example
struct resource_handler_t @{
  cce_handler_tag_t	handler;
  void *		resourcep;
@};
@end example

@noindent
in which the instance of @code{cce_handler_tag_t} is the first field.

The structure has the following public fields:

@table @code
@item cce_handler_fun_t * handler_function
Pointer to the function implementing the handler.
@end table
@end deftp


@deftypefn {Function Typedef} void cce_handler_fun_t (cce_location_tag_t * @var{L}, void * @var{H})
Type of handler functions.  The argument @var{L} references the location.  The argument @var{H}
references the handler context.
@end deftypefn


@deftp {One-Element Array Typedef} cce_handler_t
It is defined as follows:

@example
typedef cce_handler_tag_t      cce_handler_t[1];
@end example

In some cases, this type is convenient to define an instance of handler structure.
@end deftp


@deftypefun void cce_register_cleanup_handler (cce_location_tag_t * @var{L}, void * @var{H})
Register the cleanup handler referenced by @var{H} in the list of handlers associated to the
location @var{L}.  The pointer @var{H} must reference an instance of structure whose first field is
a structure of type @code{cce_handler_tag_t}; such structure is meant to be allocated on the stack
frame of the function also defining the location @var{L}.

A cleanup handler is meant to be called whenever the execution flow leaves the dynamic extent of a
location, whether with an exception or as part of the successful execution path.
@end deftypefun


@deftypefun void cce_register_error_handler (cce_location_tag_t * @var{L}, void * @var{H})
Register the error handler referenced by @var{H} in the list of handlers associated to the location
@var{L}.  The pointer @var{H} must reference an instance of structure whose first field is a
structure of type @code{cce_handler_tag_t}; such structure is meant to be allocated on the stack
frame of the function also defining the location @var{L}.

An error handler is meant to be called whenever the execution flow leaves the dynamic extent of a
location in case of an exception; it must not be called as part of the successful execution path.
@end deftypefun


@deftypefun void cce_run_cleanup_handlers (cce_location_tag_t * @var{L})
Run all the cleanup handlers associated to the location @var{L}.  Each handler must return to its
caller, taking care of itself regarding internal error handling and asynchronous resources
allocation.  Handlers are called starting from the last registered one.
@end deftypefun


@deftypefun void cce_run_error_handlers (cce_location_tag_t * @var{L})
Run all the error handlers associated to the location @var{L}.  Each handler must return to its
caller, taking care of itself regarding internal error handling and asynchronous resources
allocation.  Handlers are called starting from the last registered one.
@end deftypefun


For convenience, in the following examples: we will use nested C function definitions, which are a
@gnu{} C Compiler's extension.  We could define and call a list of cleanup handlers as follows:

@example
void handler1 (cce_location_tag_t * L, void * H) @{
  do_some_cleanup();
@}
void handler2 (cce_location_tag_t * L, void * H) @{
  do_some_cleanup();
@}
void handler3 (cce_location_tag_t * L, void * H) @{
  do_some_cleanup();
@}

cce_location_t     L;
cce_handler_tag_t  H1 = @{ .handler_function = handler1 @};
cce_handler_tag_t  H2 = @{ .handler_function = handler2 @};
cce_handler_tag_t  H3 = @{ .handler_function = handler3 @};

cce_location_init(L);
cce_register_cleanup_handler(L, &H1);
cce_register_cleanup_handler(L, &H2);
cce_register_cleanup_handler(L, &H3);
cce_run_cleanup_handlers(L);
@end example

@noindent
and we could define and call a list of error handlers as follows:

@example
void handler1 (cce_location_tag_t * L, void * H) @{
  do_some_error_handling();
@}
void handler2 (cce_location_tag_t * L, void * H) @{
  do_some_error_handling();
@}
void handler3 (cce_location_tag_t * L, void * H) @{
  do_some_error_handling();
@}

cce_location_t     L;
cce_handler_tag_t  H1 = @{ .handler_function = handler1 @};
cce_handler_tag_t  H2 = @{ .handler_function = handler2 @};
cce_handler_tag_t  H3 = @{ .handler_function = handler3 @};

cce_location_init(L);
cce_register_error_handler(L, &H1);
cce_register_error_handler(L, &H2);
cce_register_error_handler(L, &H3);
cce_run_error_handlers(L);
@end example

Let's say we need to allocate memory, and to release it whenever the dynamic extent of the local
function terminates; we can organise the code as follows, using a cleanup handler:

@example
cce_location_t      L;
cce_handler_t       HP;
void *              P;

void P_handler (cce_location_tag_t * L, void * H) @{
  free(P);
@}
HP->handler_function = P_handler;

if (CCE_ERROR == cce_location(L)) @{
  cce_run_error_handlers(L);
@} else @{
  P = malloc(4096);
  if (P) @{
    cce_register_cleanup_handler(L, HP);
  @} else @{
    cce_raise(L, NULL);
  @}
  do_something(L, P);
  cce_run_cleanup_handlers(L);
@}
@end example

@noindent
whether @cfunc{do_something} raises an exception or not: the cleanup handler is invoked and the
memory is released.

Let's say we are writing a constructor and we need to allocate memory, do something and, if
successful, return the memory to the caller; we can organise the code as follows, using an error
handler in the constructor and a cleanup handler in the caller:

@example
void *
constructor (cce_location_tag_t * upper_L)
@{
  cce_location_t    L;
  cce_handler_t     HP;
  void *            P;

  void P_handler (cce_location_tag_t * L, void * H) @{
    free(P);
  @}
  HP->handler_function = P_handler;

  if (CCE_ERROR == cce_location(L)) @{
    cce_run_error_handlers(L);
    cce_raise(upper_L, NULL);
  @} else @{
    P = malloc(4096);
    if (P) @{
      cce_register_error_handler(L, HP);
    @} else @{
      cce_raise(L, NULL);
    @}
    do_some_initialisation_in(P);
    cce_run_cleanup_handlers(L);
  @}
  return P;
@}

void caller (void)
@{
  cce_location_t    L;
  cce_handler_t     HP;
  void *            P;

  void P_handler (cce_location_tag_t * L, void * H) @{
    free(P);
  @}
  HP->handler_function = P_handler;

  if (CCE_ERROR == cce_location(L)) @{
    cce_run_error_handlers(L);
  @} else @{
    P = constructor(L);
    cce_register_cleanup_handler(L, HP);
    do_something_with(P);
    cce_run_cleanup_handlers(L);
  @}
@}
@end example

@c page
@node conditions
@chapter Exceptional condition descriptors


@menu
* conditions basic::            Basic interface to conditions.
* conditions errno::            Predefined @code{errno} conditions.
@end menu

@c page
@node conditions basic
@section Basic interface to conditions


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftypefn {Function Prototype} void cce_condition_free_fun_t (void * @var{C})
Applied to a pointer to condition descriptor: release all the dynamic resources associated to the
descriptor @var{C}.
@end deftypefn


@deftypefn {Function Prototype} void cce_condition_static_message_fun_t (void * @var{C})
Applied to a pointer to condition descriptor: return a statically allocated @asciiz{} string
describing the exceptional condition @var{C}.
@end deftypefn


@deftp {Struct Typedef} cce_condition_functions_table_t
Type of structures holding a table of function pointers to handle exceptional condition
descriptors.  It has the following fields:

@table @code
@item cce_condition_free_fun_t * free
Pointer to function which releases all the dynamic resources associated to the descriptor.  This
pointer can be @cnull{}, meaning that there are no dynamic resources in the condition descriptor.

@item cce_condition_static_message_fun_t * static_message
Pointer to function which returns a statically allocated @asciiz{} string describing the exceptional
condition.
@end table
@end deftp


@deftp {Struct Typedef} cce_condition_t
Type of structure representing an exceptional condition descriptor.  It has the following fields:

@table @code
@item cce_condition_functions_table_t * table
Pointer to a table of function pointers that handle exceptional condition descriptors.
@end table
@end deftp


Given a pointer to @code{cce_condition_t} we can act upon it with the following functions.


@deftypefun void cce_condition_free (void * @var{C})
Applied to a pointer to condition descriptor: invoke the @code{free} function referenced by the
functions table.
@end deftypefun


@deftypefun {const char *} cce_condition_static_message (void * @var{C})
Applied to a pointer to condition descriptor: invoke the @code{static_message} function referenced
by the functions table.
@end deftypefun


The basic usage pattern of condition descriptors is as follows:

@example
cce_location_t      L;

if (cce_location(L))
  @{
    @{
      cce_condition_t * C = cce_location_condition(L);
      fprintf(stderr, "log: %s\n", cce_condition_static_message(C));
      cce_condition_free(C);
    @}
    cce_run_error_handlers(L);
  @} else @{
    do_something();
    if (an_error_occurred()) @{
      cce_raise(L, select_condition_descriptor());
    @}
    cce_run_cleanup_handlers(L);
  @}
@end example

If we need to hand the condition descriptor to an upper level location we can do it as follows:

@example
void
upper_function (void)
@{
  cce_location_t        L;

  if (cce_location(L))
    @{
      @{
        cce_condition_t * C = cce_location_condition(L);
        do_something_with(cce_condition_static_message(C));
        cce_condition_free(C);
      @}
      cce_run_error_handlers(L);
    @}
  else
    @{
      lower_function(L);
      cce_run_cleanup_handlers(L);
    @}
@}

void
lower_function (cce_location_tag_t * upper_L)
@{
  cce_location_t        L;

  if (cce_location(L))
    @{
      cce_run_error_handlers(L);
      cce_raise(upper_L, cce_location_condition(L));
    @}
  else
    @{
      do_something();
      if (an_error_occurred()) @{
        cce_raise(L, select_condition_descriptor());
      @}
      cce_run_cleanup_handlers(L);
    @}
@}
@end example



@c page
@node conditions errno
@section Predefined @code{errno} conditions


All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftypefun {cce_condition_t *} cce_condition_errno (int @var{errnum})
Given the @code{errno} code @var{errnum} return the pointer to condition descriptor associated to
it.  If @var{errnum} is zero: return a pointer to condition describing a successful operation.  If
@var{errnum} is not a valid @code{errno} code for the underlying platform: return a condition
descriptor that describes an invalid code.
@end deftypefun


We can think of an @code{errno} condition descriptor as the following structure:

@example
struct cce_errno_condition_t @{
  cce_condition_functions_table_t *	table;
  int					errnum;
  const char *				message;
@};
@end example

@noindent
but this type is kept opaque to the client code.

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DOCUMENTATION_URL}

@noindent
the latest release of this package can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

